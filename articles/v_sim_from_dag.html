<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Simulating Data from a known DAG • simDAG</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.4.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.4.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Simulating Data from a known DAG">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">simDAG</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.2.0.9000</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/v_covid_example.html">Simulating Covid-19 Vaccine Data using a Discrete-Time Simulation</a></li>
    <li><a class="dropdown-item" href="../articles/v_sim_discrete_time.html">Simulating Data using a Discrete-Time Approach</a></li>
    <li><a class="dropdown-item" href="../articles/v_sim_from_dag.html">Simulating Data from a known DAG</a></li>
    <li><a class="dropdown-item" href="../articles/v_using_formulas.html">Specifying Formulas in a DAG</a></li>
  </ul>
</li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changelog</a></li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/RobinDenz1/siMDAG/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="../logo.png" class="logo" alt=""><h1>Simulating Data from a known DAG</h1>
                        <h4 data-toc-skip class="author">Robin Denz</h4>
            
      
      <small class="dont-index">Source: <a href="https://github.com/RobinDenz1/siMDAG/blob/main/vignettes/v_sim_from_dag.Rmd" class="external-link"><code>vignettes/v_sim_from_dag.Rmd</code></a></small>
      <div class="d-none name"><code>v_sim_from_dag.Rmd</code></div>
    </div>

    
    
<div class="section level2">
<h2 id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<p>In this small vignette, we introduce the <code><a href="../reference/sim_from_DAG.html">sim_from_dag()</a></code>
function, which can be used to simulate complex data from arbitrary
causal directed acyclic graphs (DAGs). The simulated data may include
continuous, binary, categorical, count or time-to-event variables. This
function is most useful if the DAG is static, meaning that there are no
time-varying variables. It is theoretically possible to use this
function to simulate data from DAGs with a time structure as well, but
there are some difficulties associated with it that will be discussed
later.</p>
</div>
<div class="section level2">
<h2 id="what-are-causal-dags-and-why-use-them">What are causal DAGs and why use them?<a class="anchor" aria-label="anchor" href="#what-are-causal-dags-and-why-use-them"></a>
</h2>
<p>A causal DAG is a DAG in which all nodes correspond to variables and
the directed edges correspond to direct causal relationships between
these variables. A direct edge from node
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
to node
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>
implies that there is direct causal effect of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>.
On the other hand, if there is no edge from node
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
to node
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>,
there is no direct causal relationship between these variables. Using a
DAG in this way makes it easy to encode the causal structure of a given
system, which is very useful for causal inference. This general idea is
a centerpiece of the <strong>structural approach</strong> to causality
developed by Pearl (2002) and Spirtes et al. (1993). We strongly
encourage the reader to make themselves familiar with some of this
literature before moving on.</p>
<p>It is very simple to generate data from a defined causal DAG. To see
why we first need to introduce the concept of <strong>root
nodes</strong> and <strong>child nodes</strong>. A root node is a node
in a DAG that does not have any edges pointing to it (no incoming
arrows). A child node on the other hand is a node that has at least one
incoming edge. In other words, root nodes have no direct causes but
child nodes do. Every node pointing into another node is considered a
<strong>parent</strong> of that child node. For example, consider the
DAG in figure 1.</p>
<div class="figure" style="text-align: center">
<img src="images_v_sim_from_dag%2Fsimple_dag.png" alt="A small DAG with four nodes" width="400"><p class="caption">
A small DAG with four nodes
</p>
</div>
<p>Nodes
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>
are root nodes because they do not have any directed edges pointing into
them. Nodes
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>
on the other hand are child nodes. The parents of node
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math>
are both
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>
because both of these nodes have directed edge towards
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math>.
Note that node
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>
is not a parent of node
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>
because there is no edge from
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>
to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>.</p>
<p>As the name implies, DAGs do not have cycles. Therefore every DAG has
at least one root node. Generating data for these nodes is the first
step to simulate data for the whole DAG. Since root nodes have no
parents, we can simply generate random data from them using an
appropriate distribution. Once we have data for all root nodes, we can
generate their directly connected child nodes next as a function of the
root nodes (and perhaps additional random error). These direct child
nodes are then used as input for the next child nodes in line and so on.
This continues until every node has been generated. Since every DAG can
be topologically sorted (Chickering 1995), this will <em>always</em>
work. All we need is to specify the DAG and the functional relationship
between each node and its parents.</p>
</div>
<div class="section level2">
<h2 id="defining-the-dag">Defining the DAG<a class="anchor" aria-label="anchor" href="#defining-the-dag"></a>
</h2>
<p>Because the <code><a href="../reference/sim_from_DAG.html">sim_from_dag()</a></code> function uses the method
described above, it requires information about the causal structure and
the exact form of the relationship between child nodes and their
parents. All of this information has to be included in the
<code>dag</code> argument, which should be a <code>DAG</code> object
created using the <code><a href="../reference/empty_dag.html">empty_dag()</a></code> function and grown using
<code><a href="../reference/node.html">node()</a></code> calls as described below. This can be done
completely manually (which is the usual strategy when conducting
simulation studies) or (partially) using existing data (which may be
useful when the interest is in getting a toy data set resembling real
data as closely as possible).</p>
<p>Regardless of which strategy you want to use, first you have to
initialize an empty <code>DAG</code> object like this:</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://r-datatable.com" class="external-link">data.table</a></span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://ggplot2.tidyverse.org" class="external-link">ggplot2</a></span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/RobinDenz1/simDAG" class="external-link">simDAG</a></span><span class="op">)</span></span>
<span></span>
<span><span class="va">dag</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/empty_dag.html">empty_dag</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<p>Afterwards you can add an unlimited amount of root nodes and child
nodes to it. Multiple different types are implemented.</p>
<div class="section level3">
<h3 id="root-node-types">Root node types<a class="anchor" aria-label="anchor" href="#root-node-types"></a>
</h3>
<p>The values for the <code>root_nodes</code> are simply sampled from
some defined distributions. Therefore, any function that generates
random draws from some distribution may be used here. Popular
alternatives for continuous data are the normal-, beta-,
gamma-distributions which are implemented in base R inside the
<code><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm()</a></code>, <code><a href="https://rdrr.io/r/stats/Beta.html" class="external-link">rbeta()</a></code> and <code><a href="https://rdrr.io/r/stats/GammaDist.html" class="external-link">rgamma()</a></code>
functions. For binary or categorical data we could use the custom
functions <code><a href="../reference/rbernoulli.html">rbernoulli()</a></code> or <code><a href="../reference/rcategorical.html">rcategorical()</a></code>
instead.</p>
</div>
<div class="section level3">
<h3 id="child-node-types">Child node types<a class="anchor" aria-label="anchor" href="#child-node-types"></a>
</h3>
<p>The <code>simDAG</code> package implements the following types of
<code>child_nodes</code> directly:</p>
<ul>
<li>
<code>node_gaussian</code>: A node based on linear regression
(continuous data).</li>
<li>
<code>node_binomial</code>: A node based on logistic regression
(binary data).</li>
<li>
<code>node_multinomial</code>: A node based on multinomial logistic
regression (categorical data).</li>
<li>
<code>node_poisson</code>: A node based on poisson regression (count
data).</li>
<li>
<code>node_negative_binomial</code>: A node based on negative
binomial regression (count data).</li>
<li>
<code>node_cox</code>: A node based on cox regression (time-to-event
data).</li>
<li>
<code>node_conditional_prob</code>: A node based on conditional
probabilities (binary / categorical data).</li>
<li>
<code>node_conditional_distr</code>: A node based on conditional
distributions (any data type).</li>
</ul>
<p>All of these nodes have their own documentation page containing a
detailed description on how data is generated from them. Although this
collection of nodes covers a lot of data types, it is still a somewhat
limited collection. If, for example, we wanted to add a child node that
is normally distributed but also truncated at specific values, we could
not do this using just the offered node functions. For this reason, the
<code><a href="../reference/sim_from_DAG.html">sim_from_dag()</a></code> function also allows the user to use custom
functions as nodes, which makes it possible to model any kind of data
and any kind of relationship.</p>
</div>
<div class="section level3">
<h3 id="defining-nodes-manually">Defining nodes manually<a class="anchor" aria-label="anchor" href="#defining-nodes-manually"></a>
</h3>
<p>Suppose that node
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
in the figure above stands for <code>age</code>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>
stands for <code>sex</code>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math>
stands for the Body-Mass-Index (<code>BMI</code>) and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>
stands for <code>death</code>. We have to start by defining what the
root nodes should look like. We use the following code to define
<code>age</code> and <code>sex</code>:</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">dag</span> <span class="op">&lt;-</span> <span class="va">dag</span> <span class="op">+</span> </span>
<span>  <span class="fu"><a href="../reference/node.html">node</a></span><span class="op">(</span><span class="st">"age"</span>, type<span class="op">=</span><span class="st">"rnorm"</span>, mean<span class="op">=</span><span class="fl">50</span>, sd<span class="op">=</span><span class="fl">4</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/node.html">node</a></span><span class="op">(</span><span class="st">"sex"</span>, type<span class="op">=</span><span class="st">"rbernoulli"</span>, p<span class="op">=</span><span class="fl">0.5</span><span class="op">)</span></span></code></pre></div>
<p>All nodes are defined by calling the <code><a href="../reference/node.html">node()</a></code> function and
adding the output to the <code>dag</code> object using a simple
<code>+</code>. This syntax is heavily inspired by the
<code>simCausal</code> R-package (Sofrygin et al. 2017). Here, we assume
that <code>age</code> is a continuous normally distributed variable with
a mean of 50 and a standard deviation of 4 (If this was a real
simulation study we would probably use a truncated normal distribution
to ensure that age is not negative). This can be done by setting the
<code>dist</code> parameter to <code>"rnorm"</code>, which is the
standard R function for generating random values from a normal
distribution. All arguments listed in the <code>params</code> parameter
will be passed to this function. Similarly, we define <code>sex</code>
to be a Bernoulli distributed variable (taking only the values 0/1). We
assume that there is an even gender distribution by setting
<code>p = 0.5</code>.</p>
<p>Next, we have to define what the relationship between the child nodes
and their parents should look like. We may use the following code:</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">dag</span> <span class="op">&lt;-</span> <span class="va">dag</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/node.html">node</a></span><span class="op">(</span><span class="st">"bmi"</span>, type<span class="op">=</span><span class="st">"gaussian"</span>, parents<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"sex"</span>, <span class="st">"age"</span><span class="op">)</span>, betas<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1.1</span>, <span class="fl">0.4</span><span class="op">)</span>,</span>
<span>       intercept<span class="op">=</span><span class="fl">12</span>, error<span class="op">=</span><span class="fl">2</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/node.html">node</a></span><span class="op">(</span><span class="st">"death"</span>, type<span class="op">=</span><span class="st">"binomial"</span>, parents<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"age"</span>, <span class="st">"bmi"</span><span class="op">)</span>, betas<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0.1</span>, <span class="fl">0.3</span><span class="op">)</span>,</span>
<span>       intercept<span class="op">=</span><span class="op">-</span><span class="fl">15</span><span class="op">)</span></span></code></pre></div>
<p>Since the <code>bmi</code> node is dependent on both <code>sex</code>
and <code>age</code>, we have to list both of these nodes as the parents
of <code>bmi</code>. We then specify that the <code>bmi</code> should be
a continuous variable modeled using a linear regression by setting
<code>type="gaussian"</code>. The concrete regression equation is
defined through the use of the <code>intercept</code>,
<code>betas</code> and <code>error</code> arguments. Our specification
for the <code>bmi</code> node corresponds to the following equation:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>m</mi><mi>i</mi><mo>=</mo><mn>12</mn><mo>+</mo><mi>s</mi><mi>e</mi><mi>x</mi><mo>⋅</mo><mn>1.1</mn><mo>+</mo><mi>a</mi><mi>g</mi><mi>e</mi><mo>⋅</mo><mn>0.4</mn><mo>+</mo><mi>N</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><mn>2</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mrow><annotation encoding="application/x-tex">
bmi = 12 + sex \cdot 1.1 + age \cdot 0.4 + N(0, 2),
</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><mn>2</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">N(0, 2)</annotation></semantics></math>
indicates that the error term is modelled as a normally distributed
variable with mean 0 and a standard deviation of 2.</p>
<p>Since <code>death</code> has only two states (alive vs. dead), we use
a logistic regression model here instead. We can do this easily by
setting <code>type="binomial"</code>. The rest of the syntax essentially
stays the same. The regression equation for <code>death</code> as
described by the code above is then:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>i</mi><mi>t</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>d</mi><mi>e</mi><mi>a</mi><mi>t</mi><mi>h</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mo>−</mo><mn>15</mn><mo>+</mo><mi>a</mi><mi>g</mi><mi>e</mi><mo>⋅</mo><mn>0.1</mn><mo>+</mo><mi>b</mi><mi>m</mi><mi>i</mi><mo>⋅</mo><mn>0.3</mn><mi>.</mi></mrow><annotation encoding="application/x-tex">
logit(death) = -15 + age \cdot 0.1 + bmi \cdot 0.3.
</annotation></semantics></math></p>
<p>To check whether we got the causal relationships right, we can call
the <code><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot()</a></code> function on the DAG object. The output should
look very similar to the hand-drawn DAG above.</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">dag</span><span class="op">)</span></span>
<span><span class="co">#&gt; Loading required namespace: ggforce</span></span></code></pre></div>
<p><img src="v_sim_from_dag_files/figure-html/unnamed-chunk-6-1.png" width="672" style="display: block; margin: auto;"></p>
<p>We can also directly print the underlying structural equations using
the <code><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary()</a></code> function:</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">dag</span><span class="op">)</span></span>
<span><span class="co">#&gt; A DAG object using the following structural equations:</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt;   age ~ N(50, 4)</span></span>
<span><span class="co">#&gt;   sex ~ Bernoulli(0.5)</span></span>
<span><span class="co">#&gt;   bmi ~ N(12 + 1.1*sex + 0.4*age, 2)</span></span>
<span><span class="co">#&gt; death ~ Bernoulli(logit(-15 + 0.1*age + 0.3*bmi))</span></span></code></pre></div>
<p>This is all correct. We can now use this <code>DAG</code> object to
generate random data using the <code><a href="../reference/sim_from_DAG.html">sim_from_dag()</a></code> function:</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">42</span><span class="op">)</span></span>
<span><span class="va">sim_dat</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/sim_from_DAG.html">sim_from_dag</a></span><span class="op">(</span>dag<span class="op">=</span><span class="va">dag</span>, n_sim<span class="op">=</span><span class="fl">10000</span><span class="op">)</span></span></code></pre></div>
<p>Setting a seed for the random number generator is necessary to obtain
replicable results. The data generated using this code looks like
this:</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">sim_dat</span>, <span class="fl">5</span><span class="op">)</span></span>
<span><span class="co">#&gt;         age    sex      bmi  death</span></span>
<span><span class="co">#&gt;       &lt;num&gt; &lt;lgcl&gt;    &lt;num&gt; &lt;lgcl&gt;</span></span>
<span><span class="co">#&gt; 1: 55.48383   TRUE 33.25311  FALSE</span></span>
<span><span class="co">#&gt; 2: 47.74121  FALSE 29.58815  FALSE</span></span>
<span><span class="co">#&gt; 3: 51.45251  FALSE 30.12967  FALSE</span></span>
<span><span class="co">#&gt; 4: 52.53145   TRUE 32.07877  FALSE</span></span>
<span><span class="co">#&gt; 5: 51.61707  FALSE 36.09082   TRUE</span></span></code></pre></div>
<p>Binary variables such as <code>sex</code> and <code>death</code> are
by default treated as logical variables, because this is the most memory
efficient way to store them. We can now check the distributions and
relationships in this dataset to confirm that it indeed corresponds to
our specified causal DAG. Starting with the root nodes:</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/hist.html" class="external-link">hist</a></span><span class="op">(</span><span class="va">sim_dat</span><span class="op">$</span><span class="va">age</span><span class="op">)</span></span></code></pre></div>
<p><img src="v_sim_from_dag_files/figure-html/unnamed-chunk-10-1.png" width="672" style="display: block; margin: auto;"></p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/table.html" class="external-link">table</a></span><span class="op">(</span><span class="va">sim_dat</span><span class="op">$</span><span class="va">sex</span><span class="op">)</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; FALSE  TRUE </span></span>
<span><span class="co">#&gt;  5051  4949</span></span></code></pre></div>
<p>This seems to be correct. Note that this is a finite dataset, which
means that the results will never <em>exactly</em> match the theoretical
distributions. But it’s definitely close enough here. To check if the
child nodes were modeled correctly, we simply fit the corresponding
models using the <code><a href="https://rdrr.io/r/stats/glm.html" class="external-link">glm()</a></code> function:</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">mod_bmi</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/glm.html" class="external-link">glm</a></span><span class="op">(</span><span class="va">bmi</span> <span class="op">~</span> <span class="va">age</span> <span class="op">+</span> <span class="va">sex</span>, data<span class="op">=</span><span class="va">sim_dat</span>, family<span class="op">=</span><span class="st">"gaussian"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">mod_bmi</span><span class="op">)</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Call:</span></span>
<span><span class="co">#&gt; glm(formula = bmi ~ age + sex, family = "gaussian", data = sim_dat)</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Coefficients:</span></span>
<span><span class="co">#&gt;              Estimate Std. Error t value Pr(&gt;|t|)    </span></span>
<span><span class="co">#&gt; (Intercept) 12.184254   0.253188   48.12   &lt;2e-16 ***</span></span>
<span><span class="co">#&gt; age          0.396020   0.005039   78.58   &lt;2e-16 ***</span></span>
<span><span class="co">#&gt; sexTRUE      1.177159   0.040563   29.02   &lt;2e-16 ***</span></span>
<span><span class="co">#&gt; ---</span></span>
<span><span class="co">#&gt; Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; (Dispersion parameter for gaussian family taken to be 4.112615)</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt;     Null deviance: 70134  on 9999  degrees of freedom</span></span>
<span><span class="co">#&gt; Residual deviance: 41114  on 9997  degrees of freedom</span></span>
<span><span class="co">#&gt; AIC: 42524</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Number of Fisher Scoring iterations: 2</span></span></code></pre></div>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">mod_death</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/glm.html" class="external-link">glm</a></span><span class="op">(</span><span class="va">death</span> <span class="op">~</span> <span class="va">age</span> <span class="op">+</span> <span class="va">bmi</span>, data<span class="op">=</span><span class="va">sim_dat</span>, family<span class="op">=</span><span class="st">"binomial"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">mod_death</span><span class="op">)</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Call:</span></span>
<span><span class="co">#&gt; glm(formula = death ~ age + bmi, family = "binomial", data = sim_dat)</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Coefficients:</span></span>
<span><span class="co">#&gt;               Estimate Std. Error z value Pr(&gt;|z|)    </span></span>
<span><span class="co">#&gt; (Intercept) -14.319144   0.371511  -38.54   &lt;2e-16 ***</span></span>
<span><span class="co">#&gt; age           0.093229   0.007057   13.21   &lt;2e-16 ***</span></span>
<span><span class="co">#&gt; bmi           0.289714   0.011331   25.57   &lt;2e-16 ***</span></span>
<span><span class="co">#&gt; ---</span></span>
<span><span class="co">#&gt; Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; (Dispersion parameter for binomial family taken to be 1)</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt;     Null deviance: 13773  on 9999  degrees of freedom</span></span>
<span><span class="co">#&gt; Residual deviance: 11805  on 9997  degrees of freedom</span></span>
<span><span class="co">#&gt; AIC: 11811</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Number of Fisher Scoring iterations: 3</span></span></code></pre></div>
<p>Evidently, the coefficients do match the causal coefficients we
specified earlier.</p>
</div>
<div class="section level3">
<h3 id="defining-nodes-using-existing-data">Defining nodes using existing data<a class="anchor" aria-label="anchor" href="#defining-nodes-using-existing-data"></a>
</h3>
<p>If the data should resemble a specific real data set, it makes sense
to base the values for the causal coefficients on that specific data
set. This can be done by fitting a single model for each child node,
extracting the estimated coefficients from the fitted models and putting
those into an appropriate <code>DAG</code> object. If the assumed DAG is
big, this can be a time-extensive task. The <code><a href="../reference/dag_from_data.html">dag_from_data()</a></code>
function automates this process. This function takes a node list
containing only minimal information about the causal structure and node
type and outputs a fully specified <code>DAG</code> object.</p>
<p>For example, lets assume that the data we just generated
(<code>sim_dat</code>) was our data set of interest. Let us also assume
that we know the true underlying causal diagram and have a rough idea
about the nature of the relationship between the nodes (e.g. we know or
can reasonably guess the node type). Now all we have to do is create a
partially specified <code>DAG</code> in accordance to these assumptions
first:</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">dag</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/empty_dag.html">empty_dag</a></span><span class="op">(</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/node.html">node</a></span><span class="op">(</span><span class="st">"age"</span>, type<span class="op">=</span><span class="st">"rnorm"</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/node.html">node</a></span><span class="op">(</span><span class="st">"sex"</span>, type<span class="op">=</span><span class="st">"rbernoulli"</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/node.html">node</a></span><span class="op">(</span><span class="st">"bmi"</span>, type<span class="op">=</span><span class="st">"gaussian"</span>, parents<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"sex"</span>, <span class="st">"age"</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/node.html">node</a></span><span class="op">(</span><span class="st">"death"</span>, type<span class="op">=</span><span class="st">"binomial"</span>, parents<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"age"</span>, <span class="st">"bmi"</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>This looks a lot like the code used above, except that we are not
explicitly defining the actual beta coefficients. We only define the
causal structure and the node types. Now we can call the
<code><a href="../reference/dag_from_data.html">dag_from_data()</a></code> function:</p>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">est_dag</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/dag_from_data.html">dag_from_data</a></span><span class="op">(</span>dag<span class="op">=</span><span class="va">dag</span>, data<span class="op">=</span><span class="va">sim_dat</span><span class="op">)</span></span></code></pre></div>
<p>It returns an object that includes a fully specified
<code>DAG</code>, which can be used directly in the
<code><a href="../reference/sim_from_DAG.html">sim_from_dag()</a></code> function:</p>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">sim_dat2</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/sim_from_DAG.html">sim_from_dag</a></span><span class="op">(</span>dag<span class="op">=</span><span class="va">est_dag</span><span class="op">$</span><span class="va">dag</span>, n_sim<span class="op">=</span><span class="fl">10000</span><span class="op">)</span></span></code></pre></div>
<p>The <code><a href="../reference/dag_from_data.html">dag_from_data()</a></code> function essentially just fits the
corresponding models one by one for each node and extracts the relevant
data from the models to fill in the gaps in the empty nodes. If we set
<code>return_models</code> to <code>TRUE</code> in the
<code><a href="../reference/dag_from_data.html">dag_from_data()</a></code> function call above, we can actually see
that it used the exact same models we fit earlier to check if the
simulation was valid.</p>
</div>
</div>
<div class="section level2">
<h2 id="time-varying-covariates">Time-varying covariates<a class="anchor" aria-label="anchor" href="#time-varying-covariates"></a>
</h2>
<p>Most real data sets include time-varying covariates, e.g. variables
that are measured at multiple points in time that are subject to
changes. It is possible to generate this type of data using the
<code><a href="../reference/sim_from_DAG.html">sim_from_dag()</a></code> function as well. All we need to do is to
define an appropriate <code>DAG</code> that directly specifies how the
variables change over time. For example, we can extend the simple
<code>DAG</code> from above to include a dimension of time:</p>
<div class="figure" style="text-align: center">
<img src="images_v_sim_from_dag%2Ftime_dep_dag.png" alt="A small DAG with four nodes"><p class="caption">
A small DAG with four nodes
</p>
</div>
<p>Here, nodes
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>
are time-constant variables that only have a causal effect on the
initial state of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>,
while nodes
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>
change over time interdependently. If we want to simulate data from a
DAG that looks like this using the <code><a href="../reference/sim_from_DAG.html">sim_from_dag()</a></code> function,
we have to add a node to the for every point in time that we want to
consider.</p>
<p>We will quickly go through a somewhat simpler example, considering
only 2 points in time. We define our nodes in the following way:</p>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">dag</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/empty_dag.html">empty_dag</a></span><span class="op">(</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/node.html">node</a></span><span class="op">(</span><span class="st">"age"</span>, type<span class="op">=</span><span class="st">"rnorm"</span>, mean<span class="op">=</span><span class="fl">50</span>, sd<span class="op">=</span><span class="fl">4</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/node.html">node</a></span><span class="op">(</span><span class="st">"sex"</span>, type<span class="op">=</span><span class="st">"rbernoulli"</span>, p<span class="op">=</span><span class="fl">0.5</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/node.html">node</a></span><span class="op">(</span><span class="st">"bmi_t1"</span>, type<span class="op">=</span><span class="st">"gaussian"</span>, betas<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1.1</span>, <span class="fl">0.4</span><span class="op">)</span>, parents<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"sex"</span>, <span class="st">"age"</span><span class="op">)</span>,</span>
<span>       intercept<span class="op">=</span><span class="fl">12</span>, error<span class="op">=</span><span class="fl">2</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/node.html">node</a></span><span class="op">(</span><span class="st">"death_t1"</span>, type<span class="op">=</span><span class="st">"binomial"</span>, parents<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"age"</span>, <span class="st">"sex"</span>, <span class="st">"bmi_t1"</span><span class="op">)</span>,</span>
<span>       betas<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0.1</span>, <span class="fl">0.3</span>, <span class="fl">0.1</span><span class="op">)</span>, intercept<span class="op">=</span><span class="op">-</span><span class="fl">15</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/node.html">node</a></span><span class="op">(</span><span class="st">"bmi_t2"</span>, type<span class="op">=</span><span class="st">"gaussian"</span>, parents<span class="op">=</span><span class="st">"bmi_t1"</span>, betas<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1.1</span><span class="op">)</span>, intercept<span class="op">=</span><span class="fl">0</span>,</span>
<span>       error<span class="op">=</span><span class="fl">2</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/node.html">node</a></span><span class="op">(</span><span class="st">"death_t2"</span>, type<span class="op">=</span><span class="st">"binomial"</span>, betas<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0.1</span>, <span class="fl">0.3</span><span class="op">)</span>,</span>
<span>       parents<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"age"</span>, <span class="st">"bmi_t2"</span><span class="op">)</span>, intercept<span class="op">=</span><span class="op">-</span><span class="fl">15</span><span class="op">)</span></span>
<span></span>
<span><span class="va">sim_dat</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/sim_from_DAG.html">sim_from_dag</a></span><span class="op">(</span>dag<span class="op">=</span><span class="va">dag</span>, n_sim<span class="op">=</span><span class="fl">10000</span><span class="op">)</span></span></code></pre></div>
<p>In this example, the <code>bmi</code> at
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">t = 1</annotation></semantics></math>
is a function of both <code>sex</code> and <code>age</code>, but the
<code>bmi</code> at
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">t = 2</annotation></semantics></math>
is only a function of the previous <code>bmi</code>. The
<code>death</code> node is determined by the initial <code>age</code>
and by the time-varying <code>bmi</code>. This surely is not the most
realistic example. It is only meant to show how the
<code><a href="../reference/sim_from_DAG.html">sim_from_dag()</a></code> function may be used to incorporate
time-dependent covariates. If many points in time should be considered
or there are very complex time-dependent structures that may not be
easily described using a DAG like the one above, the
<code><a href="../reference/sim_discrete_time.html">sim_discrete_time()</a></code> function also included in this package
may be used instead.</p>
</div>
<div class="section level2">
<h2 id="references">References<a class="anchor" aria-label="anchor" href="#references"></a>
</h2>
<p>Judea Pearl (2009). Causality: Models, Reasoning and Inference. 2nd
ed. Cambridge: Cambridge University Press</p>
<p>Peter Spirtes, Clark Glymour, and Richard Scheines (2000) Causation,
Prediction, and Search. 2nd ed. The MIT Press, Cambridge</p>
<p>Chickering, D.M. (1995). A transformational characterization of
equivalent Bayesian network structures. Proceedings of the 11th
Conference on Uncertainty in Artificial Intelligence, Montreal, Canada,
87-98.</p>
<p>Oleg Sofrygin, Mark J. van der Laan, and Romain Neugebauer (2017).
simcausal R Package: Conducting Transparent and Reproducible Simulation
Studies of Causal Effect Estimation with Complex Longitudinal Data. In:
Journal of Statistical Software. 81.2, pp. 1-47</p>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Robin Denz, Katharina Meiszl.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.1.</p>
</div>

    </footer>
</div>





  </body>
</html>
