<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Simulating Complex Crossectional and Longitudinal Data using the simDAG R Package • simDAG</title>
<!-- favicons --><link rel="icon" type="image/png" sizes="96x96" href="../favicon-96x96.png">
<link rel="icon" type="”image/svg+xml”" href="../favicon.svg">
<link rel="apple-touch-icon" sizes="180x180" href="../apple-touch-icon.png">
<link rel="icon" sizes="any" href="../favicon.ico">
<link rel="manifest" href="../site.webmanifest">
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Simulating Complex Crossectional and Longitudinal Data using the simDAG R Package">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">simDAG</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.3.1</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="active nav-item"><a class="nav-link" href="../articles/simDAG.html">Get started</a></li>
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/v_sim_from_dag.html">Simulating Data from a known DAG</a></li>
    <li><a class="dropdown-item" href="../articles/v_using_formulas.html">Specifying Formulas in a DAG</a></li>
    <li><a class="dropdown-item" href="../articles/v_custom_nodes.html">Specifying Custom Node Types in a DAG</a></li>
    <li><a class="dropdown-item" href="../articles/v_sim_discrete_time.html">Simulating Data using a Discrete-Time Approach</a></li>
    <li><a class="dropdown-item" href="../articles/v_covid_example.html">Simulating Covid-19 Vaccine Data using a Discrete-Time Simulation</a></li>
    <li><a class="dropdown-item" href="../articles/v_cookbook.html">simDAG Cookbook</a></li>
  </ul>
</li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changelog</a></li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/RobinDenz1/siMDAG/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="../logo.png" class="logo" alt=""><h1>Simulating Complex Crossectional and Longitudinal Data using the simDAG R Package</h1>
                        <h4 data-toc-skip class="author">Robin Denz and
Nina Timmesfeld</h4>
            
      
      <small class="dont-index">Source: <a href="https://github.com/RobinDenz1/siMDAG/blob/main/vignettes/simDAG.Rmd" class="external-link"><code>vignettes/simDAG.Rmd</code></a></small>
      <div class="d-none name"><code>simDAG.Rmd</code></div>
    </div>

    
        <div class="abstract">
      <p class="abstract">Abstract</p>
      This introduction to the <code>simDAG</code> <code>R</code>
      Package is a (slightly) modified version of a provisionally
      accepted article in the <em>Journal of Statistical Software</em>.
      If you use this package or want to cite information contained in
      this article, please cite the arXiv version <span class="citation">(Denz and Timmesfeld 2025)</span>. <br><br>
      Generating artificial data is a crucial step when performing
      Monte-Carlo simulation studies. Depending on the planned study,
      complex data generation processes (DGP) containing multiple,
      possibly time-varying, variables with various forms of
      dependencies and data types may be required. Simulating data from
      such DGP may therefore become a difficult and time-consuming
      endeavor. The <code>simDAG</code> <code>R</code> package offers a
      standardized approach to generate data from simple and complex DGP
      based on the definition of structural equations in directed
      acyclic graphs using arbitrary functions or regression models. The
      package offers a clear syntax with an enhanced formula interface
      and directly supports generating binary, categorical, count and
      time-to-event data with arbitrary dependencies, possibly
      non-linear relationships and interactions. It additionally
      includes a framework to conduct discrete-time based simulations
      which allows the generation of longitudinal data on a
      semi-continuous time-scale. This approach may be used to generate
      time-to-event data with both recurrent or competing events and
      possibly multiple time-varying covariates, which may themselves
      have arbitrary data types. In this article we demonstrate the vast
      amount of features included in <code>simDAG</code> by replicating
      the DGP of multiple real Monte-Carlo simulation studies. <br><br>
</div>
    
<div class="section level2">
<h2 id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<div class="section level3">
<h3 id="motivation">Motivation<a class="anchor" aria-label="anchor" href="#motivation"></a>
</h3>
<p>Applied researchers and statisticians frequently use Monte-Carlo
simulation techniques in a variety of ways. They are used to estimate
required sample sizes <span class="citation">(Arnold et al.
2011)</span>, formally compare different statistical methods <span class="citation">(Morris, White, and Crowther 2019; Denz,
Klaaßen-Mielke, and Timmesfeld 2023)</span>, help design and plan
clinical trials <span class="citation">(Kimko and Duffull 2002; Nance et
al. 2024)</span> or for teaching purposes <span class="citation">(Sigal
and Chalmers 2016; Fox et al. 2022)</span>. The main reason for their
broad usage is that the researcher has full control over the true data
generation process (DGP). In general, the researcher will define a DGP
appropriate to the situation and generate multiple datasets from it.
Some statistical analysis technique is then applied to each dataset and
the results are analyzed. A crucial step in every kind of Monte-Carlo
simulation study is thus the generation of these datasets.</p>
<p>Depending on the DGP that is required by the researcher, this step
may become very difficult and time consuming. For example, some
Monte-Carlo simulations require the generation of complex longitudinal
data with variables of different types that are causally related in
various ways <span class="citation">(Asparouhov and Muthén 2020)</span>.
Some of these possible data types are continuous variables, categorical
variables, count variables or time-to-event variables. All of these
require different parametrizations and simulation strategies. If
interactions or non-linear relationships between these variables are
required, simulating data from the DGP becomes even more
challenging.</p>
<p>Generating any artificial data requires (1) a formal description of
the DGP, (2) the knowledge of an algorithm that may be used to generate
the data from this DGP, and (3) the ability to create a software
application to implement that algorithm. Although many statisticians may
have no problem with theses steps, this might not be the case for more
applied researchers. More importantly, the third step in particular may
require a high level of expertise in programming, because the resulting
program has to be validated extensively while it also has to be
computationally efficient enough to allow potentially thousands of
datasets to be generated in a reasonable amount of time. Additionally,
it also has to be flexible enough to allow the user to easily make
changes to the DGP to be useful in most cases <span class="citation">(Sofrygin, van der Laan, and Neugebauer 2017)</span>. A
comprehensive software application that automates most of the required
work would therefore be of great benefit to the scientific
community.</p>
<p>In this article we present the <code>simDAG</code> <code>R</code>
package, which offers an easy to use and consistent framework to
generate arbitrarily complex crossectional and longitudinal data. The
aim of the package is to make all three steps of the data generation
process easier by giving users a standardized way to define the desired
DGP, which can then be used directly to generate the data without
further user input. It does so by requiring the user to define a
directed acyclic graph (DAG) with additional information about the
associations between the supplied variables <span class="citation">(Pearl 2009)</span>. The package was created using the
<code>R</code> programming language <span class="citation">(R Core Team
2024)</span> and is available on the Comprehensive <code>R</code>
Archive Network (CRAN) at <a href="https://cran.r-project.org/package=simDAG" class="external-link uri">https://cran.r-project.org/package=simDAG</a>.</p>
</div>
<div class="section level3">
<h3 id="using-dags-to-define-data-generation-processes">Using DAGs to define data generation processes<a class="anchor" aria-label="anchor" href="#using-dags-to-define-data-generation-processes"></a>
</h3>
<p>In this package, the user is required to describe the desired DGP as
a causal DAG. Formally, a DAG is a mathematical graph consisting of a
set of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>V</mi><annotation encoding="application/x-tex">V</annotation></semantics></math>
nodes (or vertices) and a set of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>E</mi><annotation encoding="application/x-tex">E</annotation></semantics></math>
edges (or links) connecting pairs of nodes. As its’ name suggests, a DAG
consists only of <em>directed</em> edges and is <em>acyclic</em>,
meaning that there are no cycles when following directed paths on the
DAG <span class="citation">(Byeon and Lee 2023)</span>. A causal DAG is
a special sort of DAG in which the nodes represent random variables and
the edges represent directed causal relationships between these
variables <span class="citation">(Pearl 2009)</span>. A very simple
example containing only three nodes and no time-dependencies is given in
Figure 1. The DAG in this figure contains a directed arrow from
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math>
and from
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>
to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math>.
This translates to the assumptions that there is a direct causal effect
of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math>
and of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>
on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math>,
but no direct causal relationship between
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>
(due to the absence of an arrow between them).</p>
<div class="figure" style="text-align: center">
<img src="images_v_joss/example_dag.png" alt="An example DAG with three nodes." width="300"><p class="caption">
An example DAG with three nodes.
</p>
</div>
<p>Such DAGs are the cornerstone of the <em>structural approach</em> to
causal inference developed by <span class="citation">Pearl (2009)</span>
and <span class="citation">Spirtes, Glymour, and Scheines (2000)</span>.
They are used extensively in social research <span class="citation">(Wouk, Bauer, and Gottfredson 2019)</span>, econonomics
<span class="citation">(Imbens 2020)</span> and epidemiology <span class="citation">(Byeon and Lee 2023)</span> to encode causal
assumptions about the real underlying DGP of empirical data. For
empirical research such graphs are very useful because they give a clear
overview of the causal assumptions made by the researchers. By using
causal graphical methods such as the <em>backdoor</em> criterion <span class="citation">(Pearl 2009)</span> or the <em>frontdoor</em> criterion
<span class="citation">(Pearl 1995)</span>, it is also possible to use
such graphs to determine which variables need to be adjusted for in
order to get unbiased estimates of certain causal effects. The
<code>daggitty</code> <code>R</code> package directly implements
multiple tools for this kind of usage <span class="citation">(Textor et
al. 2016)</span>.</p>
<p>These kind of DAGs can be formally described using <em>structural
equations</em>. These equations describe how each node is distributed.
For example, a general set of structural equations that may be used to
describe the DAG in Figure 1 are:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>A</mi><mo>∼</mo></mtd><mtd columnalign="left" style="text-align: left"><msub><mi>f</mi><mi>A</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>U</mi><mi>A</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mi>B</mi><mo>∼</mo></mtd><mtd columnalign="left" style="text-align: left"><msub><mi>f</mi><mi>B</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>U</mi><mi>B</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mi>C</mi><mo>∼</mo></mtd><mtd columnalign="left" style="text-align: left"><msub><mi>f</mi><mi>C</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>A</mi><mo>,</mo><mi>B</mi><mo>,</mo><msub><mi>U</mi><mi>C</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>.</mi></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"></mtd></mtr></mtable><annotation encoding="application/x-tex">
    \begin{aligned}
        A \sim &amp; f_A(U_A), \\
        B \sim &amp; f_B(U_B), \\
        C \sim &amp; f_C(A, B, U_C). \\
    \end{aligned}
</annotation></semantics></math></p>
<p>In these equations, the unspecified functions
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>f</mi><mi>A</mi></msub><annotation encoding="application/x-tex">f_A</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>f</mi><mi>B</mi></msub><annotation encoding="application/x-tex">f_B</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>f</mi><mi>C</mi></msub><annotation encoding="application/x-tex">f_C</annotation></semantics></math>
describe how exactly the nodes are distributed, possibly conditional on
other nodes. The terms
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>U</mi><mi>A</mi></msub><annotation encoding="application/x-tex">U_A</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>U</mi><mi>B</mi></msub><annotation encoding="application/x-tex">U_B</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>U</mi><mi>C</mi></msub><annotation encoding="application/x-tex">U_C</annotation></semantics></math>
denote random errors or disturbances. If the functions in these
structural equations are not specified and some assumption on the
probability distribution of the error terms is made, this is equivalent
to a non-parametric structural equation model <span class="citation">(Pearl 2009; Sofrygin, van der Laan, and Neugebauer
2017)</span>.</p>
<p>To make the generation of data from a DAG possible, however, it is
not enough to only specify which variables are causally related to one
another. The structural equations now also have to be fully specified.
This means that the distribution functions of each node will have to be
defined in some way by the user. A popular way to do this is to use
regression models and parametric distributions <span class="citation">(Kline 2023)</span>, but in theory any kind of function
may be used, allowing the definition of arbitrarily complex DGPs.
Continuing the example from above, we could define the structural
equations of the DAG as follows:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>A</mi><mo>∼</mo></mtd><mtd columnalign="left" style="text-align: left"><mi>N</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mi>B</mi><mo>∼</mo></mtd><mtd columnalign="left" style="text-align: left"><mi>N</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mi>C</mi><mo>∼</mo></mtd><mtd columnalign="left" style="text-align: left"><mo>−</mo><mn>2</mn><mo>+</mo><mi>A</mi><mo>⋅</mo><mn>0.3</mn><mo>+</mo><mi>B</mi><mo>⋅</mo><mo>−</mo><mn>2</mn><mo>+</mo><mi>N</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mi>.</mi></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"></mtd></mtr></mtable><annotation encoding="application/x-tex">
    \begin{aligned}
        A \sim &amp; N(0, 1), \\
        B \sim &amp; N(0, 1), \\
        C \sim &amp; -2 + A\cdot0.3 + B\cdot-2 + N(0, 1). \\
    \end{aligned}
</annotation></semantics></math></p>
<p>This means that both
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>
are independent standard normally distributed variables and that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math>
follows a simple linear regression model based on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>
with an independent normally distributed error term with mean zero. Once
all structural equations and distribution functions have been defined,
data may be generated from the DAG using a fairly simple algorithm. This
algorithm essentially generates data for one node at a time, using only
the supplied definitions and the data generated in previous steps. This
step-wise method relies on the fact that every DAG can be
<em>topologically sorted</em>, which means that there is always an
ordering of the nodes such that for every link
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>u</mi><mi>i</mi></msub><mo>,</mo><msub><mi>u</mi><mi>j</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(u_i, u_j)</annotation></semantics></math>
between nodes
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>u</mi><mi>i</mi></msub><annotation encoding="application/x-tex">u_i</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>u</mi><mi>j</mi></msub><annotation encoding="application/x-tex">u_j</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>u</mi><mi>i</mi></msub><annotation encoding="application/x-tex">u_i</annotation></semantics></math>
comes before
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>u</mi><mi>j</mi></msub><annotation encoding="application/x-tex">u_j</annotation></semantics></math><span class="citation">(Kahn 1962)</span>.</p>
<p>The generation of the data starts by ordering the nodes of the graph
in such a topologically sorted way. This means that nodes in the DAG
that have no arrows pointing into them, sometimes called <em>root
nodes</em>, are processed first. Data for these kinds of nodes can be
generated by sampling from a pre-specified parametric distribution, such
as a Gaussian distribution or a beta distribution, or through any other
process, such as re-sampling based strategies <span class="citation">(Carsey and Harden 2014)</span>. Once data for these
nodes has been generated, the data for the next node in the topological
order will be generated, based on the already generated data. These
nodes are called <em>child nodes</em>, because they are dependent on
other nodes, which are called their <em>parent nodes</em> <span class="citation">(Byeon and Lee 2023)</span>. For the example DAG shown
earlier, the two possible topological sortings are:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>A</mi><mo>,</mo><mi>B</mi><mo>,</mo><mi>C</mi><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="1.0em"></mspace><mtext mathvariant="normal">and</mtext><mspace width="1.0em"></mspace><mrow><mo stretchy="true" form="prefix">(</mo><mi>B</mi><mo>,</mo><mi>A</mi><mo>,</mo><mi>C</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">
    (A, B, C) \quad \text{and} \quad (B, A, C).
</annotation></semantics></math></p>
<p>Here, both
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>
are root nodes because they do not have any parents and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math>
is a child node of both of its’ parents
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>.
To generate data for this example using the algorithm described above,
one would first generate
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
random draws from a standard normal distribution for both
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>.
Next, one would calculate the linear combination of these values as
specified by the linear regression model in the earlier Equation and add
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
random draws from another standard normal distribution to it (which
represents the error term). In <code>R</code>, this simple example could
be simulated using the following code:</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">43</span><span class="op">)</span></span>
<span><span class="va">n</span> <span class="op">&lt;-</span> <span class="fl">100</span></span>
<span></span>
<span><span class="va">A</span> <span class="op">&lt;-</span> <span class="fu">stats</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm</a></span><span class="op">(</span><span class="va">n</span><span class="op">)</span></span>
<span><span class="va">B</span> <span class="op">&lt;-</span> <span class="fu">stats</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm</a></span><span class="op">(</span><span class="va">n</span><span class="op">)</span></span>
<span><span class="va">C</span> <span class="op">&lt;-</span> <span class="op">-</span><span class="fl">2</span> <span class="op">+</span> <span class="va">A</span><span class="op">*</span><span class="fl">0.3</span> <span class="op">+</span> <span class="va">B</span><span class="op">*</span><span class="op">-</span><span class="fl">2</span> <span class="op">+</span> <span class="fu">stats</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm</a></span><span class="op">(</span><span class="va">n</span><span class="op">)</span></span></code></pre></div>
<p>Although the manual code required for this example is fairly simple,
this is no longer the case in DAGs with more nodes and/or a more complex
DGP (for example one including different data types). The
<code>simDAG</code> package offers a standardized way to define any
possible DAG and the required distribution functions to facilitate a
clear and reproducible workflow.</p>
<p>The previous explanations and the given example focused on the simple
case of crossectional data without any time-dependencies. It is,
however, fairly straightforward to include a time-varying structure into
any DAG as well by simply adding a time-index to the time-varying nodes
and repeating the node for each point in time that should be considered
<span class="citation">(Hernán and Robins 2020)</span>. The proposed
package features computationally efficient functions to automate this
process for large amounts of time-points using a <em>discrete-time
simulation</em> approach <span class="citation">(Tang, Leu, and Abbass
2020)</span>. Although this procedure relies on a discrete time scale,
it can be used to generate data on a semi-continuous time-scale by using
very small steps in time. This is described in more detail in a later
Section.</p>
<p>Note also that while causal DAGs imply a specific causal structure,
the algorithms and code described here do not necessitate that this
causal structure has to be interpreted as such in the generated data.
For example, the structural equations shown earlier state that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>
are direct causes of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math>,
but the datasets that can be generated from these equations could also
be interpreted as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>
being only associated with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math>
for unknown reasons. As long as the desired DGP can be
<em>described</em> as a DAG, which is almost always the case, this
strategy may be used effectively to generate data even for Monte-Carlo
studies <em>not</em> concerned with causal inference.</p>
<p>Although the data-generation algorithm described above is appropriate
for most applications, it may not be the best choice for validating
causal discovery methods, due to the marginal variance of each variable
increasing along the order of the topological sorting <span class="citation">(Reisach, Seiler, and Weichwald 2021)</span>. Other
methods, such as the onion method proposed by <span class="citation">Andrews and Kummerfeld (2024)</span> may be preferable
in this particular case.</p>
</div>
<div class="section level3">
<h3 id="comparison-with-existing-software">Comparison with existing software<a class="anchor" aria-label="anchor" href="#comparison-with-existing-software"></a>
</h3>
<p>There are many different software packages that may be used to
generate data in the <code>R</code> programming language and other
languages such as <code>Python</code>. It is infeasible to summarise all
of them here, so we will only focus on a few that offer functionality
similar to the <code>simDAG</code> package instead. The following review
is therefore not intended to be exhaustive. We merely aim to show how
the existing software differs from the proposed package.</p>
<p>Multiple <code>R</code> packages support the generation of synthetic
data from fully specified structural equation models. The
<code>lavaan</code> package <span class="citation">(Rosseel
2012)</span>, the <code>semTools</code> package <span class="citation">(Jorgensen et al. 2022)</span> and the
<code>simsem</code> package <span class="citation">(Pornprasertmanit et
al. 2021)</span> are a few examples. However, these packages focus soley
on structural equation models with linear relationships and as such do
not allow the generation of data with different data types. For example,
none of these packages allow the generation of time-to-event data, which
is a type of data that is often needed in simulation studies.
Specialized <code>R</code> packages such as the <code>survsim</code>
<span class="citation">(Moriña and Navarro 2017)</span>,
<code>simsurv</code> <span class="citation">(Brilleman et al.
2021)</span>, <code>rsurv</code> <span class="citation">(Demarqui
2024)</span> and <code>reda</code> <span class="citation">(Wang et al.
2022)</span> packages may be used to simulate such data instead.
Although some of these packages allow generation of recurrent events,
competing events and general multi-state time-to-event data, unlike the
<code>simDAG</code> package, none of them support arbitrary mixtures of
these data types or time-varying covariates.</p>
<p>Other packages, such as the <code>simPop</code> package <span class="citation">(Templ et al. 2017)</span> and the
<code>simFrame</code> package <span class="citation">(Alfons, Templ, and
Filzmoser 2010)</span> allow generation of more complex synthetic data
structures as well, but are mostly focused on generating data that
mimicks real datasets. Similarly, the <code>simtrial</code> package
offers very flexible tools for the generation of randomized controlled
trial data, but it would be difficult to use it to generate other data
types. Software directly based on causal DAGs as DGPs also exists.
Although it is not stated in the package documentation directly, the
<code>simstudy</code> package <span class="citation">(Goldfeld and
Wujciak-Jens 2020)</span> also relies on the DAG based algorithm
described earlier. It supports the use of different data types and
custom generation functions, but only has partial support for generation
of longitudinal data. Alternatively, the <code>Python</code> library
<code>DagSim</code> <span class="citation">(Hajj, Pensar, and Sandve
2023)</span> allows users to generate arbitrary forms of data, while
also allowing the user to supply custom functions for the data
generation process. The price for this flexibility is, however, that not
many default options are implemented in the library.</p>
<p>Finally, the <code>simcausal</code> <code>R</code> package <span class="citation">(Sofrygin, van der Laan, and Neugebauer 2017)</span> is
very similar to the <code>simDAG</code> package and was in fact a big
inspiration for it. Like the <code>simDAG</code> package, it is also
based on the causal DAG framework. The syntax for defining a DAG is
nearly the same, with some differences in how formula objects can and
should be specified. Unlike the proposed package, however, the
<code>simcausal</code> package is focused mostly on generating data for
simulation studies dealing with causal inference. As such, it also
directly supports the generation of data after performing some
interventions on the DAG <span class="citation">(Pearl 2009)</span>.
Although the proposed package lacks such functionality, it is a lot more
flexible in terms of what data can be generated. <code>simDAG</code>
supports the use of arbitrary data generation functions, the definition
of interactions, non-linear relationships and mixed model syntax in its’
formula interface and categorical input data for nodes. None of these
features are present in <code>simcausal</code> <span class="citation">(Sofrygin, van der Laan, and Neugebauer
2017)</span>.</p>
</div>
<div class="section level3">
<h3 id="organization-of-this-article">Organization of this article<a class="anchor" aria-label="anchor" href="#organization-of-this-article"></a>
</h3>
<p>First, we will introduce the most important functionality of the
proposed package by describing the core functions and the usual workflow
when employing the package. This includes a detailed description of how
to translate the theoretical description of the desired DGP into a
<code>DAG</code> object, which may then be used to generate data.
Afterwards we will illustrate the capabilities of the package by
reproducing the DGPs of multiple real Monte-Carlo simulation studies.
Two DGPs describing the generation of crossectional data and
longitudinal data with only few considered points in time will be
considered first. Afterwards, an introduction into the generation of
more complex longitudinal data utilizing the discrete-time simulation
approach is presented. Finally, the package and its potential usefulness
is discussed.</p>
</div>
</div>
<div class="section level2">
<h2 id="the-workflow">The workflow<a class="anchor" aria-label="anchor" href="#the-workflow"></a>
</h2>
<div class="section level3">
<h3 id="included-functions">Included functions<a class="anchor" aria-label="anchor" href="#included-functions"></a>
</h3>
<p>The following functions are used in a typical workflow using the
<code>simDAG</code> <code>R</code> package.</p>
<table class="table">
<colgroup>
<col width="45%">
<col width="55%">
</colgroup>
<tbody>
<tr class="odd">
<td><code><a href="../reference/empty_dag.html">empty_dag()</a></code></td>
<td>Initializes an empty <code>DAG</code> object, which should be later
filled with information on relevant nodes. <code>DAG</code> objects are
the most important data structure of this package. How to define and use
them is illustrated in more detail below.</td>
</tr>
<tr class="even">
<td>
<code><a href="../reference/node.html">node()</a></code> and <code><a href="../reference/node.html">node_td()</a></code>
</td>
<td>Can be used to define one or multiple nodes each. These functions
are typically used to fill the <code>DAG</code> objects with information
about how the respective node should be generated, e.g., which other
nodes it depends on (if any), whether it is time-dependent or not, what
kind of data type it should be and the exact structural equation that it
should follow. <code><a href="../reference/node.html">node()</a></code> can only be used to define nodes at
one specific point in time, while the <code><a href="../reference/node.html">node_td()</a></code> function
should only be used to define time-varying nodes for discrete-time
simulations.</td>
</tr>
<tr class="odd">
<td>
<code><a href="../reference/add_node.html">add_node()</a></code> or <code>DAG + node</code>
</td>
<td>Allows the definition made by <code><a href="../reference/node.html">node()</a></code> or
<code><a href="../reference/node.html">node_td()</a></code> to be added to the <code>DAG</code> object.</td>
</tr>
<tr class="even">
<td><code><a href="../reference/plot.DAG.html">plot.DAG()</a></code></td>
<td>Directly plots a <code>DAG</code> object using the
<code>ggplot2</code> library <span class="citation">(Wickham
2016)</span>.</td>
</tr>
<tr class="odd">
<td><code>summary.DAG()</code></td>
<td>May be used to print the underlying structural equations of all
nodes in a <code>DAG</code> object.</td>
</tr>
<tr class="even">
<td><code><a href="../reference/sim_from_DAG.html">sim_from_dag()</a></code></td>
<td>Is one of the two core simulation functions. Given a fully specified
<code>DAG</code> object that only includes nodes defined using
<code><a href="../reference/node.html">node()</a></code>, it randomly generates a <code>data.table</code>
<span class="citation">(Barrett et al. 2024)</span> according to the DGP
specified by the <code>DAG</code>.</td>
</tr>
<tr class="odd">
<td><code><a href="../reference/sim_discrete_time.html">sim_discrete_time()</a></code></td>
<td>Is the second core simulation function. Given a fully specified
<code>DAG</code> object that includes one or multiple nodes added using
the <code><a href="../reference/node.html">node_td()</a></code> function, and possibly one or multiple nodes
added using the <code><a href="../reference/node.html">node()</a></code> function, it randomly generates data
according to the specified DGP using a discrete-time simulation
approach. This is described in detail in a later Section.</td>
</tr>
<tr class="even">
<td><code><a href="../reference/sim_n_datasets.html">sim_n_datasets()</a></code></td>
<td>Allows users to directly generate multiple datasets from a single
<code>DAG</code>, possibly using parallel processing.</td>
</tr>
<tr class="odd">
<td><code><a href="../reference/sim2data.html">sim2data()</a></code></td>
<td>May be used to transform the output produced by the
<code><a href="../reference/sim_discrete_time.html">sim_discrete_time()</a></code> function into either the <em>wide</em>,
<em>long</em> or <em>start-stop</em> format to make further usage of the
generated data easier.</td>
</tr>
</tbody>
</table>
<p>The package additionally includes multiple functions starting with
<code>node_</code>. These functions are used to generate data of
different types and using different specifications. Usually they do not
have to be called directly by the user. Instead they are specified as
<code>type</code>s in the <code><a href="../reference/node.html">node()</a></code> or <code><a href="../reference/node.html">node_td()</a></code>
functions and only called internally. Some additional convenience
functions are also included, but are not further discussed in this
article. Instead we choose to focus on describing the core functionality
in detail and refer the interested user to the official documentation
for more information.</p>
</div>
<div class="section level3">
<h3 id="defining-the-dag">Defining the DAG<a class="anchor" aria-label="anchor" href="#defining-the-dag"></a>
</h3>
<p>Regardless of which kind of data the user want to generate, it is
always necessary to first define a <code>DAG</code> object which
adequately describes the DGP the user wants to simulate. In most cases
this should be done using the following steps:</p>
<ul>
<li>
<strong>(1)</strong> Initialize an empty <code>DAG</code> object
using the <code><a href="../reference/empty_dag.html">empty_dag()</a></code> function.</li>
<li>
<strong>(2)</strong> Define one or multiple nodes using the
<code><a href="../reference/node.html">node()</a></code> or <code><a href="../reference/node.html">node_td()</a></code> functions.</li>
<li>
<strong>(3)</strong> Add these nodes to the <code>DAG</code> using
the <code>+</code> syntax or the <code><a href="../reference/add_node.html">add_node()</a></code> function.</li>
</ul>
<p>The <code><a href="../reference/empty_dag.html">empty_dag()</a></code> function is very simple, as it does not
have any arguments. It is merely used to setup the initial
<code>DAG</code> object. The actual definition of the nodes should be
done using either the <code><a href="../reference/node.html">node()</a></code> function (node at a single
point in time) or <code><a href="../reference/node.html">node_td()</a></code> function (node that varies over
time), which have the following syntax:</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/node.html">node</a></span><span class="op">(</span><span class="va">name</span>, <span class="va">type</span>, parents<span class="op">=</span><span class="cn">NULL</span>, formula<span class="op">=</span><span class="cn">NULL</span>, <span class="va">...</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="../reference/node.html">node_td</a></span><span class="op">(</span><span class="va">name</span>, <span class="va">type</span>, parents<span class="op">=</span><span class="cn">NULL</span>, formula<span class="op">=</span><span class="cn">NULL</span>, <span class="va">...</span><span class="op">)</span></span></code></pre></div>
<p>The arguments are:</p>
<ul>
<li>
<code>name</code>: A character string of the name of the node that
should be generated, or a character vector including multiple names. If
a character vector with more than one name is supplied, multiple
independent nodes with the same definition will be added to the
<code>DAG</code> object.</li>
<li>
<code>type</code>: A character string specifying the type of the
node or any suitable function that can be used to generate data for a
node. Further details on supported node types are given in the next
Section.</li>
<li>
<code>parents</code>: If the node is a child node this argument
should contain the names of its’ parents, unless a <code>formula</code>
is supplied instead.</li>
<li>
<code>formula</code>: An optional formula object that specifies an
additive combination of coefficients and variables as required by
generalized linear models for example. This argument may be used for
most built-in node types and for user-defined functions. It allows
inclusion of internally generated dummy variables (when using
categorical variables as parents), interaction terms of arbitrarily high
orders, cubic terms and arbitrary mixed model syntax for some node
types.</li>
<li>
<code>...</code>: Additional arguments passed to the function
defined by the <code>type</code> argument.</li>
</ul>
<p>For example, the simple DAG that we described earlier may be created
using the following code:</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="st"><a href="https://github.com/RobinDenz1/simDAG" class="external-link">"simDAG"</a></span><span class="op">)</span></span>
<span><span class="va">dag</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/empty_dag.html">empty_dag</a></span><span class="op">(</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/node.html">node</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"A"</span>, <span class="st">"B"</span><span class="op">)</span>, type<span class="op">=</span><span class="st">"rnorm"</span>, mean<span class="op">=</span><span class="fl">0</span>, sd<span class="op">=</span><span class="fl">1</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/node.html">node</a></span><span class="op">(</span><span class="st">"C"</span>, type<span class="op">=</span><span class="st">"gaussian"</span>, formula<span class="op">=</span><span class="op">~</span><span class="op">-</span><span class="fl">2</span> <span class="op">+</span> <span class="va">A</span><span class="op">*</span><span class="fl">0.3</span> <span class="op">+</span> <span class="va">B</span><span class="op">*</span><span class="op">-</span><span class="fl">2</span>,</span>
<span>       error<span class="op">=</span><span class="fl">1</span><span class="op">)</span></span></code></pre></div>
<p>First, an empty <code>DAG</code> object is initialized using the
<code><a href="../reference/empty_dag.html">empty_dag()</a></code> function, to which nodes are added directly
using the <code>+</code> syntax. Here, only the <code><a href="../reference/node.html">node()</a></code>
function is required, because all nodes only have to be defined for a
single point in time, since this DAG is only supposed to describe
crossectional data. Additionally, since both
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>
have the same structural equation here, only one call to
<code><a href="../reference/node.html">node()</a></code> is needed to define both of these nodes. By setting
<code>type="rnorm"</code> and leaving both the <code>parents</code> and
the <code>formula</code> arguments at their default values, these nodes
are specified as root nodes for which values will be generated using the
<code><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm()</a></code> function with the additional arguments passed
afterwards. Because
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math>
is supposed to follow a linear regression model,
<code>type="gaussian"</code> is used here and the structural equation is
specified using the <code>formula</code> argument.</p>
<p>The result is a <code>DAG</code> object. To re-create Figure 1, users
may use the associated S3 <code><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot()</a></code> method, which internally
uses the <code>igraph</code> package <span class="citation">(Csárdi et
al. 2024)</span> to put the nodes into position and the
<code>ggplot2</code> package <span class="citation">(Wickham
2016)</span> and the <code>ggforce</code> <span class="citation">(Pedersen 2022)</span> for the actual plotting:</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="st"><a href="https://r.igraph.org/" class="external-link">"igraph"</a></span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="st"><a href="https://ggplot2.tidyverse.org" class="external-link">"ggplot2"</a></span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="st"><a href="https://ggforce.data-imaginist.com" class="external-link">"ggforce"</a></span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">dag</span>, layout<span class="op">=</span><span class="st">"as_tree"</span>, node_size<span class="op">=</span><span class="fl">0.15</span>, node_fill<span class="op">=</span><span class="st">"grey"</span>,</span>
<span>     node_text_fontface<span class="op">=</span><span class="st">"italic"</span><span class="op">)</span></span></code></pre></div>
<p><img src="simDAG_files/figure-html/unnamed-chunk-6-1.png" width="528" style="display: block; margin: auto;"></p>
<p>The output is not exactly the same as Figure 1 because of space
reasons, but it is very similar. Additionally, the underlying structural
equations may be printed directly using the associated S3
<code><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary()</a></code> method:</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">dag</span><span class="op">)</span></span>
<span><span class="co">#&gt; A DAG object using the following structural equations:</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; A ~ N(0, 1)</span></span>
<span><span class="co">#&gt; B ~ N(0, 1)</span></span>
<span><span class="co">#&gt; C ~ N(-2 + A*0.3 + B*-2, 1)</span></span></code></pre></div>
<p>Both of these methods may be useful to check whether the DAG is
defined as intended by the user, or to formally describe the DGP in a
publication.</p>
</div>
<div class="section level3">
<h3 id="supported-node-types">Supported node types<a class="anchor" aria-label="anchor" href="#supported-node-types"></a>
</h3>
<p>Different <code>type</code>s of nodes are supported, depending on
what kind of node is being specified. If the node is a root node, any
function with an argument called <code>n</code> that specifies how many
observations of some kind should be generated may be used. For example,
the base <code>R</code> <code><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif()</a></code> function may be used as a
type to generate a uniformly distributed node. Other popular choices are
<code><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm()</a></code> for normally distributed nodes or
<code><a href="https://rdrr.io/r/stats/GammaDist.html" class="external-link">rgamma()</a></code> for a gamma distributed node. For convenience, the
proposed package also includes implementations for fast Bernoulli trials
(<code><a href="../reference/rbernoulli.html">rbernoulli()</a></code>), fast sampling from discrete probability
distributions (<code><a href="../reference/rcategorical.html">rcategorical()</a></code>) and a function to set a node
to a constant value (<code><a href="../reference/rconstant.html">rconstant()</a></code>).</p>
<p>If the node has one or more parent nodes, any function that can
generate data based on these nodes and has the arguments
<code>data</code> (containing the data generated up to this point) and
<code>parents</code> (a vector with the names of the parent nodes) may
be used as <code>type</code>. Multiple popular choices are directly
implemented in this package. These include nodes based on generalized
linear models and potentially more complex functions to sample from
conditional distributions. Finally, the package also includes two
specialized functions which may only be used for discrete-time
simulations. These functions are able to generate binary or categorical
time-varying covariates, as well as multiple forms of time-to-event data
by repeatedly performing Bernoulli trials or multinomial trials over
time. More details are given in the Section on discrete-time simulation.
A brief overview over all implemented node types is given in the
following Table. Note that when using these node types, the user may
either pass the respective function directly to the <code>type</code>
argument, or use a string of the name without the <code>node_</code>
prefix.</p>
<table class="table">
<colgroup>
<col width="45%">
<col width="55%">
</colgroup>
<thead><tr class="header">
<th>Node type</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><code><a href="../reference/rbernoulli.html">rbernoulli()</a></code></td>
<td>Samples from a Bernoulli distribution</td>
</tr>
<tr class="even">
<td><code><a href="../reference/rcategorical.html">rcategorical()</a></code></td>
<td>Samples from a discrete probability distribution</td>
</tr>
<tr class="odd">
<td><code><a href="../reference/rconstant.html">rconstant()</a></code></td>
<td>Sets the node to a constant value</td>
</tr>
<tr class="even">
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><code><a href="../reference/node_gaussian.html">node_gaussian()</a></code></td>
<td>Generates a node based on a (mixed) linear regression model</td>
</tr>
<tr class="even">
<td><code><a href="../reference/node_binomial.html">node_binomial()</a></code></td>
<td>Generates a node based on a (mixed) logistic regression model</td>
</tr>
<tr class="odd">
<td><code><a href="../reference/node_conditional_prob.html">node_conditional_prob()</a></code></td>
<td>Samples from a conditional discrete probability distribution</td>
</tr>
<tr class="even">
<td><code><a href="../reference/node_conditional_distr.html">node_conditional_distr()</a></code></td>
<td>Samples from different distributions conditional on values of other
variables</td>
</tr>
<tr class="odd">
<td><code><a href="../reference/node_multinomial.html">node_multinomial()</a></code></td>
<td>Generates a node based on a multinomial regression model</td>
</tr>
<tr class="even">
<td><code><a href="../reference/node_poisson.html">node_poisson()</a></code></td>
<td>Generates a node based on a (mixed) Poisson regression model</td>
</tr>
<tr class="odd">
<td><code><a href="../reference/node_negative_binomial.html">node_negative_binomial()</a></code></td>
<td>Generates a node based on a negative binomial regression model</td>
</tr>
<tr class="even">
<td><code><a href="../reference/node_zeroinfl.html">node_zeroinfl()</a></code></td>
<td>Generates a node based on a zero-inflated Poisson or negative
binomial regression model</td>
</tr>
<tr class="odd">
<td><code><a href="../reference/node_identity.html">node_identity()</a></code></td>
<td>Generates a node based on an <code>R</code> expression that includes
previously generated nodes</td>
</tr>
<tr class="even">
<td><code><a href="../reference/node_mixture.html">node_mixture()</a></code></td>
<td>Generates a node as a mixture of other node types</td>
</tr>
<tr class="odd">
<td><code><a href="../reference/node_cox.html">node_cox()</a></code></td>
<td>Generates a node based on a Cox proportional hazards regression
model, using the method of <span class="citation">Bender, Augustin, and
Blettner (2005)</span>
</td>
</tr>
<tr class="even">
<td>
<code><a href="../reference/node_rsurv.html">node_aftreg()</a></code>, <code><a href="../reference/node_rsurv.html">node_ahreg()</a></code>,
<code><a href="../reference/node_rsurv.html">node_ehreg()</a></code>, <code><a href="../reference/node_rsurv.html">node_poreg()</a></code>,
<code><a href="../reference/node_rsurv.html">node_ypreg()</a></code>
</td>
<td>Generates a node based on various parametric survival models as
implemented in <code>rsurv</code> <span class="citation">(Demarqui
2024)</span>
</td>
</tr>
<tr class="odd">
<td></td>
<td></td>
</tr>
<tr class="even">
<td><code><a href="../reference/node_time_to_event.html">node_time_to_event()</a></code></td>
<td>A node based on repeated Bernoulli trials over time, intended to
generate time-varying variables and time-to-event nodes</td>
</tr>
<tr class="odd">
<td><code><a href="../reference/node_competing_events.html">node_competing_events()</a></code></td>
<td>A node based on repeated multinomial trials over time, intended to
generate time-varying variables and time-to-event nodes</td>
</tr>
</tbody>
</table>
<p><strong>Table 1</strong>: A brief overview over all implemented node
types. The first section contains functions that may only be used to
generate root nodes, while the second section contains functions that
may only be used to generate child nodes. Nodes in both of these
sections may be used in both <code><a href="../reference/node.html">node()</a></code> and
<code><a href="../reference/node.html">node_td()</a></code> calls. The nodes mentioned in the third section
are only meant to be used for discrete-time simulations.</p>
</div>
</div>
<div class="section level2">
<h2 id="simulating-crossectional-data">Simulating crossectional data<a class="anchor" aria-label="anchor" href="#simulating-crossectional-data"></a>
</h2>
<p>In the following Section we will illustrate how to use the
<code>simDAG</code> package to simulate more complex crossectional data.
Instead of using a made up artificial example, we will do this by
partially replicating a real Monte-Carlo simulation study by <span class="citation">Denz, Klaaßen-Mielke, and Timmesfeld (2023)</span>,
published in the prestigious peer-reviewed journal <em>Statistics in
Medicine</em>. Because this package strictly focuses on the data
generation step of Monte-Carlo studies and for reasons of brevity, we
will not reproduce the entire simulation study. Instead we will only
replicate the DGP used to generate the data for this study.</p>
<p><span class="citation">Denz, Klaaßen-Mielke, and Timmesfeld
(2023)</span> recently performed a neutral comparison study of multiple
different methods to estimate counterfactual survival curves from
crossectional observational data. In this Monte-Carlo simulation study
they wanted to investigate how different kinds of misspecifications of
nuisance models, which are used in some methods to estimate the
counterfactual survival curves, affect the estimates produced by the
different methods. To do this, a DGP was required that includes multiple
interrelated binary and continuous variables, as well as a
right-censored time-to-event variable.</p>
<p>In particular, the data sets they generated for each simulation run
included six covariates, two of which were binary
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mn>1</mn></msub><mo>,</mo><msub><mi>X</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">X_1, X_3</annotation></semantics></math>)
and four of which were continuous
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mn>2</mn></msub><mo>,</mo><msub><mi>X</mi><mn>4</mn></msub><mo>,</mo><msub><mi>X</mi><mn>5</mn></msub><mo>,</mo><msub><mi>X</mi><mn>6</mn></msub></mrow><annotation encoding="application/x-tex">X_2, X_4, X_5, X_6</annotation></semantics></math>).
It additionally included a binary treatment variable
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Z</mi><annotation encoding="application/x-tex">Z</annotation></semantics></math>)
and a right-censored time-to-event outcome
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>).
The two binary covariates
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mn>1</mn></msub><annotation encoding="application/x-tex">X_1</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mn>3</mn></msub><annotation encoding="application/x-tex">X_3</annotation></semantics></math>
followed a simple Bernoulli distribution with a success probability of
0.5.
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mn>2</mn></msub><annotation encoding="application/x-tex">X_2</annotation></semantics></math>
was generated by a linear regression model, dependent on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mn>3</mn></msub><annotation encoding="application/x-tex">X_3</annotation></semantics></math>.
The two continuous covariates
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mn>4</mn></msub><annotation encoding="application/x-tex">X_4</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mn>6</mn></msub><annotation encoding="application/x-tex">X_6</annotation></semantics></math>
were standard normally distributed, while
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mn>5</mn></msub><annotation encoding="application/x-tex">X_5</annotation></semantics></math>
was generated according to a linear regression model dependent on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mn>6</mn></msub><annotation encoding="application/x-tex">X_6</annotation></semantics></math>.
The treatment variable
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Z</mi><annotation encoding="application/x-tex">Z</annotation></semantics></math>
followed a logistic regression model, dependent on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mn>2</mn></msub><annotation encoding="application/x-tex">X_2</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mn>3</mn></msub><annotation encoding="application/x-tex">X_3</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mn>5</mn></msub><annotation encoding="application/x-tex">X_5</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mn>6</mn></msub><annotation encoding="application/x-tex">X_6</annotation></semantics></math>,
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mn>2</mn></msub><annotation encoding="application/x-tex">X_2</annotation></semantics></math>
was included as a squared term. Finally, the outcome
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>
was generated according to a Cox model, dependent on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mn>1</mn></msub><annotation encoding="application/x-tex">X_1</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mn>2</mn></msub><annotation encoding="application/x-tex">X_2</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mn>4</mn></msub><annotation encoding="application/x-tex">X_4</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mn>5</mn></msub><annotation encoding="application/x-tex">X_5</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Z</mi><annotation encoding="application/x-tex">Z</annotation></semantics></math>,
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mn>5</mn></msub><annotation encoding="application/x-tex">X_5</annotation></semantics></math>
was included as a squared term. Data for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>
was generated using the method by <span class="citation">(Bender,
Augustin, and Blettner 2005)</span>, based on a Weibull distribution
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mo>=</mo><mn>2</mn><mo>,</mo><mi>γ</mi><mo>=</mo><mn>2.4</mn></mrow><annotation encoding="application/x-tex">\lambda=2, \gamma=2.4</annotation></semantics></math>).
The time until censoring was generated independently from a second
Weibull distribution
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>γ</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">\lambda=1, \gamma=2</annotation></semantics></math>).</p>
<p>This DGP was used because it includes two confounders
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mn>2</mn></msub><annotation encoding="application/x-tex">X_2</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mn>5</mn></msub><annotation encoding="application/x-tex">X_5</annotation></semantics></math>)
for the causal effect of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Z</mi><annotation encoding="application/x-tex">Z</annotation></semantics></math>
on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>,
which are correlated with other non-confounding variables. The inclusion
of non-linear relationships allowed <span class="citation">Denz,
Klaaßen-Mielke, and Timmesfeld (2023)</span> to investigate different
kinds of misspecified models. More details on the DGP and the simulation
study itself are given in the original manuscript. To replicate the DGP
of this study, the following <code>DAG</code> definition may be
used:</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">dag</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/empty_dag.html">empty_dag</a></span><span class="op">(</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/node.html">node</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"X1"</span>, <span class="st">"X3"</span><span class="op">)</span>, type<span class="op">=</span><span class="st">"rbernoulli"</span>, p<span class="op">=</span><span class="fl">0.5</span>,</span>
<span>       output<span class="op">=</span><span class="st">"numeric"</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/node.html">node</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"X4"</span>, <span class="st">"X6"</span><span class="op">)</span>, type<span class="op">=</span><span class="st">"rnorm"</span>, mean<span class="op">=</span><span class="fl">0</span>, sd<span class="op">=</span><span class="fl">1</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/node.html">node</a></span><span class="op">(</span><span class="st">"X2"</span>, type<span class="op">=</span><span class="st">"gaussian"</span>, formula<span class="op">=</span><span class="op">~</span><span class="fl">0.3</span> <span class="op">+</span> <span class="va">X3</span><span class="op">*</span><span class="fl">0.1</span>,</span>
<span>       error<span class="op">=</span><span class="fl">1</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/node.html">node</a></span><span class="op">(</span><span class="st">"X5"</span>, type<span class="op">=</span><span class="st">"gaussian"</span>, formula<span class="op">=</span><span class="op">~</span><span class="fl">0.3</span> <span class="op">+</span> <span class="va">X6</span><span class="op">*</span><span class="fl">0.1</span>,</span>
<span>       error<span class="op">=</span><span class="fl">1</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/node.html">node</a></span><span class="op">(</span><span class="st">"Z"</span>, type<span class="op">=</span><span class="st">"binomial"</span>, formula<span class="op">=</span><span class="op">~</span><span class="op">-</span><span class="fl">1.2</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/AsIs.html" class="external-link">I</a></span><span class="op">(</span><span class="va">X2</span><span class="op">^</span><span class="fl">2</span><span class="op">)</span><span class="op">*</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="fl">3</span><span class="op">)</span></span>
<span>        <span class="op">+</span> <span class="va">X3</span><span class="op">*</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="fl">1.5</span><span class="op">)</span> <span class="op">+</span> <span class="va">X5</span><span class="op">*</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="fl">1.5</span><span class="op">)</span> <span class="op">+</span> <span class="va">X6</span><span class="op">*</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="fl">2</span><span class="op">)</span>,</span>
<span>       output<span class="op">=</span><span class="st">"numeric"</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/node.html">node</a></span><span class="op">(</span><span class="st">"T"</span>, type<span class="op">=</span><span class="st">"cox"</span>, formula<span class="op">=</span><span class="op">~</span><span class="va">X1</span><span class="op">*</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="fl">1.8</span><span class="op">)</span> <span class="op">+</span> <span class="va">X2</span><span class="op">*</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="fl">1.8</span><span class="op">)</span> <span class="op">+</span></span>
<span>        <span class="va">X4</span><span class="op">*</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="fl">1.8</span><span class="op">)</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/AsIs.html" class="external-link">I</a></span><span class="op">(</span><span class="va">X5</span><span class="op">^</span><span class="fl">2</span><span class="op">)</span><span class="op">*</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="fl">2.3</span><span class="op">)</span> <span class="op">+</span> <span class="va">Z</span><span class="op">*</span><span class="op">-</span><span class="fl">1</span>,</span>
<span>       surv_dist<span class="op">=</span><span class="st">"weibull"</span>, lambda<span class="op">=</span><span class="fl">2</span>, gamma<span class="op">=</span><span class="fl">2.4</span>,</span>
<span>       cens_dist<span class="op">=</span><span class="st">"rweibull"</span>,</span>
<span>       cens_args<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>shape<span class="op">=</span><span class="fl">1</span>, scale<span class="op">=</span><span class="fl">2</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>As before, we can define the nodes
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mn>1</mn></msub><annotation encoding="application/x-tex">X_1</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mn>3</mn></msub><annotation encoding="application/x-tex">X_3</annotation></semantics></math>
and the nodes
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mn>4</mn></msub><annotation encoding="application/x-tex">X_4</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mn>5</mn></msub><annotation encoding="application/x-tex">X_5</annotation></semantics></math>
using a single call to <code><a href="../reference/node.html">node()</a></code>, because they have the same
definition. Since only directly supported regression models are required
for this DGP, we were able to use the <code>formula</code> argument to
directly type out all of the structural equations.</p>
<p>Plotting this <code>DAG</code> using the <code><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot()</a></code> method
produces the following output:</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">dag</span>, node_size<span class="op">=</span><span class="fl">0.3</span>, node_fill<span class="op">=</span><span class="st">"grey"</span>,</span>
<span>     node_text_fontface<span class="op">=</span><span class="st">"italic"</span><span class="op">)</span></span></code></pre></div>
<p><img src="simDAG_files/figure-html/unnamed-chunk-9-1.png" width="528" style="display: block; margin: auto;"></p>
<p>The underlying structural equations are:</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">dag</span><span class="op">)</span></span>
<span><span class="co">#&gt; A DAG object using the following structural equations:</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt;   X1 ~ Bernoulli(0.5)</span></span>
<span><span class="co">#&gt;   X3 ~ Bernoulli(0.5)</span></span>
<span><span class="co">#&gt;   X4 ~ N(0, 1)</span></span>
<span><span class="co">#&gt;   X6 ~ N(0, 1)</span></span>
<span><span class="co">#&gt;   X2 ~ N(0.3 + X3*0.1, 1)</span></span>
<span><span class="co">#&gt;   X5 ~ N(0.3 + X6*0.1, 1)</span></span>
<span><span class="co">#&gt;    Z ~ Bernoulli(logit(-1.2 + I(X2^2)*log(3) + X3*log(1.5) +</span></span>
<span><span class="co">#&gt;                   X5*log(1.5) + X6*log(2)))</span></span>
<span><span class="co">#&gt; T[T] ~ (-(log(Unif(0, 1))/(2*exp(X1*log(1.8) + X2*log(1.8) +</span></span>
<span><span class="co">#&gt;          X4*log(1.8) + I(X5^2)*log(2.3) + Z*-1))))^(1/2.4)</span></span>
<span><span class="co">#&gt; T[C] ~ rweibull(shape=1, scale=2)</span></span></code></pre></div>
<p>Finally, we can generate a single <code>data.table</code> from this
<code>DAG</code> using the <code><a href="../reference/sim_from_DAG.html">sim_from_dag()</a></code> function. The
first few rows of the generated data look like this:</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="st"><a href="https://r-datatable.com" class="external-link">"data.table"</a></span><span class="op">)</span></span>
<span><span class="va">dat</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/sim_from_DAG.html">sim_from_dag</a></span><span class="op">(</span><span class="va">dag</span>, n_sim<span class="op">=</span><span class="fl">500</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Round.html" class="external-link">round</a></span><span class="op">(</span><span class="va">dat</span>, <span class="fl">3</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt;       X1    X3     X4     X6     X2     X5     Z T_time T_status</span></span>
<span><span class="co">#&gt;    &lt;num&gt; &lt;num&gt;  &lt;num&gt;  &lt;num&gt;  &lt;num&gt;  &lt;num&gt; &lt;num&gt;  &lt;num&gt;    &lt;num&gt;</span></span>
<span><span class="co">#&gt; 1:     0     0 -0.646  1.186 -0.628  1.395     1  0.318        0</span></span>
<span><span class="co">#&gt; 2:     1     0  0.968 -2.368  0.101 -0.040     0  0.135        1</span></span>
<span><span class="co">#&gt; 3:     0     0  0.125  2.012  0.662  0.694     1  0.758        1</span></span>
<span><span class="co">#&gt; 4:     0     1 -0.142 -2.610 -0.826  0.588     1  1.100        1</span></span>
<span><span class="co">#&gt; 5:     0     0 -0.273  0.632  1.462  0.007     1  0.890        1</span></span>
<span><span class="co">#&gt; 6:     1     1 -0.198  0.379  0.693  2.416     1  0.058        1</span></span></code></pre></div>
<p>Although only eight nodes were defined in the corresponding
<code>DAG</code>, it includes nine columns. The reason for this is that
nodes generated using <code>type="cox"</code> by default generate two
columns: one for the observed time and one indicating whether the
observation is right-censored or not. This is the standard data format
for such time-to-event data and one of the reasons supplied node
functions are allowed to output multiple columns at the same time. This
of course also extends to custom user-defined node <code>type</code>s.
When no censoring distribution is supplied, it would also be possible to
return only the simulated time-to-event in a single column by setting
<code>as_two_cols=FALSE</code> in the <code><a href="../reference/node.html">node()</a></code> call for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>.</p>
</div>
<div class="section level2">
<h2 id="simulating-longitudinal-data-with-few-points-in-time">Simulating longitudinal data with few points in time<a class="anchor" aria-label="anchor" href="#simulating-longitudinal-data-with-few-points-in-time"></a>
</h2>
<p>For many applications the desired DGP may contain one or more
variables that change over time. If that is the case, longitudinal data
must be generated. There are two approaches to do this using the
algorithm implemented in the proposed package: (1) defining one node per
point in time of interest and (2) constructing one node definition for
all points in time that should be considered simultaneously. In this
Section the first approach will be illustrated by replicating the DGP
that was used in the Monte-Carlo simulation study performed by <span class="citation">Gruber et al. (2015)</span>.</p>
<p>In their study, <span class="citation">Gruber et al. (2015)</span>
compared the efficiency of different methods of estimating inverse
probability weights for marginal structural models. Such models are
often used to estimate marginal causal effects of treatment-regimes from
longitudinal observational data with time-varying variables <span class="citation">(Hernán and Robins 2020)</span>. The main aim was to
quantify the benefits of using ensemble methods versus using traditional
methods, such as logistic regression models, when estimating the
required weights. Their DGP therefore required the inclusion of
time-varying variables. Below we focus on the DGP theses authors used in
their first simulation scenario.</p>
<p>Their DGP consisted of four variables: a binary treatment variable
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>,
a binary unmeasured baseline covariate
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>U</mi><annotation encoding="application/x-tex">U</annotation></semantics></math>,
a continuous confounder
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>
and a binary outcome
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Y</mi><annotation encoding="application/x-tex">Y</annotation></semantics></math>.
Since
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>U</mi><annotation encoding="application/x-tex">U</annotation></semantics></math>
represents a baseline variable, it does not vary over time. All other
variables, however, were generated at two distinct time points.
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
were generated for time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn><annotation encoding="application/x-tex">0</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>,
while the time-lagged outcome
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Y</mi><annotation encoding="application/x-tex">Y</annotation></semantics></math>
was generated for times
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>2</mn><annotation encoding="application/x-tex">2</annotation></semantics></math>.
For simplicity,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
was affected only by present and past
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>
and not by previous values of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
itself.
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>
on the other hand was caused by previous values of itself and by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>U</mi><annotation encoding="application/x-tex">U</annotation></semantics></math>.
Finally,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Y</mi><annotation encoding="application/x-tex">Y</annotation></semantics></math>
is only caused by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>U</mi><annotation encoding="application/x-tex">U</annotation></semantics></math>,
meaning that neither the treatment nor the confounder have any actual
effect on the outcome. To generate continuous child nodes they relied on
linear regression models. For binary child nodes, logistic regression
models were used. A more detailed description of the data generation
process is given in the original article <span class="citation">(Gruber
et al. 2015)</span>. A <code>DAG</code> object to define this DGP in the
proposed package is given below.</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">dag</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/empty_dag.html">empty_dag</a></span><span class="op">(</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/node.html">node</a></span><span class="op">(</span><span class="st">"U"</span>, type<span class="op">=</span><span class="st">"rbernoulli"</span>, p<span class="op">=</span><span class="fl">0.5</span>, output<span class="op">=</span><span class="st">"numeric"</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/node.html">node</a></span><span class="op">(</span><span class="st">"L0"</span>, type<span class="op">=</span><span class="st">"gaussian"</span>, formula<span class="op">=</span><span class="op">~</span><span class="fl">0.1</span> <span class="op">+</span> <span class="fl">0.6</span><span class="op">*</span><span class="va">U</span>,</span>
<span>       error<span class="op">=</span><span class="fl">1</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/node.html">node</a></span><span class="op">(</span><span class="st">"A0"</span>, type<span class="op">=</span><span class="st">"binomial"</span>, formula<span class="op">=</span><span class="op">~</span><span class="op">-</span><span class="fl">0.4</span> <span class="op">+</span> <span class="fl">0.6</span><span class="op">*</span><span class="va">L0</span>,</span>
<span>       output<span class="op">=</span><span class="st">"numeric"</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/node.html">node</a></span><span class="op">(</span><span class="st">"Y1"</span>, type<span class="op">=</span><span class="st">"binomial"</span>, formula<span class="op">=</span><span class="op">~</span><span class="op">-</span><span class="fl">3.5</span> <span class="op">+</span> <span class="op">-</span><span class="fl">0.9</span><span class="op">*</span><span class="va">U</span>,</span>
<span>       output<span class="op">=</span><span class="st">"numeric"</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/node.html">node</a></span><span class="op">(</span><span class="st">"L1"</span>, type<span class="op">=</span><span class="st">"gaussian"</span>, formula<span class="op">=</span><span class="op">~</span><span class="fl">0.5</span> <span class="op">+</span> <span class="fl">0.02</span><span class="op">*</span><span class="va">L0</span> <span class="op">+</span></span>
<span>        <span class="fl">0.5</span><span class="op">*</span><span class="va">U</span> <span class="op">+</span> <span class="fl">1.5</span><span class="op">*</span><span class="va">A0</span>, error<span class="op">=</span><span class="fl">1</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/node.html">node</a></span><span class="op">(</span><span class="st">"A1"</span>, type<span class="op">=</span><span class="st">"binomial"</span>, formula<span class="op">=</span><span class="op">~</span><span class="op">-</span><span class="fl">0.4</span> <span class="op">+</span> <span class="fl">0.02</span><span class="op">*</span><span class="va">L0</span> <span class="op">+</span></span>
<span>        <span class="fl">0.58</span><span class="op">*</span><span class="va">L1</span>, output<span class="op">=</span><span class="st">"numeric"</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/node.html">node</a></span><span class="op">(</span><span class="st">"Y2"</span>, type<span class="op">=</span><span class="st">"binomial"</span>, formula<span class="op">=</span><span class="op">~</span><span class="op">-</span><span class="fl">2.5</span> <span class="op">+</span> <span class="fl">0.9</span><span class="op">*</span><span class="va">U</span>,</span>
<span>       output<span class="op">=</span><span class="st">"numeric"</span><span class="op">)</span></span></code></pre></div>
<p>Shown graphically, the <code>DAG</code> looks like this:</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">dag</span>, node_size<span class="op">=</span><span class="fl">0.2</span>, node_fill<span class="op">=</span><span class="st">"grey"</span>,</span>
<span>     node_text_fontface<span class="op">=</span><span class="st">"italic"</span>, layout<span class="op">=</span><span class="st">"in_circle"</span><span class="op">)</span></span></code></pre></div>
<p><img src="simDAG_files/figure-html/unnamed-chunk-13-1.png" width="528" style="display: block; margin: auto;"></p>
<p>The structural equations can again be printed using the
<code><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary()</a></code> function:</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">dag</span><span class="op">)</span></span>
<span><span class="co">#&gt; A DAG object using the following structural equations:</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt;  U ~ Bernoulli(0.5)</span></span>
<span><span class="co">#&gt; L0 ~ N(0.1 + 0.6*U, 1)</span></span>
<span><span class="co">#&gt; A0 ~ Bernoulli(logit(-0.4 + 0.6*L0))</span></span>
<span><span class="co">#&gt; Y1 ~ Bernoulli(logit(-3.5 + -0.9*U))</span></span>
<span><span class="co">#&gt; L1 ~ N(0.5 + 0.02*L0 + 0.5*U + 1.5*A0, 1)</span></span>
<span><span class="co">#&gt; A1 ~ Bernoulli(logit(-0.4 + 0.02*L0 + 0.58*L1))</span></span>
<span><span class="co">#&gt; Y2 ~ Bernoulli(logit(-2.5 + 0.9*U))</span></span></code></pre></div>
<p>Finally, we can call the <code><a href="../reference/sim_from_DAG.html">sim_from_dag()</a></code> function on this
<code>DAG</code> to generate some data:</p>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">dat</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/sim_from_DAG.html">sim_from_dag</a></span><span class="op">(</span><span class="va">dag</span>, n_sim<span class="op">=</span><span class="fl">1000</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">dat</span><span class="op">)</span></span>
<span><span class="co">#&gt;        U         L0    A0    Y1         L1    A1    Y2</span></span>
<span><span class="co">#&gt;    &lt;num&gt;      &lt;num&gt; &lt;num&gt; &lt;num&gt;      &lt;num&gt; &lt;num&gt; &lt;num&gt;</span></span>
<span><span class="co">#&gt; 1:     0  1.3086008     0     0 -0.1642422     1     0</span></span>
<span><span class="co">#&gt; 2:     1 -0.4978996     1     0  3.2424318     0     0</span></span>
<span><span class="co">#&gt; 3:     1  0.5125773     1     0  2.4114821     1     0</span></span>
<span><span class="co">#&gt; 4:     1  1.1811591     1     0  3.2285778     0     1</span></span>
<span><span class="co">#&gt; 5:     1  1.3826790     1     0  1.7878382     1     0</span></span>
<span><span class="co">#&gt; 6:     1 -0.3077301     0     0  1.1737307     0     0</span></span></code></pre></div>
<p>Because the variables
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Y</mi><annotation encoding="application/x-tex">Y</annotation></semantics></math>
should be generated at different points in time, we have to include one
node definition per variable per point in time to get an appropriate
<code>DAG</code>. Apart from that the syntax is exactly the same as it
was when generating crossectional data. More points in time could be
added by simply adding more calls to <code><a href="../reference/node.html">node()</a></code> to the
<code>DAG</code> object, using appropriate regression models. The main
advantage of this method is that it allows flexible changes of the DGP
over time. However, the obvious shortcoming is that it does not easily
extend to scenarios with many points in time. Although the authors only
considered three time-varying variables and two distinct points in time
here, the <code>DAG</code> definition is already quite cumbersome. For
every further point in time, three new calls to <code><a href="../reference/node.html">node()</a></code>
would be necessary. If hundreds of points in time should be considered,
using this method is essentially in-feasible. To circumvent these
problems we describe a slightly different way of generating longitudinal
data below.</p>
</div>
<div class="section level2">
<h2 id="simulating-longitudinal-data-with-many-points-in-time">Simulating longitudinal data with many points in time<a class="anchor" aria-label="anchor" href="#simulating-longitudinal-data-with-many-points-in-time"></a>
</h2>
<div class="section level3">
<h3 id="formal-description">Formal description<a class="anchor" aria-label="anchor" href="#formal-description"></a>
</h3>
<p>Instead of defining each node for every point in time separately, it
is often possible to define the structural equations in a generic
time-dependent fashion, so that the same equation can be applied at each
point in time, simplifying the workflow considerably. The result is the
description of a specific stochastic process. For example, consider a
very simple DAG with only one time-dependent node
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Y</mi><annotation encoding="application/x-tex">Y</annotation></semantics></math>
at three points in time,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>∈</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">t \in \{0, 1, 2\}</annotation></semantics></math>:</p>
<p><img src="simDAG_files/figure-html/unnamed-chunk-16-1.png" width="528" style="display: block; margin: auto;"></p>
<p>In this DAG,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Y</mi><mi>t</mi></msub><annotation encoding="application/x-tex">Y_t</annotation></semantics></math>
is only caused by values of itself at
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">t-1</annotation></semantics></math>.
Suppose that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Y</mi><annotation encoding="application/x-tex">Y</annotation></semantics></math>
is a binary event indicator that is zero for everyone at
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">t = 0</annotation></semantics></math>.
At every point in time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Y</mi><annotation encoding="application/x-tex">Y</annotation></semantics></math>
is set to 1 with a probability of 0.01. Once
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Y</mi><annotation encoding="application/x-tex">Y</annotation></semantics></math>
is set to 1, it never changes back to 0. The following structural
equation may be used to describe this DAG:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Y</mi><mi>t</mi></msub><mo>∼</mo><mi>B</mi><mi>e</mi><mi>r</mi><mi>n</mi><mi>o</mi><mi>u</mi><mi>l</mi><mi>l</mi><mi>i</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>P</mi><mi>Y</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mrow><annotation encoding="application/x-tex">
    Y_t \sim Bernoulli(P_Y(t)),
</annotation></semantics></math></p>
<p>where</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>Y</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><mtable><mtr><mtd columnalign="left" style="text-align: left"><mn>0</mn></mtd><mtd columnalign="left" style="text-align: left"><mtext mathvariant="normal">if</mtext><mspace width="1.0em"></mspace><mi>t</mi><mo>=</mo><mn>0</mn></mtd></mtr><mtr><mtd columnalign="left" style="text-align: left"><mn>1</mn></mtd><mtd columnalign="left" style="text-align: left"><mtext mathvariant="normal">if</mtext><mspace width="1.0em"></mspace><msub><mi>Y</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>=</mo><mn>1</mn></mtd></mtr><mtr><mtd columnalign="left" style="text-align: left"><mn>0.01</mn><mo>,</mo></mtd><mtd columnalign="left" style="text-align: left"><mtext mathvariant="normal">otherwise</mtext></mtd></mtr></mtable></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">
    P_Y(t) =
    \begin{cases}
        0 &amp; \text{if} \quad t = 0 \\
        1 &amp; \text{if} \quad Y_{t-1} = 1 \\
        0.01, &amp; \text{otherwise}
    \end{cases}.
</annotation></semantics></math></p>
<p>The number of points in time could be increased by an arbitrary
number and the same structural equation could still be used. Note that
the time points may stand for any period of time, such as minutes, days
or years. This is of course a trivial example, but this approach may
also be used to define very complex DGPs, as illustrated below. For
example, arbitrary dependencies on other variables measured at the same
time or at any earlier time may be used when defining a node. To
generate data from this type of DAG, the same algorithm as described in
the first Section may be used. Since only discrete points in time are
considered, this type of simulation has also been called
<em>discrete-time simulation</em> <span class="citation">(Tang, Leu, and
Abbass 2020)</span> or <em>dynamic microsimulation</em> <span class="citation">(Spooner et al. 2021)</span> in the literature and is
closely related to <em>discrete-event simulation</em> <span class="citation">(Banks et al. 2014)</span>.</p>
</div>
<div class="section level3">
<h3 id="a-simple-example">A simple example<a class="anchor" aria-label="anchor" href="#a-simple-example"></a>
</h3>
<p>To generate data for the simple example considered above in the
proposed package, we first have to define an appropriate
<code>DAG</code> object as before. This can be done using the
<code><a href="../reference/node.html">node_td()</a></code> function with <code>type="time_to_event"</code>
as shown below.</p>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">dag</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/empty_dag.html">empty_dag</a></span><span class="op">(</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/node.html">node_td</a></span><span class="op">(</span><span class="st">"Y"</span>, type<span class="op">=</span><span class="st">"time_to_event"</span>, prob_fun<span class="op">=</span><span class="fl">0.01</span>,</span>
<span>          event_duration<span class="op">=</span><span class="cn">Inf</span><span class="op">)</span></span></code></pre></div>
<p>By default, the value of node defined using
<code>type="time_to_event"</code> is 0 for all individuals at
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">t = 0</annotation></semantics></math>.
The <code>prob_fun</code> argument defines the function that determines
the occurrence probability at each point in time. It is set to 0.01
here, indicating that for all individuals and regardless of the value of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>
the probability of experiencing the event is constant. Usually this
argument will be passed an appropriate function to generate the
occurrence probability for each individual at each point in time
separately, but this is not necessary yet. By setting the
<code>event_duration</code> argument to <code>Inf</code>, we are
indicating that the all events have an infinite duration, making the
first event the final event for each person. In contrast to before, the
<code><a href="../reference/sim_discrete_time.html">sim_discrete_time()</a></code> function now has to be used to generate
data from this <code>DAG</code> object, because it contains a
time-varying node:</p>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">sim</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/sim_discrete_time.html">sim_discrete_time</a></span><span class="op">(</span><span class="va">dag</span>, n_sim<span class="op">=</span><span class="fl">1000</span>, max_t<span class="op">=</span><span class="fl">80</span><span class="op">)</span></span></code></pre></div>
<p>The <code>max_t</code> argument specifies how many points in time
should be simulated. Instead of just three points in time we consider 80
here. Contrary to the <code><a href="../reference/sim_from_DAG.html">sim_from_dag()</a></code> function, the
<code><a href="../reference/sim_discrete_time.html">sim_discrete_time()</a></code> function does not return a single
<code>data.table</code>. Instead it returns a <code>simDT</code> object,
which usually has to be processed further using the
<code><a href="../reference/sim2data.html">sim2data()</a></code> function to be useful. In this case, however, it
is enough to simply extract the last state of the simulation to get all
the information we need. This last simulation state is stored in the
<code>$data</code> parameter of the <code>simDT</code> object:</p>
<div class="sourceCode" id="cb16"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">sim</span><span class="op">$</span><span class="va">data</span><span class="op">)</span></span>
<span><span class="co">#&gt;      .id Y_event Y_time</span></span>
<span><span class="co">#&gt;    &lt;int&gt;  &lt;lgcl&gt;  &lt;int&gt;</span></span>
<span><span class="co">#&gt; 1:     1   FALSE     NA</span></span>
<span><span class="co">#&gt; 2:     2    TRUE     56</span></span>
<span><span class="co">#&gt; 3:     3    TRUE      8</span></span>
<span><span class="co">#&gt; 4:     4    TRUE     26</span></span>
<span><span class="co">#&gt; 5:     5   FALSE     NA</span></span>
<span><span class="co">#&gt; 6:     6    TRUE     58</span></span></code></pre></div>
<p>As specified, the simulation contains only the variable
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Y</mi><annotation encoding="application/x-tex">Y</annotation></semantics></math>,
split into two columns. The first is called <code>Y_event</code> and is
a binary indicator of whether the individual is currently experiencing
an event. The second column called <code>Y_time</code> shows the time at
which that event happened, or is set to <code>NA</code> if there is no
event currently happening. Since every event is final, this is all
information that was generated here. Individuals with a value of
<code>NA</code> in <code>Y_time</code> can be considered right-censored
at
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mn>80</mn></mrow><annotation encoding="application/x-tex">t = 80</annotation></semantics></math>.
In this trivial example, it would be a lot easier to generate equivalent
data by sampling from an appropriate parametric distributions. The
following Section will illustrate the benefits of the approach using a
more involved example.</p>
</div>
<div class="section level3">
<h3 id="simulating-adverse-events-after-covid-19-vaccination">Simulating adverse events after Covid-19 vaccination<a class="anchor" aria-label="anchor" href="#simulating-adverse-events-after-covid-19-vaccination"></a>
</h3>
<p>Suppose that we want to generate data for the Covid-19 pandemic,
containing individual level information about Covid-19 vaccinations
denoted by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
and the development of an acute myocarditis denoted by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Y</mi><annotation encoding="application/x-tex">Y</annotation></semantics></math>.
Different individuals get vaccinated at different times, possible
multiple times. Additionally, they might experience zero or multiple
cases of myocarditis, also at different times. Both variables are
therefore time-dependent binary variables, which are related to one
another. If the target of interest is to estimate the effect of the
vaccination on the time until the occurrence of a myocarditis, the
vaccination may be considered a time-dependent variable and the
myocarditis as a non-terminal, possibly recurrent, time-to-event
outcome. This setup was of interest to <span class="citation">Denz et
al. (2025)</span>, who performed a Monte-Carlo simulation study to
investigate the impact of linkage errors when estimating vaccine-safety
from observational data. Below we will illustrate a simplified version
of the DGP used therein.</p>
<p>For simplicity, we will make multiple simplifying assumptions that
were not made in the original simulation study. First, we assume that
the probability of being vaccinated and the base probability of
developing a myocarditis are constant over time and equal for all
individuals. The only risk factor for developing a myocarditis in this
example is the Covid-19 vaccination itself. More precisely, the
structural equation for the myocarditis node at
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>
is given by:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Y</mi><mi>t</mi></msub><mo>∼</mo><mi>B</mi><mi>e</mi><mi>r</mi><mi>n</mi><mi>o</mi><mi>u</mi><mi>l</mi><mi>l</mi><mi>i</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>P</mi><mi>Y</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mrow><annotation encoding="application/x-tex">
    Y_t \sim Bernoulli(P_{Y}(t)),
</annotation></semantics></math></p>
<p>with:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>Y</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><mtable><mtr><mtd columnalign="left" style="text-align: left"><msub><mi>P</mi><mrow><mi>Y</mi><mn>0</mn></mrow></msub><mo>⋅</mo><mi>R</mi><msub><mi>R</mi><mi>A</mi></msub><mo>,</mo></mtd><mtd columnalign="left" style="text-align: left"><mrow><mtext mathvariant="normal">if </mtext><mspace width="0.333em"></mspace></mrow><mi>t</mi><mo>∈</mo><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>T</mi><mi>A</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><msub><mi>T</mi><mi>A</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msub><mi>d</mi><mrow><mi>r</mi><mi>i</mi><mi>s</mi><mi>k</mi></mrow></msub><mo stretchy="true" form="postfix">]</mo></mrow></mtd></mtr><mtr><mtd columnalign="left" style="text-align: left"><msub><mi>P</mi><mrow><mi>Y</mi><mn>0</mn></mrow></msub><mo>,</mo></mtd><mtd columnalign="left" style="text-align: left"><mtext mathvariant="normal">otherwise</mtext></mtd></mtr></mtable></mrow><mo>,</mo></mrow><annotation encoding="application/x-tex">
    P_{Y}(t) =
    \begin{cases}
        P_{Y0} \cdot RR_{A}, &amp; \text{if } t \in  \left[T_{A}(t), T_{A}(t) + d_{risk}\right] \\
        P_{Y0}, &amp; \text{otherwise}
    \end{cases},
</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>P</mi><mrow><mi>Y</mi><mn>0</mn></mrow></msub><annotation encoding="application/x-tex">P_{Y0}</annotation></semantics></math>
denotes the base probability of developing a myocarditis,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>A</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">T_{A}(t)</annotation></semantics></math>
denotes the time of the last performed vaccination and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>d</mi><mrow><mi>r</mi><mi>i</mi><mi>s</mi><mi>k</mi></mrow></msub><annotation encoding="application/x-tex">d_{risk}</annotation></semantics></math>
defines the duration after the vaccination in which the risk of
developing a myocarditis is elevated by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><msub><mi>R</mi><mi>A</mi></msub></mrow><annotation encoding="application/x-tex">RR_{A}</annotation></semantics></math>.
In this particular case, each
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>
will represent a single day. Similarly, the vaccination node can be
described formally as:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mi>t</mi></msub><mo>∼</mo><mi>B</mi><mi>e</mi><mi>r</mi><mi>n</mi><mi>o</mi><mi>u</mi><mi>l</mi><mi>l</mi><mi>i</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>P</mi><mi>A</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mrow><annotation encoding="application/x-tex">
    A_t \sim Bernoulli(P_{A}(t)),
</annotation></semantics></math></p>
<p>with:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>A</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><mtable><mtr><mtd columnalign="left" style="text-align: left"><mn>1</mn><mo>,</mo></mtd><mtd columnalign="left" style="text-align: left"><mrow><mtext mathvariant="normal">if </mtext><mspace width="0.333em"></mspace></mrow><mi>t</mi><mo>∈</mo><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>T</mi><mi>A</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><msub><mi>T</mi><mi>A</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mn>20</mn><mo stretchy="true" form="postfix">]</mo></mrow></mtd></mtr><mtr><mtd columnalign="left" style="text-align: left"><mn>0</mn><mo>,</mo></mtd><mtd columnalign="left" style="text-align: left"><mrow><mtext mathvariant="normal">if </mtext><mspace width="0.333em"></mspace></mrow><mi>t</mi><mo>∈</mo><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>T</mi><mi>A</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mn>21</mn><mo>,</mo><msub><mi>T</mi><mi>A</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mn>150</mn><mo stretchy="true" form="postfix">]</mo></mrow></mtd></mtr><mtr><mtd columnalign="left" style="text-align: left"><msub><mi>P</mi><mrow><mi>A</mi><mn>0</mn></mrow></msub><mo>,</mo></mtd><mtd columnalign="left" style="text-align: left"><mtext mathvariant="normal">otherwise</mtext></mtd></mtr></mtable></mrow><mo>,</mo></mrow><annotation encoding="application/x-tex">
    P_{A}(t) =
    \begin{cases}
        1, &amp; \text{if } t \in  \left[T_{A}(t), T_A(t) + 20 \right] \\
        0, &amp; \text{if } t \in  \left[T_{A}(t) + 21, T_A(t) + 150\right] \\
        P_{A0}, &amp; \text{otherwise}
    \end{cases},
</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>P</mi><mrow><mi>A</mi><mn>0</mn></mrow></msub><annotation encoding="application/x-tex">P_{A0}</annotation></semantics></math>
denotes the base probability of getting vaccinated. The Figure below
illustrates the result of applying these structural equations to a
fictional person who gets vaccinated at
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">t = 100</annotation></semantics></math>.</p>
<div class="figure" style="text-align: center">
<img src="images_v_joss/example_probs.png" alt="A simple graph showing $P_A(t)$ and $P_Y(t)$ for a fictional individual who got vaccinated once at $t = 100$, with $P_{A0} = 0.01$, $P_{Y0} = 0.005$, $d_{risk} = 20$ and $RR_A = 3.24$." width="600"><p class="caption">
A simple graph showing
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>A</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">P_A(t)</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>Y</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">P_Y(t)</annotation></semantics></math>
for a fictional individual who got vaccinated once at
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">t = 100</annotation></semantics></math>,
with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mrow><mi>A</mi><mn>0</mn></mrow></msub><mo>=</mo><mn>0.01</mn></mrow><annotation encoding="application/x-tex">P_{A0} = 0.01</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mrow><mi>Y</mi><mn>0</mn></mrow></msub><mo>=</mo><mn>0.005</mn></mrow><annotation encoding="application/x-tex">P_{Y0} = 0.005</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mrow><mi>r</mi><mi>i</mi><mi>s</mi><mi>k</mi></mrow></msub><mo>=</mo><mn>20</mn></mrow><annotation encoding="application/x-tex">d_{risk} = 20</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><msub><mi>R</mi><mi>A</mi></msub><mo>=</mo><mn>3.24</mn></mrow><annotation encoding="application/x-tex">RR_A = 3.24</annotation></semantics></math>.
</p>
</div>
<p>The following code may be used to define this DGP:</p>
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">prob_myoc</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">data</span>, <span class="va">P_0</span>, <span class="va">RR_A</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rdatatable.gitlab.io/data.table/reference/fifelse.html" class="external-link">fifelse</a></span><span class="op">(</span><span class="va">data</span><span class="op">$</span><span class="va">A_event</span>, <span class="va">P_0</span><span class="op">*</span><span class="va">RR_A</span>, <span class="va">P_0</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="va">dag</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/empty_dag.html">empty_dag</a></span><span class="op">(</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/node.html">node_td</a></span><span class="op">(</span><span class="st">"A"</span>, type<span class="op">=</span><span class="st">"time_to_event"</span>, prob_fun<span class="op">=</span><span class="fl">0.01</span>,</span>
<span>          event_duration<span class="op">=</span><span class="fl">20</span>, immunity_duration<span class="op">=</span><span class="fl">150</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/node.html">node_td</a></span><span class="op">(</span><span class="st">"Y"</span>, type<span class="op">=</span><span class="st">"time_to_event"</span>, prob_fun<span class="op">=</span><span class="va">prob_myoc</span>,</span>
<span>          parents<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"A_event"</span><span class="op">)</span>, P_0<span class="op">=</span><span class="fl">0.005</span>, RR_A<span class="op">=</span><span class="fl">3.24</span><span class="op">)</span></span></code></pre></div>
<p>First, we define a function that calculates
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>Y</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">P_Y(t)</annotation></semantics></math>
at each simulated day for all individuals, called
<code>prob_myoc()</code>. This function simply checks whether the binary
event indicator of the vaccination event, <code>"A_event"</code>, is
currently <code>TRUE</code> and multiplies the baseline probability of
developing a myocarditis
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>P</mi><mrow><mi>Y</mi><mn>0</mn></mrow></msub><annotation encoding="application/x-tex">P_{Y0}</annotation></semantics></math>
with the relative risk if this is the case. Otherwise it just returns
the baseline probability directly. This function is then passed directly
to the <code>prob_fun</code> argument in the <code><a href="../reference/node.html">node_td()</a></code> call
when defining the myocarditis node. For this to be a sensible strategy,
we need to ensure that <code>"A_event"</code> is only <code>TRUE</code>
when a person is currently at elevated risk for a myocarditis, as
defined in the earlier Equation. In other words, <code>"A_event"</code>
should not actually be an indicator of whether someone just received a
vaccination, but an indicator of whether the person is currently in the
risk period of 20 days following the vaccination. We can achieve this by
setting the <code>event_duration</code> parameter in the node definition
of the vaccination node to 20, meaning that the vaccination node will
equal 1 for 20 days after a vaccination was performed. This argument is
a direct feature of the <code><a href="../reference/node_time_to_event.html">node_time_to_event()</a></code> function,
which is called internally whenever <code>type="time_to_event"</code> is
used in a time-dependent node.</p>
<p>The base probability for the vaccination and for the myocarditis
events are set to the arbitrary values of 0.01 and 0.005 respectively.
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><msub><mi>R</mi><mi>A</mi></msub></mrow><annotation encoding="application/x-tex">RR_{A}</annotation></semantics></math>
is set to 3.24, which is the value used in the actual simulation study
by <span class="citation">Denz et al. (2025)</span>. The
<code>immunity_duration</code> parameter used for the vaccination node
additionally specifies that a person will not receive another
vaccination in the first 150 days after a vaccination was performed.
More specifically, these settings ensure that <code>"A_event"</code> is
set to <code>FALSE</code> for 130 days after the
<code>event_duration</code> of 20 days is over. This is another feature
of <code>"time_to_event"</code> nodes. To run the simulation for two
simulated years, the following code may be used:</p>
<div class="sourceCode" id="cb18"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">sim</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/sim_discrete_time.html">sim_discrete_time</a></span><span class="op">(</span><span class="va">dag</span>, n_sim<span class="op">=</span><span class="fl">10000</span>, max_t<span class="op">=</span><span class="fl">365</span><span class="op">*</span><span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<p>Since both of the included variables change over time and may have
multiple events, it is not appropriate to just look at the last state of
the simulation in this case. Instead we will have to use the
<code><a href="../reference/sim2data.html">sim2data()</a></code> function to obtain a useful dataset. The
following code may be used to get a dataset in the <em>start-stop</em>
format:</p>
<div class="sourceCode" id="cb19"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">dat</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/sim2data.html">sim2data</a></span><span class="op">(</span><span class="va">sim</span>, to<span class="op">=</span><span class="st">"start_stop"</span>, target_event<span class="op">=</span><span class="st">"Y"</span>,</span>
<span>                keep_only_first<span class="op">=</span><span class="cn">TRUE</span>, overlap<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">dat</span><span class="op">)</span></span>
<span><span class="co">#&gt;      .id start  stop      A      Y</span></span>
<span><span class="co">#&gt;    &lt;int&gt; &lt;int&gt; &lt;num&gt; &lt;lgcl&gt; &lt;lgcl&gt;</span></span>
<span><span class="co">#&gt; 1:     1     1    57  FALSE   TRUE</span></span>
<span><span class="co">#&gt; 2:     2     1    21  FALSE  FALSE</span></span>
<span><span class="co">#&gt; 3:     2    21    38   TRUE   TRUE</span></span>
<span><span class="co">#&gt; 4:     3     1    50  FALSE  FALSE</span></span>
<span><span class="co">#&gt; 5:     3    50    70   TRUE  FALSE</span></span>
<span><span class="co">#&gt; 6:     3    70   272  FALSE  FALSE</span></span></code></pre></div>
<p>In this format, there are multiple rows per person, corresponding to
periods of time in which all variables stayed the same. These intervals
are defined by the <code>start</code> column (time at which the period
starts) and <code>stop</code> columns (time at which the period ends).
The <code>overlap</code> argument specifies whether these intervals
should be overlapping or not. By setting <code>target_event="Y"</code>,
the function treats the <code>Y</code> node as the outcome instead of as
another time-dependent covariate. The resulting data is in exactly the
format needed to fit standard time-to-event models, such as a Cox model
with time-varying covariates <span class="citation">(Z. Zhang et al.
2018)</span>. Using the <code>survival</code> package <span class="citation">(Therneau 2024)</span>, we can do this using the
following code:</p>
<div class="sourceCode" id="cb20"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="st"><a href="https://github.com/therneau/survival" class="external-link">"survival"</a></span><span class="op">)</span></span>
<span><span class="va">mod</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/survival/man/coxph.html" class="external-link">coxph</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/pkg/survival/man/Surv.html" class="external-link">Surv</a></span><span class="op">(</span><span class="va">start</span>, <span class="va">stop</span>, <span class="va">Y</span><span class="op">)</span> <span class="op">~</span> <span class="va">A</span>, data<span class="op">=</span><span class="va">dat</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">mod</span><span class="op">)</span></span>
<span><span class="co">#&gt; Call:</span></span>
<span><span class="co">#&gt; coxph(formula = Surv(start, stop, Y) ~ A, data = dat)</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt;   n= 25020, number of events= 9871 </span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt;          coef exp(coef) se(coef)     z Pr(&gt;|z|)    </span></span>
<span><span class="co">#&gt; ATRUE 1.15906   3.18693  0.02377 48.76   &lt;2e-16 ***</span></span>
<span><span class="co">#&gt; ---</span></span>
<span><span class="co">#&gt; Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt;       exp(coef) exp(-coef) lower .95 upper .95</span></span>
<span><span class="co">#&gt; ATRUE     3.187     0.3138     3.042     3.339</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Concordance= 0.58  (se = 0.002 )</span></span>
<span><span class="co">#&gt; Likelihood ratio test= 1928  on 1 df,   p=&lt;2e-16</span></span>
<span><span class="co">#&gt; Wald test            = 2378  on 1 df,   p=&lt;2e-16</span></span>
<span><span class="co">#&gt; Score (logrank) test = 2648  on 1 df,   p=&lt;2e-16</span></span></code></pre></div>
<p>Because the DGP fulfills all assumptions of the Cox model and the
sample size is very large, the resulting hazard ratio is close to the
relative risk of 3.24 that were specified in the <code>DAG</code>
object. Other types of models, such as discrete-time survival models,
may require different data formats <span class="citation">(Tutz and
Schmid 2016)</span>. Because of this, the <code><a href="../reference/sim2data.html">sim2data()</a></code>
function also supports the transformation into <em>long-</em> and
<em>wide-</em> format data.</p>
<p>Above we assumed that the presence of a myocarditis event has no
effect on whether a person gets vaccinated or not. In reality, it is
unlikely that a person who is currently experiencing a myocarditis would
get a Covid-19 vaccine. We can include this into the DGP by modifying
the <code>prob_fun</code> argument when defining the vaccination node as
shown below:</p>
<div class="sourceCode" id="cb21"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">prob_vacc</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">data</span>, <span class="va">P_0</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rdatatable.gitlab.io/data.table/reference/fifelse.html" class="external-link">fifelse</a></span><span class="op">(</span><span class="va">data</span><span class="op">$</span><span class="va">Y_event</span>, <span class="fl">0</span>, <span class="va">P_0</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="va">dag</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/empty_dag.html">empty_dag</a></span><span class="op">(</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/node.html">node_td</a></span><span class="op">(</span><span class="st">"A"</span>, type<span class="op">=</span><span class="st">"time_to_event"</span>, prob_fun<span class="op">=</span><span class="va">prob_vacc</span>,</span>
<span>          event_duration<span class="op">=</span><span class="fl">20</span>, immunity_duration<span class="op">=</span><span class="fl">150</span>, P_0<span class="op">=</span><span class="fl">0.01</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/node.html">node_td</a></span><span class="op">(</span><span class="st">"Y"</span>, type<span class="op">=</span><span class="st">"time_to_event"</span>, prob_fun<span class="op">=</span><span class="va">prob_myoc</span>,</span>
<span>          parents<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"A_event"</span><span class="op">)</span>, P_0<span class="op">=</span><span class="fl">0.005</span>, RR_A<span class="op">=</span><span class="fl">3.24</span>,</span>
<span>          event_duration<span class="op">=</span><span class="fl">80</span><span class="op">)</span></span></code></pre></div>
<p>In this extension, the probability of getting vaccinated is set to 0
whenever the respective person is currently experiencing a myocarditis
event. By additionally setting the <code>event_duration</code> parameter
of the myocarditis node to the arbitrary value of 80, we are defining
that in the 80 days after experiencing the event there will be no
vaccination for that person. Data could be generated and transformed
using the same code as before.</p>
</div>
<div class="section level3">
<h3 id="additionally-supported-features">Additionally supported features<a class="anchor" aria-label="anchor" href="#additionally-supported-features"></a>
</h3>
<p>The example shown above illustrates only a small fraction of the
possible features that could be included into the DGP using the
discrete-time simulation algorithm implemented in the proposed package.
Below we name more features that could theoretically be added to the
DGP. Examples for how to actually implement these extensions are given
in the appendix.</p>
<ul>
<li><p><strong>Time-Dependent Probabilities and Effects</strong>: In the
example above both the base probabilities and the relative risks were
always set to a constant, regardless of the simulation time. This may
also be changed by re-defining the <code>prob_fun</code> argument to
have a named argument called <code>sim_time</code>. Internally, the
current time of the simulation will then be passed directly to the
<code>prob_fun</code>, allowing users to define any
time-dependencies.</p></li>
<li><p><strong>Non-Linear Effects</strong>: Above, we only considered
the simple scenario in which the probability of an event after the
occurrence of another event follows a simple step function, e.g., it is
set to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>P</mi><mn>0</mn></msub><annotation encoding="application/x-tex">P_0</annotation></semantics></math>
in general and increased by a fixed factor in a fixed duration after an
event. This may also be changed by using more complex definitions of
<code>prob_fun</code> that are not based only on the <code>_event</code>
column of the exposure, but directly on the time of occurrence.</p></li>
<li><p><strong>Adding more Binary Time-Dependent Variables</strong>:
Only two time-dependent variables were considered in the example. It is
of course possible to add as many further variables as desired by the
user by simply adding more appropriate <code><a href="../reference/node.html">node_td()</a></code> calls to
the <code>DAG</code> object. Both the <code><a href="../reference/sim_discrete_time.html">sim_discrete_time()</a></code>
function and the <code><a href="../reference/sim2data.html">sim2data()</a></code> function will still work
exactly as described earlier.</p></li>
<li><p><strong>Adding Baseline Covariates</strong>: It is of course also
possible to define a <code>DAG</code> that contains both
time-independent and time-dependent variables at the same time. This can
be achieved by adding nodes with the <code><a href="../reference/node.html">node()</a></code> and
<code><a href="../reference/node.html">node_td()</a></code> function. Data for the time-independent variables
will then be generated first (at
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">t = 0</annotation></semantics></math>)
and the time-dependent simulation will be performed as before, albeit
possibly dependent on the time-independent variables.</p></li>
<li><p><strong>Adding Categorical Time-Dependent Variables</strong>:
Sometimes it may not be appropriate to describe a time-varying variable
using only two classes. For theses cases, the proposed package also
includes the <code>"competing_events"</code> node type, which is very
similar to the <code>"time_to_event"</code> node type. The only
difference is that instead of Bernoulli trials multinomial trials are
performed at each point in time for all individuals, allowing the
generation of mutually exclusive events.</p></li>
<li><p><strong>Adding Arbitrarily Distributed Time-Dependent
Variables</strong>: As in the <code><a href="../reference/sim_from_DAG.html">sim_from_dag()</a></code> function, any
kind of function may be used as a <code>type</code> for time-dependent
variables. By appropriately defining those, it is possible to generate
count and continuous time-varying variables as well.</p></li>
<li><p><strong>Adding Ordered Events</strong>: Some events should only
be possible once something else has already happened. For example, a
person usually cannot receive a PhD before graduating high school. This
type of data may also be generated, again by appropriately specifying
the required probability functions.</p></li>
</ul>
<p>All of the mentioned and shown features may of course be used in
arbitrary combinations. Additionally, the list above is not meant to be
exhaustive. It is merely supposed to highlight how versatile the
implemented approach is.</p>
</div>
<div class="section level3">
<h3 id="computational-considerations">Computational considerations<a class="anchor" aria-label="anchor" href="#computational-considerations"></a>
</h3>
<p>Although the discrete-time simulation procedure described above is
incredibly flexible, it is also very computationally expensive
theoretically. For example, when using nodes of type
<code>"time_to_event"</code>. as shown above, the program has to
re-calculate the event probabilities at each point in time, for every
individual and for every node. Increasing either the number of nodes,
the number of time points or the number of considered individuals
therefore non-linearly increases the number of required computations.
This fact, together with the lack of available appropriate software
packages, is probably the main reason this type of simulation strategy
is rarely used in Monte-Carlo simulation studies. Since Monte-Carlo
studies often require thousands of replications with hundreds of
different scenarios, even a runtime of a few seconds to generate a
dataset may be too long to keep the simulation computationally
feasible.</p>
<p>The presented implementation was therefore designed explicitly to be
as fast as possible. To ensure that it can be run on multiple processing
cores in parallel, it is additionally designed to use as little random
access memory (RAM) as possible. As all other code in this package, it
exclusively uses the <code>data.table</code> package <span class="citation">(Barrett et al. 2024)</span> to perform most required
computations. The <code>data.table</code> package is arguably the best
choice for doing data wrangling in the <code>R</code> ecosystem in terms
of computational efficiency and has similar performance as corresponding
software libraries in <code>R</code> and <code>Julia</code> <span class="citation">(Chiou, Xu, and Huang 2023)</span>. The proposed
package additionally relies on a few tricks to keep the amount of memory
used small. For example, when using nodes of type
<code>"time_to_event"</code>, by default not every state of the
simulation is saved. Only the times at which an event occurred are
recorded. This information is then efficiently pieced together in the
<code><a href="../reference/sim2data.html">sim2data()</a></code> function when creating the actual dataset.</p>
<p>Although none of these code optimizations can entirely overcome the
inherent computational complexity of the approach, they do ensure that
the usage of this method is feasible to generate reasonably large data
with many points in time on a regular office computer. For example,
generating a dataset with 1000 individuals and 730 distinct points in
time from the first <code>DAG</code>, shown in the Section containing
the Covid example, takes only 1.11 seconds on average on the authors
personal computer, using a single processing core (Intel(R) Core(TM)
i7-9700 CPU @ 3.00GHz, 32GB RAM). It is, however, also important to note
that the runtime highly depends on how efficient the functions supplied
to the <code>prob_fun</code> arguments are written as well.</p>
<p>Below we give some additional limited code to illustrate the
increased runtime of the <code><a href="../reference/sim_discrete_time.html">sim_discrete_time()</a></code> function with
increasing <code>n_sim</code> and increasing <code>max_t</code> values.
As an example, we use the first DGP shown in the Section on the Covid
example to generate some data for multiple different values of each
argument. We include calls to the <code><a href="../reference/sim2data.html">sim2data()</a></code> function in
the runtime calculations, because calling this function is necessary to
obtain usable data and as such should be considered part of the DGP. The
runtime is calculated using the <code>microbenchmark</code> package
<span class="citation">(Mersmann 2023)</span>.</p>
<div class="sourceCode" id="cb22"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># NOTE: This part of the code is not run here, because it would take too long</span></span>
<span><span class="co"># on CRAN and would introduce another dependency on the "microbenchmark"</span></span>
<span><span class="co"># package. Results may also vary depending on the hardware this is run on.</span></span>
<span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/joshuaulrich/microbenchmark/" class="external-link">microbenchmark</a></span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">1234</span><span class="op">)</span></span>
<span></span>
<span><span class="va">prob_myoc</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">data</span>, <span class="va">P_0</span>, <span class="va">RR_A</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rdatatable.gitlab.io/data.table/reference/fifelse.html" class="external-link">fifelse</a></span><span class="op">(</span><span class="va">data</span><span class="op">$</span><span class="va">A_event</span>, <span class="va">P_0</span><span class="op">*</span><span class="va">RR_A</span>, <span class="va">P_0</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="va">run_example</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">n</span>, <span class="va">max_t</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">dag</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/empty_dag.html">empty_dag</a></span><span class="op">(</span><span class="op">)</span> <span class="op">+</span></span>
<span>    <span class="fu"><a href="../reference/node.html">node_td</a></span><span class="op">(</span><span class="st">"A"</span>, type<span class="op">=</span><span class="st">"time_to_event"</span>, prob_fun<span class="op">=</span><span class="fl">0.01</span>,</span>
<span>            event_duration<span class="op">=</span><span class="fl">20</span>, immunity_duration<span class="op">=</span><span class="fl">150</span><span class="op">)</span> <span class="op">+</span></span>
<span>    <span class="fu"><a href="../reference/node.html">node_td</a></span><span class="op">(</span><span class="st">"Y"</span>, type<span class="op">=</span><span class="st">"time_to_event"</span>, prob_fun<span class="op">=</span><span class="va">prob_myoc</span>,</span>
<span>            parents<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"A_event"</span><span class="op">)</span>, P_0<span class="op">=</span><span class="fl">0.005</span>, RR_A<span class="op">=</span><span class="fl">3.24</span><span class="op">)</span></span>
<span></span>
<span>  <span class="va">sim</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/sim_discrete_time.html">sim_discrete_time</a></span><span class="op">(</span><span class="va">dag</span>, n_sim<span class="op">=</span><span class="va">n</span>, max_t<span class="op">=</span><span class="va">max_t</span><span class="op">)</span></span>
<span></span>
<span>  <span class="va">dat</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/sim2data.html">sim2data</a></span><span class="op">(</span><span class="va">sim</span>, to<span class="op">=</span><span class="st">"start_stop"</span>, target_event<span class="op">=</span><span class="st">"Y"</span>,</span>
<span>                  keep_only_first<span class="op">=</span><span class="cn">TRUE</span>, overlap<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="va">n</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">10</span>, <span class="fl">100</span>, <span class="fl">1000</span>, <span class="fl">10000</span>, <span class="fl">100000</span><span class="op">)</span></span>
<span><span class="va">max_t</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">10</span>, <span class="fl">100</span>, <span class="fl">1000</span>, <span class="fl">10000</span><span class="op">)</span></span>
<span></span>
<span><span class="va">params</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>max_t<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="va">max_t</span>, each<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">n</span><span class="op">)</span><span class="op">)</span>,</span>
<span>                     n<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="va">n</span><span class="op">)</span>, time<span class="op">=</span><span class="cn">NA</span><span class="op">)</span></span>
<span></span>
<span><span class="kw">for</span> <span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq_len</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">params</span><span class="op">)</span><span class="op">)</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">n_i</span> <span class="op">&lt;-</span> <span class="va">params</span><span class="op">$</span><span class="va">n</span><span class="op">[</span><span class="va">i</span><span class="op">]</span></span>
<span>  <span class="va">max_t_i</span> <span class="op">&lt;-</span> <span class="va">params</span><span class="op">$</span><span class="va">max_t</span><span class="op">[</span><span class="va">i</span><span class="op">]</span></span>
<span></span>
<span>  <span class="va">bench</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/microbenchmark/man/microbenchmark.html" class="external-link">microbenchmark</a></span><span class="op">(</span><span class="fu">run_example</span><span class="op">(</span>n<span class="op">=</span><span class="va">n_i</span>, max_t<span class="op">=</span><span class="va">max_t_i</span><span class="op">)</span>,</span>
<span>                          times<span class="op">=</span><span class="fl">1</span><span class="op">)</span></span>
<span>  <span class="va">params</span><span class="op">$</span><span class="va">time</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/mean.html" class="external-link">mean</a></span><span class="op">(</span><span class="va">bench</span><span class="op">$</span><span class="va">time</span> <span class="op">/</span> <span class="fl">1000000000</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="va">params</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/with.html" class="external-link">within</a></span><span class="op">(</span><span class="va">params</span>, <span class="op">{</span></span>
<span>  <span class="va">max_t</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/factor.html" class="external-link">factor</a></span><span class="op">(</span><span class="va">max_t</span><span class="op">)</span>;</span>
<span><span class="op">}</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/ggplot.html" class="external-link">ggplot</a></span><span class="op">(</span><span class="va">params</span>, <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/aes.html" class="external-link">aes</a></span><span class="op">(</span>x<span class="op">=</span><span class="va">n</span>, y<span class="op">=</span><span class="va">time</span>, color<span class="op">=</span><span class="va">max_t</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/geom_point.html" class="external-link">geom_point</a></span><span class="op">(</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/geom_path.html" class="external-link">geom_line</a></span><span class="op">(</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/ggtheme.html" class="external-link">theme_bw</a></span><span class="op">(</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/labs.html" class="external-link">labs</a></span><span class="op">(</span>x<span class="op">=</span><span class="st">"n_sim"</span>, y<span class="op">=</span><span class="st">"Runtime in Seconds"</span>, color<span class="op">=</span><span class="st">"max_t"</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/scale_continuous.html" class="external-link">scale_x_continuous</a></span><span class="op">(</span>labels<span class="op">=</span><span class="fu">scales</span><span class="fu">::</span><span class="fu"><a href="https://scales.r-lib.org/reference/label_number.html" class="external-link">label_comma</a></span><span class="op">(</span><span class="op">)</span>,</span>
<span>                     transform<span class="op">=</span><span class="st">"log10"</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/scale_continuous.html" class="external-link">scale_y_log10</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<p><img src="images_v_joss/runtime.png" width="600" style="display: block; margin: auto;"></p>
<p>The runtime increases more sharply with higher values of
<code>max_t</code> than it does with higher values of
<code>n_sim</code>, because each additional considered point in time
internally translates to one more iteration in an <code>R</code>
<code>for</code> loop, while each additional considered individual
translates to one more row in the generated data, which is processed
using optimized <code>data.table</code> code directly.</p>
</div>
</div>
<div class="section level2">
<h2 id="discussion">Discussion<a class="anchor" aria-label="anchor" href="#discussion"></a>
</h2>
<p>In this article we presented the <code>simDAG</code> <code>R</code>
package and illustrated how it can be used to generate various forms of
artificial data that may be required for Monte-Carlo simulation studies.
In particular, we showed how the package may be used to generate
crossectional and longitudinal data with multiple variables of different
data types, non-linear effects and arbitrary causal dependencies. We
showed how similar the syntax is for very different kinds of DGP and how
closely the required code resembles the actual underlying structural
equations when using built-in node types. Because the package is based
on defining a DAG to describe the DGP, it lends itself particularly well
to simulation studies dealing with causal inference, but it is by no
means limited to applications in this field, as shown in the second to
last Section of the article.</p>
<p>In addition to the main data generation functions, the package also
includes multiple functions to facilitate the accurate description of
the underlying DGP. Such descriptions are of great importance to
facilitate both understanding and reproducibility of simulation studies,
as emphasized in the literature <span class="citation">(Morris, White,
and Crowther 2019; Cheng et al. 2016)</span>. Among these are the
<code><a href="../reference/plot.DAG.html">plot.DAG()</a></code> function, that was used throughout the article
to graphically display the defined <code>DAG</code> objects. While this
function is useful on its own, some users may prefer to use one of the
many other options to display DAGs in <code>R</code> <span class="citation">(Pitts and Fowler 2024)</span>. To make this easier for
users the package also contains the <code><a href="../reference/dag2matrix.html">dag2matrix()</a></code> function,
which returns the underlying adjacency matrix of a <code>DAG</code>
object and the <code><a href="../reference/as.igraph.DAG.html">as.igraph.DAG()</a></code> function for direct
integration with the <code>igraph</code> <code>R</code> package <span class="citation">(Csárdi et al. 2024)</span>. Additionally, the
<code>summary.DAG()</code> method may be used to directly print the used
structural equations, as shown throughout the article.</p>
<p>The most distinguishing feature of the package is its capability of
carrying out discrete-time simulations to generate longitudinal data
with hundreds of points in time in a suitable amount of time. While
other packages, such as the <code>simcausal</code> package <span class="citation">(Sofrygin, van der Laan, and Neugebauer 2017)</span>
offer similar features to generate crossectional data, its’
implementation for generation of longitudinal data is very different
from the proposed package. In <code>simcausal</code> a new node is
defined for each point in time internally. Although the user has direct
access to each of these nodes (and therefore to each value at any point
in time), the provided formula interface does not naturally support the
definition of nodes with events that occur at some point in time and
last for a certain amount of time. This can be done with little effort
in the <code>simDAG</code> package using the provided
<code>"time_to_event"</code> node type.</p>
<p>This type of node can then be used to specify outcomes or to specify
binary time-varying covariates, as illustrated in the main text where we
used two such nodes to describe both the Covid-19 vaccination status and
the associated adverse event. Using just this node type it is therefore
possible to define DGPs including a time-to-event outcome (possibly with
recurrent events) with multiple time-varying covariates. While there are
multiple other methods to generate some forms of time-to-event data with
time-varying covariates <span class="citation">(Hendry 2013; Austin
2012; Huang et al. 2020; Ngwa et al. 2022)</span>, most of them require
strict parametrizations or do not support the use of multiple,
arbitrarily distributed time-varying variables. Additionally, neither of
these methods allows the inclusion of recurrent events or competing
events. None of these restrictions apply to the discrete-time simulation
approach.</p>
<p>However, the method also has two main disadvantages. First, it is a
lot more computationally expensive than other methods, and secondly it
does usually require the user to define appropriate functions to
generate the time- and individual specific probabilities per node.
Although the inherent computational complexity cannot be removed, it is
alleviated in the implementation of this package through the use of
optimized code and the <code>data.table</code> back-end <span class="citation">(Barrett et al. 2024)</span>. As shown in the article,
the presented implementation allows generation of large datasets in a
reasonable amount of time. A computationally more efficient alternative
not considered in this package would be <em>discrete-event
simulation</em> <span class="citation">(Banks et al. 2014)</span>, in
which the time until the next event is modeled directly instead of
simulating the entire process over time. Performing such simulations is,
however, usually a lot more demanding both conceptually and in terms of
required software development <span class="citation">(X. Zhang
2018)</span>. The burden of specifying appropriate input to the
<code>prob_fun</code> argument in our approach is comparatively small,
but it might still be a concern for some users. We hope that the many
provided examples and explanations in both this article and the
extensive documentation and multiple vignettes of the package will help
users overcome this issue.</p>
<p>To keep this article at a reasonable length, it was necessary to omit
some implemented features of the <code>simDAG</code> package. One of
these features is its capability to generate data for complex
multi-level DGPs. By internally using code from the <code>simr</code>
package <span class="citation">(Green and MacLeod 2016)</span>, it
allows users to add arbitrarily complex random effects and random slopes
to nodes of type <code>"gaussian"</code>, <code>"binomial"</code> and
<code>"poisson"</code>. This can be done by directly adding the standard
mixed model <code>R</code> syntax to the <code>formula</code> interface.
Additionally, while the main focus of the package is on generating data
from a user-defined DGP, the package offers limited support for
generating data that mimics already existing data through the
<code><a href="../reference/dag_from_data.html">dag_from_data()</a></code> function. This function only requires the
user to specify the causal dependencies assumed to be present in the
data and the type of each node and then directly extracts coefficients
and intercepts from the available data by fitting various models to it.
The returned DAG is then fully specified and can be used directly in a
standard <code><a href="../reference/sim_from_DAG.html">sim_from_dag()</a></code> call to obtain data similar to the
one supplied. Note that this function does not directly support all
available node types. If the main goal of the user is to generate such
synthetic mimicked datasets, using packages such as <code>simPop</code>
<span class="citation">(Templ et al. 2017)</span> might be
preferable.</p>
<p>Finally, we would like to note that the package is still under active
development. We are currently working on multiple new features to make
the package even more versatile for users. For example, future versions
of the package are planned to support the definition of interventions on
the DAG, much like the <code>simcausal</code> package <span class="citation">(Sofrygin, van der Laan, and Neugebauer 2017)</span>,
which would make it even easier to generate data for causal inference
based simulations, without having to re-define the DAG multiple times.
We also plan to extend the internal library of available node types, by
for example including node functions to simulate competing events data
without the use of discrete-time simulation <span class="citation">(Moriña and Navarro 2017; Haller and Ulm
2014)</span>.</p>
</div>
<div class="section level2">
<h2 id="computational-details">Computational details<a class="anchor" aria-label="anchor" href="#computational-details"></a>
</h2>
<p>The results in this paper were obtained using <code>R</code> 4.5.1
with the <code>data.table</code> 1.17.4 package, the
<code>survival</code> 3.8.3 package, the <code>igraph</code> 2.1.4
package, the <code>ggplot2</code> 3.5.2 package and the
<code>simDAG</code> 0.3.1 package. <code>R</code> itself and all
packages used are available from the Comprehensive <code>R</code>
Archive Network (CRAN) at <a href="https://CRAN.R-project.org/" class="external-link uri">https://CRAN.R-project.org/</a>.</p>
</div>
<div class="section level2">
<h2 id="acknowledgments">Acknowledgments<a class="anchor" aria-label="anchor" href="#acknowledgments"></a>
</h2>
<p>We would like to thank Katharina Meiszl for her valuable input and
for contributing some unit tests and input checks to the proposed
package. We would also like to thank the anonymous reviewers, whose
feedback and suggestions greatly improved the manuscript and the package
itself.</p>
</div>
<div class="section level2">
<h2 id="appendix-a-further-features-of-discrete-time-simulation">Appendix A: Further Features of Discrete-Time Simulation<a class="anchor" aria-label="anchor" href="#appendix-a-further-features-of-discrete-time-simulation"></a>
</h2>
<p>As mentioned in the main text, there are a lot of possible features
that could be included in the DGP using the discrete-time simulation
approach, which are not shown in the main text. Below we will give some
simple examples on how to use the discrete-time simulation approach
implemented in the <code>simDAG</code> package to generate artificial
data with some of these useful features. For most of these examples, the
first DGP shown in the Covid example Section will be extended.</p>
<div class="section level3">
<h3 id="time-dependent-base-probabilities">Time-Dependent Base Probabilities<a class="anchor" aria-label="anchor" href="#time-dependent-base-probabilities"></a>
</h3>
<p>To make
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>P</mi><mrow><mi>Y</mi><mn>0</mn></mrow></msub><annotation encoding="application/x-tex">P_{Y0}</annotation></semantics></math>
time-dependent, the <code>sim_time</code> argument may be used to change
the definition of the function that generates the myocarditis
probabilities. The following code gives an example for this:</p>
<div class="sourceCode" id="cb23"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">prob_myoc</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">data</span>, <span class="va">P_0</span>, <span class="va">RR_A</span>, <span class="va">sim_time</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">P_0</span> <span class="op">&lt;-</span> <span class="va">P_0</span> <span class="op">+</span> <span class="fl">0.001</span><span class="op">*</span><span class="va">sim_time</span></span>
<span>  <span class="fu"><a href="https://rdatatable.gitlab.io/data.table/reference/fifelse.html" class="external-link">fifelse</a></span><span class="op">(</span><span class="va">data</span><span class="op">$</span><span class="va">A_event</span>, <span class="va">P_0</span><span class="op">*</span><span class="va">RR_A</span>, <span class="va">P_0</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="va">dag</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/empty_dag.html">empty_dag</a></span><span class="op">(</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/node.html">node_td</a></span><span class="op">(</span><span class="st">"A"</span>, type<span class="op">=</span><span class="st">"time_to_event"</span>, prob_fun<span class="op">=</span><span class="fl">0.01</span>,</span>
<span>          event_duration<span class="op">=</span><span class="fl">20</span>, immunity_duration<span class="op">=</span><span class="fl">150</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/node.html">node_td</a></span><span class="op">(</span><span class="st">"Y"</span>, type<span class="op">=</span><span class="st">"time_to_event"</span>, prob_fun<span class="op">=</span><span class="va">prob_myoc</span>,</span>
<span>          parents<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"A_event"</span><span class="op">)</span>, P_0<span class="op">=</span><span class="fl">0.005</span>, RR_A<span class="op">=</span><span class="fl">3.24</span><span class="op">)</span></span>
<span></span>
<span><span class="va">sim</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/sim_discrete_time.html">sim_discrete_time</a></span><span class="op">(</span><span class="va">dag</span>, n_sim<span class="op">=</span><span class="fl">100</span>, max_t<span class="op">=</span><span class="fl">200</span><span class="op">)</span></span>
<span><span class="va">data</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/sim2data.html">sim2data</a></span><span class="op">(</span><span class="va">sim</span>, to<span class="op">=</span><span class="st">"start_stop"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">data</span><span class="op">)</span></span>
<span><span class="co">#&gt;      .id start  stop      A      Y</span></span>
<span><span class="co">#&gt;    &lt;int&gt; &lt;int&gt; &lt;num&gt; &lt;lgcl&gt; &lt;lgcl&gt;</span></span>
<span><span class="co">#&gt; 1:     1     1    13  FALSE  FALSE</span></span>
<span><span class="co">#&gt; 2:     1    14    17   TRUE  FALSE</span></span>
<span><span class="co">#&gt; 3:     1    18    18   TRUE   TRUE</span></span>
<span><span class="co">#&gt; 4:     1    19    24   TRUE  FALSE</span></span>
<span><span class="co">#&gt; 5:     1    25    25   TRUE   TRUE</span></span>
<span><span class="co">#&gt; 6:     1    26    33   TRUE  FALSE</span></span></code></pre></div>
<p>In this example, the base probability of myocarditis grows by 0.001
with each passing day, but the relative risk of infection given a
vaccination stays constant. More complex time-dependencies may of course
be implemented as well. The same procedure could also be used to make
the vaccination probabilities time-dependent as well.</p>
</div>
<div class="section level3">
<h3 id="time-dependent-effects">Time-Dependent Effects<a class="anchor" aria-label="anchor" href="#time-dependent-effects"></a>
</h3>
<p>In some scenarios it may also be required to make the effect itself
vary over time. Here, we could make the size of the relative risk of
developing a myocarditis given a recent Covid-19 vaccination dependent
on the calender time, again by using the <code>sim_time</code> argument
in the respective <code>prob_fun</code>:</p>
<div class="sourceCode" id="cb24"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">prob_myoc</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">data</span>, <span class="va">P_0</span>, <span class="va">RR_A</span>, <span class="va">sim_time</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">RR_A</span> <span class="op">&lt;-</span> <span class="va">RR_A</span> <span class="op">+</span> <span class="fl">0.01</span><span class="op">*</span><span class="va">sim_time</span></span>
<span>  <span class="fu"><a href="https://rdatatable.gitlab.io/data.table/reference/fifelse.html" class="external-link">fifelse</a></span><span class="op">(</span><span class="va">data</span><span class="op">$</span><span class="va">A_event</span>, <span class="va">P_0</span><span class="op">*</span><span class="va">RR_A</span>, <span class="va">P_0</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="va">dag</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/empty_dag.html">empty_dag</a></span><span class="op">(</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/node.html">node_td</a></span><span class="op">(</span><span class="st">"A"</span>, type<span class="op">=</span><span class="st">"time_to_event"</span>, prob_fun<span class="op">=</span><span class="fl">0.01</span>,</span>
<span>          event_duration<span class="op">=</span><span class="fl">20</span>, immunity_duration<span class="op">=</span><span class="fl">150</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/node.html">node_td</a></span><span class="op">(</span><span class="st">"Y"</span>, type<span class="op">=</span><span class="st">"time_to_event"</span>, prob_fun<span class="op">=</span><span class="va">prob_myoc</span>,</span>
<span>          parents<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"A_event"</span><span class="op">)</span>, P_0<span class="op">=</span><span class="fl">0.005</span>, RR_A<span class="op">=</span><span class="fl">3.24</span><span class="op">)</span></span>
<span></span>
<span><span class="va">sim</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/sim_discrete_time.html">sim_discrete_time</a></span><span class="op">(</span><span class="va">dag</span>, n_sim<span class="op">=</span><span class="fl">100</span>, max_t<span class="op">=</span><span class="fl">200</span><span class="op">)</span></span>
<span><span class="va">data</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/sim2data.html">sim2data</a></span><span class="op">(</span><span class="va">sim</span>, to<span class="op">=</span><span class="st">"start_stop"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">data</span><span class="op">)</span></span>
<span><span class="co">#&gt;      .id start  stop      A      Y</span></span>
<span><span class="co">#&gt;    &lt;int&gt; &lt;int&gt; &lt;num&gt; &lt;lgcl&gt; &lt;lgcl&gt;</span></span>
<span><span class="co">#&gt; 1:     1     1    16  FALSE  FALSE</span></span>
<span><span class="co">#&gt; 2:     1    17    36   TRUE  FALSE</span></span>
<span><span class="co">#&gt; 3:     1    37   200  FALSE  FALSE</span></span>
<span><span class="co">#&gt; 4:     2     1    21  FALSE  FALSE</span></span>
<span><span class="co">#&gt; 5:     2    22    22  FALSE   TRUE</span></span>
<span><span class="co">#&gt; 6:     2    23    58  FALSE  FALSE</span></span></code></pre></div>
<p>Here, the relative risk increases by 0.01 for each passing day,
meaning that the risk of a myocarditis given a recent vaccination
increases over time.</p>
</div>
<div class="section level3">
<h3 id="non-linear-effects">Non-Linear Effects<a class="anchor" aria-label="anchor" href="#non-linear-effects"></a>
</h3>
<p>In all previous examples, it was assumed that the effect of the
vaccination on the probability of developing a myocarditis follows a
step-function. The risk was instantly elevated by a constant factor
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><msub><mi>R</mi><mi>A</mi></msub></mrow><annotation encoding="application/x-tex">RR_A</annotation></semantics></math>)
after vaccination, which lasts for a specified amount of time and then
instantly drops back to the baseline risk. Any other kind of
relationship may also be simulated, by again changing the
<code>prob_myoc()</code> function accordingly. The following code may be
used:</p>
<div class="sourceCode" id="cb25"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">prob_myoc</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">data</span>, <span class="va">P_0</span>, <span class="va">RR_A</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">RR_A</span> <span class="op">&lt;-</span> <span class="va">RR_A</span> <span class="op">-</span> <span class="fl">0.1</span><span class="op">*</span><span class="va">data</span><span class="op">$</span><span class="va">A_time_since_last</span></span>
<span>  <span class="fu"><a href="https://rdatatable.gitlab.io/data.table/reference/fifelse.html" class="external-link">fifelse</a></span><span class="op">(</span><span class="va">data</span><span class="op">$</span><span class="va">A_event</span>, <span class="va">P_0</span><span class="op">*</span><span class="va">RR_A</span>, <span class="va">P_0</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="va">dag</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/empty_dag.html">empty_dag</a></span><span class="op">(</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/node.html">node_td</a></span><span class="op">(</span><span class="st">"A"</span>, type<span class="op">=</span><span class="st">"time_to_event"</span>, prob_fun<span class="op">=</span><span class="fl">0.01</span>,</span>
<span>          event_duration<span class="op">=</span><span class="fl">20</span>, immunity_duration<span class="op">=</span><span class="fl">150</span>,</span>
<span>          time_since_last<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/node.html">node_td</a></span><span class="op">(</span><span class="st">"Y"</span>, type<span class="op">=</span><span class="st">"time_to_event"</span>, prob_fun<span class="op">=</span><span class="va">prob_myoc</span>,</span>
<span>          parents<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"A_event"</span>, <span class="st">"A_time_since_last"</span><span class="op">)</span>,</span>
<span>          P_0<span class="op">=</span><span class="fl">0.005</span>, RR_A<span class="op">=</span><span class="fl">3.24</span><span class="op">)</span></span>
<span></span>
<span><span class="va">sim</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/sim_discrete_time.html">sim_discrete_time</a></span><span class="op">(</span><span class="va">dag</span>, n_sim<span class="op">=</span><span class="fl">100</span>, max_t<span class="op">=</span><span class="fl">200</span><span class="op">)</span></span>
<span><span class="va">data</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/sim2data.html">sim2data</a></span><span class="op">(</span><span class="va">sim</span>, to<span class="op">=</span><span class="st">"start_stop"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">data</span><span class="op">)</span></span>
<span><span class="co">#&gt;      .id start  stop      A      Y</span></span>
<span><span class="co">#&gt;    &lt;int&gt; &lt;int&gt; &lt;num&gt; &lt;lgcl&gt; &lt;lgcl&gt;</span></span>
<span><span class="co">#&gt; 1:     1     1     6  FALSE  FALSE</span></span>
<span><span class="co">#&gt; 2:     1     7    26   TRUE  FALSE</span></span>
<span><span class="co">#&gt; 3:     1    27    29  FALSE  FALSE</span></span>
<span><span class="co">#&gt; 4:     1    30    30  FALSE   TRUE</span></span>
<span><span class="co">#&gt; 5:     1    31   200  FALSE  FALSE</span></span>
<span><span class="co">#&gt; 6:     2     1    43  FALSE  FALSE</span></span></code></pre></div>
<p>In this code,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><msub><mi>R</mi><mi>A</mi></msub></mrow><annotation encoding="application/x-tex">RR_A</annotation></semantics></math>
decreases with each day after a person is vaccinated. In contrast to the
previous example, this happens on a person-specific time-scale and not
on a total calender time level. To do this properly, we set the
<code>time_since_last</code> argument inside the <code><a href="../reference/node.html">node_td()</a></code>
call of the vaccination definition to <code>TRUE</code>. This argument
is supported when using nodes of type <code>"time_to_event"</code>. It
adds another column to the dataset which includes the time since the
last vaccination was performed for each individual. This column is then
also added in the <code>parents</code> vector, so that we can use it in
<code>prob_myoc()</code> function. Here we simply substract 0.1 from
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><msub><mi>R</mi><mi>A</mi></msub></mrow><annotation encoding="application/x-tex">RR_A</annotation></semantics></math>
for each day after vaccination. This essentially means that on the day
of vaccination itself, the relative risk will be 3.24 as specified in
the <code>DAG</code>. On the first day after the vaccination, however,
the relative risk will only be 3.14 and so forth. In other words, the
extent of the adverse effect of the vaccination decreases over time
linearly. Again, more complex functions may also be used to model this
type of non-linear effects.</p>
</div>
<div class="section level3">
<h3 id="multiple-interrelated-binary-time-dependent-variables">Multiple Interrelated Binary Time-Dependent Variables<a class="anchor" aria-label="anchor" href="#multiple-interrelated-binary-time-dependent-variables"></a>
</h3>
<p>Another possibility to extent the DGP would be to add more
<code>"time_to_event"</code> variables. For example, we may want to
additionally consider the effect of a Covid-19 infection itself, denoted
by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>C</mi><mi>t</mi></msub><annotation encoding="application/x-tex">C_t</annotation></semantics></math>
here. For simplicity we will assume that Covid-19 has a constant
probability of occurrence over time which is the same for all
individuals.In this example we will assume that the vaccination reduces
the risk of getting a Covid-19 infection to 0 for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>d</mi><mrow><mi>i</mi><mi>m</mi><mi>m</mi><mi>u</mi><mi>n</mi><mi>e</mi></mrow></msub><annotation encoding="application/x-tex">d_{immune}</annotation></semantics></math>
days after the vaccination was performed. We may use the following
structural equation to describe this variable:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>t</mi></msub><mo>∼</mo><mi>B</mi><mi>e</mi><mi>r</mi><mi>n</mi><mi>o</mi><mi>u</mi><mi>l</mi><mi>l</mi><mi>i</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>P</mi><mi>C</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mrow><annotation encoding="application/x-tex">
    C_t \sim Bernoulli(P_{C}(t)),
</annotation></semantics></math></p>
<p>with:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>C</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><mtable><mtr><mtd columnalign="left" style="text-align: left"><mn>0</mn><mo>,</mo></mtd><mtd columnalign="left" style="text-align: left"><mrow><mtext mathvariant="normal">if </mtext><mspace width="0.333em"></mspace></mrow><mi>t</mi><mo>∈</mo><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>T</mi><mi>A</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><msub><mi>T</mi><mi>A</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msub><mi>d</mi><mrow><mi>i</mi><mi>m</mi><mi>m</mi><mi>u</mi><mi>n</mi><mi>e</mi></mrow></msub><mo stretchy="true" form="postfix">]</mo></mrow></mtd></mtr><mtr><mtd columnalign="left" style="text-align: left"><msub><mi>P</mi><mrow><mi>C</mi><mn>0</mn></mrow></msub><mo>,</mo></mtd><mtd columnalign="left" style="text-align: left"><mtext mathvariant="normal">otherwise</mtext></mtd></mtr></mtable></mrow><mo>,</mo></mrow><annotation encoding="application/x-tex">
    P_{C}(t) =
    \begin{cases}
        0, &amp; \text{if } t \in  \left[T_{A}(t), T_{A}(t) + d_{immune}\right] \\
        P_{C0}, &amp; \text{otherwise}
    \end{cases},
</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>P</mi><mrow><mi>C</mi><mn>0</mn></mrow></msub><annotation encoding="application/x-tex">P_{C0}</annotation></semantics></math>
is the baseline probability of experiencing a Covid-19 infection and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>A</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">T_A(t)</annotation></semantics></math>
is still defined to be the time of the last Covid-19 vaccination as
before. In addition to this, we will also change the definition of the
myocarditis node
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Y</mi><mi>t</mi></msub><annotation encoding="application/x-tex">Y_t</annotation></semantics></math>).
Instead of being only dependent on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>A</mi><mi>t</mi></msub><annotation encoding="application/x-tex">A_t</annotation></semantics></math>,
the Covid-19 Infection should now also raise the probability of
developing a myocarditis by a constant factor
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><msub><mi>R</mi><mi>C</mi></msub></mrow><annotation encoding="application/x-tex">RR_C</annotation></semantics></math>
in the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>d</mi><mrow><mi>C</mi><mi>.</mi><mi>r</mi><mi>i</mi><mi>s</mi><mi>k</mi></mrow></msub><annotation encoding="application/x-tex">d_{C.risk}</annotation></semantics></math>
days after the Covid-19 infection. The structural equation can then be
changed to be:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Y</mi><mi>t</mi></msub><mo>∼</mo><mi>B</mi><mi>e</mi><mi>r</mi><mi>n</mi><mi>o</mi><mi>u</mi><mi>l</mi><mi>l</mi><mi>i</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>P</mi><mi>Y</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mrow><annotation encoding="application/x-tex">
    Y_t \sim Bernoulli(P_{Y}(t)),
</annotation></semantics></math></p>
<p>with:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>Y</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><mtable><mtr><mtd columnalign="left" style="text-align: left"><msub><mi>P</mi><mrow><mi>Y</mi><mn>0</mn></mrow></msub><mo>⋅</mo><mi>R</mi><msub><mi>R</mi><mi>A</mi></msub><mo>⋅</mo><mi>R</mi><msub><mi>R</mi><mi>C</mi></msub><mo>,</mo></mtd><mtd columnalign="left" style="text-align: left"><mrow><mtext mathvariant="normal">if </mtext><mspace width="0.333em"></mspace></mrow><mi>t</mi><mo>∈</mo><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>T</mi><mi>A</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><msub><mi>T</mi><mi>A</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msub><mi>d</mi><mrow><mi>A</mi><mi>.</mi><mi>r</mi><mi>i</mi><mi>s</mi><mi>k</mi></mrow></msub><mo stretchy="true" form="postfix">]</mo></mrow><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> and </mtext><mspace width="0.333em"></mspace></mrow><mi>t</mi><mo>∈</mo><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>T</mi><mi>A</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><msub><mi>T</mi><mi>A</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msub><mi>d</mi><mrow><mi>C</mi><mi>.</mi><mi>r</mi><mi>i</mi><mi>s</mi><mi>k</mi></mrow></msub><mo stretchy="true" form="postfix">]</mo></mrow></mtd></mtr><mtr><mtd columnalign="left" style="text-align: left"><msub><mi>P</mi><mrow><mi>Y</mi><mn>0</mn></mrow></msub><mo>⋅</mo><mi>R</mi><msub><mi>R</mi><mi>C</mi></msub><mo>,</mo></mtd><mtd columnalign="left" style="text-align: left"><mrow><mtext mathvariant="normal">if </mtext><mspace width="0.333em"></mspace></mrow><mi>t</mi><mo>∈</mo><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>T</mi><mi>A</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><msub><mi>T</mi><mi>A</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msub><mi>d</mi><mrow><mi>C</mi><mi>.</mi><mi>r</mi><mi>i</mi><mi>s</mi><mi>k</mi></mrow></msub><mo stretchy="true" form="postfix">]</mo></mrow></mtd></mtr><mtr><mtd columnalign="left" style="text-align: left"><msub><mi>P</mi><mrow><mi>Y</mi><mn>0</mn></mrow></msub><mo>⋅</mo><mi>R</mi><msub><mi>R</mi><mi>A</mi></msub><mo>,</mo></mtd><mtd columnalign="left" style="text-align: left"><mrow><mtext mathvariant="normal">if </mtext><mspace width="0.333em"></mspace></mrow><mi>t</mi><mo>∈</mo><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>T</mi><mi>A</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><msub><mi>T</mi><mi>A</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msub><mi>d</mi><mrow><mi>A</mi><mi>.</mi><mi>r</mi><mi>i</mi><mi>s</mi><mi>k</mi></mrow></msub><mo stretchy="true" form="postfix">]</mo></mrow></mtd></mtr><mtr><mtd columnalign="left" style="text-align: left"><msub><mi>P</mi><mrow><mi>Y</mi><mn>0</mn></mrow></msub><mo>,</mo></mtd><mtd columnalign="left" style="text-align: left"><mtext mathvariant="normal">otherwise</mtext></mtd></mtr></mtable></mrow><mo>,</mo></mrow><annotation encoding="application/x-tex">
    P_{Y}(t) =
    \begin{cases}
        P_{Y0} \cdot RR_{A} \cdot RR_{C}, &amp; \text{if } t \in  \left[T_{A}(t), T_{A}(t) + d_{A.risk}\right] \text{ and } t \in  \left[T_{A}(t), T_{A}(t) + d_{C.risk}\right] \\
        P_{Y0} \cdot RR_{C}, &amp; \text{if } t \in  \left[T_{A}(t), T_{A}(t) + d_{C.risk}\right] \\
        P_{Y0} \cdot RR_{A}, &amp; \text{if } t \in  \left[T_{A}(t), T_{A}(t) + d_{A.risk}\right] \\
        P_{Y0}, &amp; \text{otherwise}
    \end{cases},
</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>d</mi><mrow><mi>A</mi><mi>.</mi><mi>r</mi><mi>i</mi><mi>s</mi><mi>k</mi></mrow></msub><annotation encoding="application/x-tex">d_{A.risk}</annotation></semantics></math>
is the duration after vaccination in which the risk of developing a
myocarditis is elevated by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><msub><mi>R</mi><mi>A</mi></msub></mrow><annotation encoding="application/x-tex">RR_A</annotation></semantics></math>.
The structural equation for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
are the same as defined in previous Equations. The following code may be
used to generate data from this DGP:</p>
<div class="sourceCode" id="cb26"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">prob_myoc</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">data</span>, <span class="va">P_0</span>, <span class="va">RR_A</span>, <span class="va">RR_C</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">P_0</span> <span class="op">*</span> <span class="va">RR_A</span><span class="op">^</span><span class="op">(</span><span class="va">data</span><span class="op">$</span><span class="va">A_event</span><span class="op">)</span> <span class="op">*</span> <span class="va">RR_C</span><span class="op">^</span><span class="op">(</span><span class="va">data</span><span class="op">$</span><span class="va">C_event</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="va">prob_covid</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">data</span>, <span class="va">P_0</span>, <span class="va">d_immune</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rdatatable.gitlab.io/data.table/reference/fifelse.html" class="external-link">fifelse</a></span><span class="op">(</span><span class="va">data</span><span class="op">$</span><span class="va">A_time_since_last</span> <span class="op">&lt;</span> <span class="va">d_immune</span>, <span class="fl">0</span>, <span class="va">P_0</span>, na<span class="op">=</span><span class="va">P_0</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="va">dag</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/empty_dag.html">empty_dag</a></span><span class="op">(</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/node.html">node_td</a></span><span class="op">(</span><span class="st">"A"</span>, type<span class="op">=</span><span class="st">"time_to_event"</span>, prob_fun<span class="op">=</span><span class="fl">0.01</span>,</span>
<span>          event_duration<span class="op">=</span><span class="fl">20</span>, immunity_duration<span class="op">=</span><span class="fl">150</span>,</span>
<span>          time_since_last<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/node.html">node_td</a></span><span class="op">(</span><span class="st">"C"</span>, type<span class="op">=</span><span class="st">"time_to_event"</span>, prob_fun<span class="op">=</span><span class="va">prob_covid</span>,</span>
<span>          parents<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"A_time_since_last"</span><span class="op">)</span>, event_duration<span class="op">=</span><span class="fl">14</span>,</span>
<span>          P_0<span class="op">=</span><span class="fl">0.01</span>, d_immune<span class="op">=</span><span class="fl">120</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/node.html">node_td</a></span><span class="op">(</span><span class="st">"Y"</span>, type<span class="op">=</span><span class="st">"time_to_event"</span>, prob_fun<span class="op">=</span><span class="va">prob_myoc</span>,</span>
<span>          parents<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"A_event"</span>, <span class="st">"A_time_since_last"</span>, <span class="st">"C_event"</span><span class="op">)</span>,</span>
<span>          P_0<span class="op">=</span><span class="fl">0.005</span>, RR_A<span class="op">=</span><span class="fl">3.24</span>, RR_C<span class="op">=</span><span class="fl">2.5</span><span class="op">)</span></span>
<span></span>
<span><span class="va">sim</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/sim_discrete_time.html">sim_discrete_time</a></span><span class="op">(</span><span class="va">dag</span>, n_sim<span class="op">=</span><span class="fl">100</span>, max_t<span class="op">=</span><span class="fl">200</span><span class="op">)</span></span>
<span><span class="va">data</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/sim2data.html">sim2data</a></span><span class="op">(</span><span class="va">sim</span>, to<span class="op">=</span><span class="st">"start_stop"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">data</span><span class="op">)</span></span>
<span><span class="co">#&gt;      .id start  stop      A      C      Y</span></span>
<span><span class="co">#&gt;    &lt;int&gt; &lt;int&gt; &lt;num&gt; &lt;lgcl&gt; &lt;lgcl&gt; &lt;lgcl&gt;</span></span>
<span><span class="co">#&gt; 1:     1     1    46  FALSE  FALSE  FALSE</span></span>
<span><span class="co">#&gt; 2:     1    47    47  FALSE  FALSE   TRUE</span></span>
<span><span class="co">#&gt; 3:     1    48    50  FALSE  FALSE  FALSE</span></span>
<span><span class="co">#&gt; 4:     1    51    51  FALSE  FALSE   TRUE</span></span>
<span><span class="co">#&gt; 5:     1    52    58  FALSE  FALSE  FALSE</span></span>
<span><span class="co">#&gt; 6:     1    59    72  FALSE   TRUE  FALSE</span></span></code></pre></div>
<p>In this code we first re-define the <code>prob_myoc()</code> function
to include the effect of the Covid-19 infection. This utilizes a small
computational trick, relying on the fact that any number to the power of
0 is 1 and any number to the power of 1 is itself. Since
<code>TRUE</code> is treated as a 1 and <code>FALSE</code> is
interpreted as a 0 in R, we can simply take the relative risks to the
power of their current event indicator to only multiply the baseline
risk with the respective relative risks if they are currently in the
risk durations. Next, we define a new function called
<code>prob_covid()</code> to include the immunity duration, again using
the <code>time_since_last</code> functionality. By finally adding
another <code><a href="../reference/node.html">node_td()</a></code> call to the <code>DAG</code> object, we
were able to specify the DGP in the desired way.</p>
</div>
<div class="section level3">
<h3 id="using-baseline-covariates">Using Baseline Covariates<a class="anchor" aria-label="anchor" href="#using-baseline-covariates"></a>
</h3>
<p>Previously, only time-dependent variable were included in the DGP. By
adding calls to the simple <code><a href="../reference/node.html">node()</a></code> function to the
<code>DAG</code> object it is, however, also possible to additionally
include time-independent variables as well. Suppose that we want the
baseline probability
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>P</mi><mrow><mi>A</mi><mn>0</mn></mrow></msub><annotation encoding="application/x-tex">P_{A0}</annotation></semantics></math>
of the vaccination to vary by biological sex in the first DGP described
in the Covid example Section. We could do this using the following
code:</p>
<div class="sourceCode" id="cb27"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">prob_myoc</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">data</span>, <span class="va">P_0</span>, <span class="va">RR_A</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rdatatable.gitlab.io/data.table/reference/fifelse.html" class="external-link">fifelse</a></span><span class="op">(</span><span class="va">data</span><span class="op">$</span><span class="va">A_event</span>, <span class="va">P_0</span><span class="op">*</span><span class="va">RR_A</span>, <span class="va">P_0</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="va">prob_vacc</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">data</span>, <span class="va">P_0</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rdatatable.gitlab.io/data.table/reference/fifelse.html" class="external-link">fifelse</a></span><span class="op">(</span><span class="va">data</span><span class="op">$</span><span class="va">Sex</span>, <span class="va">P_0</span><span class="op">*</span><span class="fl">2</span>, <span class="va">P_0</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="va">dag</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/empty_dag.html">empty_dag</a></span><span class="op">(</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/node.html">node</a></span><span class="op">(</span><span class="st">"Sex"</span>, type<span class="op">=</span><span class="st">"rbernoulli"</span>, p<span class="op">=</span><span class="fl">0.4</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/node.html">node_td</a></span><span class="op">(</span><span class="st">"A"</span>, type<span class="op">=</span><span class="st">"time_to_event"</span>, prob_fun<span class="op">=</span><span class="fl">0.01</span>,</span>
<span>          event_duration<span class="op">=</span><span class="fl">20</span>, immunity_duration<span class="op">=</span><span class="fl">150</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/node.html">node_td</a></span><span class="op">(</span><span class="st">"Y"</span>, type<span class="op">=</span><span class="st">"time_to_event"</span>, prob_fun<span class="op">=</span><span class="va">prob_myoc</span>,</span>
<span>          parents<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"A_event"</span><span class="op">)</span>, P_0<span class="op">=</span><span class="fl">0.005</span>, RR_A<span class="op">=</span><span class="fl">3.24</span><span class="op">)</span></span>
<span></span>
<span><span class="va">sim</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/sim_discrete_time.html">sim_discrete_time</a></span><span class="op">(</span><span class="va">dag</span>, n_sim<span class="op">=</span><span class="fl">100</span>, max_t<span class="op">=</span><span class="fl">200</span><span class="op">)</span></span>
<span><span class="va">data</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/sim2data.html">sim2data</a></span><span class="op">(</span><span class="va">sim</span>, to<span class="op">=</span><span class="st">"start_stop"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">data</span><span class="op">)</span></span>
<span><span class="co">#&gt;      .id start  stop      A      Y    Sex</span></span>
<span><span class="co">#&gt;    &lt;int&gt; &lt;int&gt; &lt;num&gt; &lt;lgcl&gt; &lt;lgcl&gt; &lt;lgcl&gt;</span></span>
<span><span class="co">#&gt; 1:     1     1    48  FALSE  FALSE  FALSE</span></span>
<span><span class="co">#&gt; 2:     1    49    49  FALSE   TRUE  FALSE</span></span>
<span><span class="co">#&gt; 3:     1    50    58  FALSE  FALSE  FALSE</span></span>
<span><span class="co">#&gt; 4:     1    59    59  FALSE   TRUE  FALSE</span></span>
<span><span class="co">#&gt; 5:     1    60   200  FALSE  FALSE  FALSE</span></span>
<span><span class="co">#&gt; 6:     2     1     4  FALSE  FALSE   TRUE</span></span></code></pre></div>
<p>Here, everything is kept the same as in the original example, with
the small change that we now add a call to <code><a href="../reference/node.html">node()</a></code> before
adding the time-dependent variables to define the <code>Sex</code> node
using a simple Bernoulli distribution. Additionally, we now had to
define a function that appropriately generates the probabilities of
vaccination per <code>Sex</code>. This was done by simply increasing
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>P</mi><mn>0</mn></msub><annotation encoding="application/x-tex">P_0</annotation></semantics></math>
by a factor of 2 whenever the value of <code>Sex</code> is
<code>TRUE</code> (which might stand for males or females). It would
also be possible to add child time-independent child nodes as well, but
this is left as an exercise to the interested reader.</p>
</div>
<div class="section level3">
<h3 id="using-categorical-time-dependent-variables">Using Categorical Time-Dependent Variables<a class="anchor" aria-label="anchor" href="#using-categorical-time-dependent-variables"></a>
</h3>
<p>The previous examples all included only binary time-dependent
variables. For some applications it may be neccessary to used
categorical time-dependent variables. For example, instead of generating
the vaccination status as binary, we may want to model it as a
categorical variable with multiple levels, indicating which kind of
vaccine the person received (if any). This may be done using the
<code>"competing_events"</code> node <code>type</code>. Below is a
simple example:</p>
<div class="sourceCode" id="cb28"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">prob_myoc</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">data</span>, <span class="va">P_0</span>, <span class="va">RR_A</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rdatatable.gitlab.io/data.table/reference/fifelse.html" class="external-link">fifelse</a></span><span class="op">(</span><span class="va">data</span><span class="op">$</span><span class="va">A_event</span> <span class="op">&gt;</span> <span class="fl">0</span>, <span class="va">P_0</span><span class="op">*</span><span class="va">RR_A</span>, <span class="va">P_0</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="va">prob_vacc</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">data</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">n</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">data</span><span class="op">)</span></span>
<span>  <span class="va">p_mat</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">0.99</span>, <span class="va">n</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">0.0005</span>, <span class="va">n</span><span class="op">)</span>,</span>
<span>                    <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">0.0005</span>, <span class="va">n</span><span class="op">)</span><span class="op">)</span>,</span>
<span>                  byrow<span class="op">=</span><span class="cn">FALSE</span>, ncol<span class="op">=</span><span class="fl">3</span><span class="op">)</span></span>
<span>  <span class="kw"><a href="https://rdrr.io/r/base/function.html" class="external-link">return</a></span><span class="op">(</span><span class="va">p_mat</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="va">dag</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/empty_dag.html">empty_dag</a></span><span class="op">(</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/node.html">node_td</a></span><span class="op">(</span><span class="st">"A"</span>, type<span class="op">=</span><span class="st">"competing_events"</span>, prob_fun<span class="op">=</span><span class="va">prob_vacc</span>,</span>
<span>          event_duration<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">20</span>, <span class="fl">20</span><span class="op">)</span>, immunity_duration<span class="op">=</span><span class="fl">150</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/node.html">node_td</a></span><span class="op">(</span><span class="st">"Y"</span>, type<span class="op">=</span><span class="st">"time_to_event"</span>, prob_fun<span class="op">=</span><span class="va">prob_myoc</span>,</span>
<span>          parents<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"A_event"</span><span class="op">)</span>, P_0<span class="op">=</span><span class="fl">0.005</span>, RR_A<span class="op">=</span><span class="fl">3.24</span><span class="op">)</span></span>
<span></span>
<span><span class="va">sim</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/sim_discrete_time.html">sim_discrete_time</a></span><span class="op">(</span><span class="va">dag</span>, n_sim<span class="op">=</span><span class="fl">100</span>, max_t<span class="op">=</span><span class="fl">200</span>,</span>
<span>                         save_states<span class="op">=</span><span class="st">"all"</span><span class="op">)</span></span>
<span><span class="va">data</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/sim2data.html">sim2data</a></span><span class="op">(</span><span class="va">sim</span>, to<span class="op">=</span><span class="st">"start_stop"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">data</span><span class="op">)</span></span>
<span><span class="co">#&gt;      .id start  stop     A      Y</span></span>
<span><span class="co">#&gt;    &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;num&gt; &lt;lgcl&gt;</span></span>
<span><span class="co">#&gt; 1:     1     1    23     0  FALSE</span></span>
<span><span class="co">#&gt; 2:     1    24    24     0   TRUE</span></span>
<span><span class="co">#&gt; 3:     1    25    53     0  FALSE</span></span>
<span><span class="co">#&gt; 4:     1    54    73     1  FALSE</span></span>
<span><span class="co">#&gt; 5:     1    74   159     0  FALSE</span></span>
<span><span class="co">#&gt; 6:     1   160   160     0   TRUE</span></span></code></pre></div>
<p>The <code>"competing_events"</code> node <code>type</code> works in
much the same way as the <code>"time_to_event"</code> node type, with
the main difference being that instead of using Bernoulli trials it
relies on multinomial trials, which are equivalent to drawing a simple
random sample with unequal probabilities for each element. Instead of
supplying a single probability of success per person and per point in
time, the <code>prob_fun</code> supplied to a
<code>"competing_events"</code> node is therefore expected to provide a
vector of probabilities. In the example above, we simply define the
probabilities to be the same for everyone regardless of the simulated
time. The first category represents “no vaccination” while the next two
categories specify vaccinations with vaccines of different kinds. Note
that in this code, the <code>prob_myoc()</code> function only checks
whether there was any vaccination, so it does not really make a
difference whether one uses a <code>"competing_events"</code> or
<code>"time_to_event"</code> node here.</p>
<p>To get more useful person specific multinomial probabilities, the
<code><a href="../reference/node_multinomial.html">node_multinomial()</a></code> function may be useful. Because the
underlying code for multinomial trials is a bit more complex than the
code for simple Bernoulli trials, using this type of node may lead to an
increased runtime. The node type is usually most useful when the goal is
to generate artificial time-to-event data with mutually exclusive types
of events, also known as competing events or competing risks data. Also
note that in the example we had to set the <code>save_states</code>
argument of the <code><a href="../reference/sim_discrete_time.html">sim_discrete_time()</a></code> function to
<code>"all"</code>. This is required when the goal is to transform the
data into the start-stop format later, because the DGP does not consist
solely of time-dependent nodes of type <code>"time_to_event"</code>.</p>
</div>
<div class="section level3">
<h3 id="using-continuous-time-dependent-variables">Using Continuous Time-Dependent Variables<a class="anchor" aria-label="anchor" href="#using-continuous-time-dependent-variables"></a>
</h3>
<p>It is also possible to use continuous variables as time-dependent
variables in the proposed package. The following code gives a very
simple example:</p>
<div class="sourceCode" id="cb29"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">dag</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/empty_dag.html">empty_dag</a></span><span class="op">(</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/node.html">node</a></span><span class="op">(</span><span class="st">"calories"</span>, type<span class="op">=</span><span class="st">"rnorm"</span>, mean<span class="op">=</span><span class="fl">2500</span>, sd<span class="op">=</span><span class="fl">150</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/node.html">node_td</a></span><span class="op">(</span><span class="st">"calories"</span>, type<span class="op">=</span><span class="st">"gaussian"</span>,</span>
<span>          formula<span class="op">=</span> <span class="op">~</span> <span class="fl">1</span> <span class="op">+</span> <span class="va">calories</span><span class="op">*</span><span class="fl">1.1</span>, error<span class="op">=</span><span class="fl">1</span><span class="op">)</span></span>
<span></span>
<span><span class="va">sim</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/sim_discrete_time.html">sim_discrete_time</a></span><span class="op">(</span><span class="va">dag</span>, n_sim<span class="op">=</span><span class="fl">100</span>, max_t<span class="op">=</span><span class="fl">200</span>,</span>
<span>                         save_states<span class="op">=</span><span class="st">"all"</span><span class="op">)</span></span>
<span><span class="va">data</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/sim2data.html">sim2data</a></span><span class="op">(</span><span class="va">sim</span>, to<span class="op">=</span><span class="st">"long"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">data</span><span class="op">)</span></span>
<span><span class="co">#&gt; Key: &lt;.id, .time&gt;</span></span>
<span><span class="co">#&gt;      .id .time calories</span></span>
<span><span class="co">#&gt;    &lt;int&gt; &lt;int&gt;    &lt;num&gt;</span></span>
<span><span class="co">#&gt; 1:     1     1 2837.652</span></span>
<span><span class="co">#&gt; 2:     1     2 3123.649</span></span>
<span><span class="co">#&gt; 3:     1     3 3436.496</span></span>
<span><span class="co">#&gt; 4:     1     4 3782.254</span></span>
<span><span class="co">#&gt; 5:     1     5 4160.574</span></span>
<span><span class="co">#&gt; 6:     1     6 4577.265</span></span></code></pre></div>
<p>In this example, we first generate a normally distributed root node
called <code>calories</code> using a standard <code><a href="../reference/node.html">node()</a></code> call.
This represents the value of the variable at
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">t = 0</annotation></semantics></math>.
If we did not specify this variable, the code would return an error
message at
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">t = 1</annotation></semantics></math>,
because there would be no value of <code>calories</code> to use in the
subsequently defined regression model. Next, a call to
<code><a href="../reference/node.html">node_td()</a></code> is added to the <code>DAG</code> object to
specify how this variable changes with each step in time. We use a
simple linear regression model, where the only independent variable is
the last value of the variable itself. In the subsequent simulation we
again set <code>save_states="all"</code> to specify that the data at all
points in time should be saved. This is necessary here both because the
<code>DAG</code> consists of time-dependent nodes that are not of type
<code>"time_to_event"</code>, and because the variable changes at every
point in time for every individual. Because of the nature of the data,
it would also not make sense to transform the data into the start-stop
format. Instead, the long format is choosen here.</p>
</div>
<div class="section level3">
<h3 id="ordered-events">Ordered Events<a class="anchor" aria-label="anchor" href="#ordered-events"></a>
</h3>
<p>The following code gives an example on how events could be simulated
so that a specific order of events is always respected:</p>
<div class="sourceCode" id="cb30"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">prob_bachelors</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">data</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rdatatable.gitlab.io/data.table/reference/fifelse.html" class="external-link">fifelse</a></span><span class="op">(</span><span class="va">data</span><span class="op">$</span><span class="va">highschool_event</span>, <span class="fl">0.01</span>, <span class="fl">0</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="va">prob_masters</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">data</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rdatatable.gitlab.io/data.table/reference/fifelse.html" class="external-link">fifelse</a></span><span class="op">(</span><span class="va">data</span><span class="op">$</span><span class="va">bachelors_event</span>, <span class="fl">0.01</span>, <span class="fl">0</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="va">dag</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/empty_dag.html">empty_dag</a></span><span class="op">(</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/node.html">node_td</a></span><span class="op">(</span><span class="st">"highschool"</span>, type<span class="op">=</span><span class="st">"time_to_event"</span>, prob_fun<span class="op">=</span><span class="fl">0.01</span>,</span>
<span>          event_duration<span class="op">=</span><span class="cn">Inf</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/node.html">node_td</a></span><span class="op">(</span><span class="st">"bachelors"</span>, type<span class="op">=</span><span class="st">"time_to_event"</span>, prob_fun<span class="op">=</span><span class="va">prob_bachelors</span>,</span>
<span>          event_duration<span class="op">=</span><span class="cn">Inf</span>, parents<span class="op">=</span><span class="st">"highschool_event"</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/node.html">node_td</a></span><span class="op">(</span><span class="st">"masters"</span>, type<span class="op">=</span><span class="st">"time_to_event"</span>, prob_fun<span class="op">=</span><span class="va">prob_masters</span>,</span>
<span>          event_duration<span class="op">=</span><span class="cn">Inf</span>, parents<span class="op">=</span><span class="st">"bachelors_event"</span><span class="op">)</span></span>
<span></span>
<span><span class="va">sim</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/sim_discrete_time.html">sim_discrete_time</a></span><span class="op">(</span><span class="va">dag</span>, n_sim<span class="op">=</span><span class="fl">100</span>, max_t<span class="op">=</span><span class="fl">200</span><span class="op">)</span></span>
<span><span class="va">data</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/sim2data.html">sim2data</a></span><span class="op">(</span><span class="va">sim</span>, to<span class="op">=</span><span class="st">"start_stop"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">data</span><span class="op">)</span></span>
<span><span class="co">#&gt;      .id start  stop highschool bachelors masters</span></span>
<span><span class="co">#&gt;    &lt;int&gt; &lt;int&gt; &lt;num&gt;     &lt;lgcl&gt;    &lt;lgcl&gt;  &lt;lgcl&gt;</span></span>
<span><span class="co">#&gt; 1:     1     1    75      FALSE     FALSE   FALSE</span></span>
<span><span class="co">#&gt; 2:     1    76   200       TRUE     FALSE   FALSE</span></span>
<span><span class="co">#&gt; 3:     2     1     4      FALSE     FALSE   FALSE</span></span>
<span><span class="co">#&gt; 4:     2     5   178       TRUE     FALSE   FALSE</span></span>
<span><span class="co">#&gt; 5:     2   179   200       TRUE      TRUE   FALSE</span></span>
<span><span class="co">#&gt; 6:     3     1   116      FALSE     FALSE   FALSE</span></span></code></pre></div>
<p>In this specification, we try to simulate the educational status of a
person over time. We assume that individuals can only obtain a bachelors
degree once they have finished high school and that they can only
receive a masters degree once they finished the bachelors degree. To
keep this order of events in tact, we can split the variable into its
three constituent parts. First, the indicator whether someone graduated
<code>highschool</code> is simulated using simple Bernoulli trials as
implemented in the <code>"time_to_event"</code> node type. By setting
<code>event_duration=Inf</code>, we ensure that no one ever “looses”
their degree. Only afterwards do we generate whether the same person
also received a <code>bachelors</code> degree. By using a standard
<code><a href="https://rdatatable.gitlab.io/data.table/reference/fifelse.html" class="external-link">fifelse()</a></code> call, we can easily specify that the probability
of obtaining a <code>bachelors</code> degree is 0 for individuals
without a <code>highschool</code> degree. Subsequently, we do the same
for the <code>masters</code> node.</p>
<p>Again, this simulation could be made much more realistic. For
example, in the example used here there is no limitations on how close
the different graduations can be to each other. An individual might
receive all three degrees in the same time unit. This could be changed
by using the <code>sim_time</code> argument in the definition of the
probability functions, as discussed earlier.</p>
</div>
</div>
<div class="section level2">
<h2 class="unnumbered" id="literature">Literature<a class="anchor" aria-label="anchor" href="#literature"></a>
</h2>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-Alfons2010" class="csl-entry">
Alfons, Andreas, Matthias Templ, and Peter Filzmoser. 2010. <span>“An
Object-Oriented Framework for Statistical Simulation: The r Package
simFrame.”</span> <em>Journal of Statistical Software</em> 37 (3): 1–36.
<a href="https://doi.org/10.18637/jss.v037.i03" class="external-link">https://doi.org/10.18637/jss.v037.i03</a>.
</div>
<div id="ref-Andrews2024" class="csl-entry">
Andrews, Bryan, and Erich Kummerfeld. 2024. <span>“Better Simulations
for Validating Causal Discovery with the DAG-Adaptation of the Onion
Method.”</span> arXiv:2405.13100v1.
</div>
<div id="ref-Arnold2011" class="csl-entry">
Arnold, Benjamin F., Daniel R. Hogan, John M. Colford Jr., and Alan E.
Hubbard. 2011. <span>“Simulation Methods to Estimate Design Power: An
Overview for Applied Research.”</span> <em>BMC Medical Research
Methodology</em> 11 (94): 1–10. <a href="https://doi.org/10.1186/1471-2288-11-94" class="external-link">https://doi.org/10.1186/1471-2288-11-94</a>.
</div>
<div id="ref-Asparouhov2020" class="csl-entry">
Asparouhov, Tihomir, and Bengt Muthén. 2020. <span>“Comparison of Models
for the Analysis of Intensive Longitudinal Data.”</span> <em>Structural
Equation Modeling: A Multidisciplinary Journal</em> 27 (2): 275–97. <a href="https://doi.org/10.1080/10705511.2019.1626733" class="external-link">https://doi.org/10.1080/10705511.2019.1626733</a>.
</div>
<div id="ref-Austin2012" class="csl-entry">
Austin, Peter C. 2012. <span>“Generating Survival Times to Simulate Cox
Proportional Hazards Models with Time-Varying Covariates.”</span>
<em>Statistics in Medicine</em> 31 (29): 3946–58. <a href="https://doi.org/10.1002/sim.5452" class="external-link">https://doi.org/10.1002/sim.5452</a>.
</div>
<div id="ref-Banks2014" class="csl-entry">
Banks, Jerry, John S. Carson II, Barry L. Nelson, and David M. Nicol.
2014. <em>Discrete-Event System Simulation</em>. Vol. 5. Edinburgh Gate:
Pearson Education Limited.
</div>
<div id="ref-Barrett2024" class="csl-entry">
Barrett, Tyson, Matt Dowle, Arun Srinivasan, Jan Gorecki, Michael
Chirico, and Toby Hocking. 2024. <em>Data.table: Extension of
‘Data.frame‘</em>. <a href="https://CRAN.R-project.org/package=data.table" class="external-link">https://CRAN.R-project.org/package=data.table</a>.
</div>
<div id="ref-Bender2005" class="csl-entry">
Bender, Ralf, Thomas Augustin, and Maria Blettner. 2005.
<span>“Generating Survival Times to Simulate Cox Proportional Hazards
Models.”</span> <em>Statistics in Medicine</em> 24 (11): 1713–23. <a href="https://doi.org/10.1002/sim.2059" class="external-link">https://doi.org/10.1002/sim.2059</a>.
</div>
<div id="ref-Brilleman2021" class="csl-entry">
Brilleman, Samuel L., Rory Wolfe, Margarita Moreno-Betancur, and Michael
J. Crowther. 2021. <span>“Simulating Survival Data Using the Simsurv r
Package.”</span> <em>Journal of Statistical Software</em> 97 (3). <a href="https://doi.org/10.18637/jss.v097.i03" class="external-link">https://doi.org/10.18637/jss.v097.i03</a>.
</div>
<div id="ref-Byeon2023" class="csl-entry">
Byeon, Sangmin, and Woojoo Lee. 2023. <span>“Directed Acyclic Graphs for
Clinical Research: A Tutorial.”</span> <em>Journal of Minimally Invasive
Surgery</em> 26 (3): 97–107. <a href="https://doi.org/10.7602/jmis.2023.26.3.97" class="external-link">https://doi.org/10.7602/jmis.2023.26.3.97</a>.
</div>
<div id="ref-Carsey2014" class="csl-entry">
Carsey, Thomas M., and Jeffrey J. Harden. 2014. <em>Monte Carlo
Simulation and Resampling Methods for Social Science</em>. Thousand
Oaks: SAGE Publications.
</div>
<div id="ref-Cheng2016" class="csl-entry">
Cheng, Adam, David Kessler, Ralph Mackinnon, Todd P. Chang, Vinay M.
Nadkarni, Elizabeth A. Hunt, Jordan Duval-Arnould, et al. 2016.
<span>“Reporting Guidelines for Health Care Simulation Research:
Extensions to the CONSORT and STROBE Statements.”</span> <em>Advances in
Simulation</em> 1 (25): 1–13. <a href="https://doi.org/10.1186/s41077-016-0025-y" class="external-link">https://doi.org/10.1186/s41077-016-0025-y</a>.
</div>
<div id="ref-Chiou2023" class="csl-entry">
Chiou, Sy Han, Gongjun Xu, and Jun Yan Chiung-Yu Huang. 2023.
<span>“Regression Modeling for Recurrent Events Possibly with an
Informative Terminal Event Using r Package reReg.”</span> <em>Journal of
Statistical Software</em> 105 (5): 1–34. <a href="https://doi.org/10.18637/jss.v105.i05" class="external-link">https://doi.org/10.18637/jss.v105.i05</a>.
</div>
<div id="ref-Csardi2024" class="csl-entry">
Csárdi, Gábor, Tamás Nepusz, Vincent Traag, Szabolcs Horvát, Fabio
Zanini, Daniel Noom, and Kirill Müller. 2024. <em>Igraph: Network
Analysis and Visualization in r</em>. <a href="https://doi.org/10.5281/zenodo.7682609" class="external-link">https://doi.org/10.5281/zenodo.7682609</a>.
</div>
<div id="ref-Demarqui2024" class="csl-entry">
Demarqui, Fábio N. 2024. <span>“Survival Data Simulation with the r
Package Rsurv.”</span> arXiv:2406.01750v1.
</div>
<div id="ref-Denz2023" class="csl-entry">
Denz, Robin, Renate Klaaßen-Mielke, and Nina Timmesfeld. 2023. <span>“A
Comparison of Different Methods to Adjust Survival Curves for
Confounders.”</span> <em>Statistics in Medicine</em> 42 (10): 1461–79.
<a href="https://doi.org/10.1002/sim.9681" class="external-link">https://doi.org/10.1002/sim.9681</a>.
</div>
<div id="ref-Denz2023a" class="csl-entry">
Denz, Robin, Katharina Meiszl, Peter Ihle, Doris Oberle, Ursula
Drechsel-Bäuerle, Katrin Scholz, Ingo Meyer, and Nina Timmesfeld. 2025.
<span>“Impact of Record-Linkage Errors in Covid-19 Vaccine-Safety
Analyses Using German Health-Care Data: A Simulation Study.”</span>
<em>Communications in Statistics: Simulation and Computation</em>
InPrint. <a href="https://doi.org/10.1080/03610918.2025.2488942" class="external-link">https://doi.org/10.1080/03610918.2025.2488942</a>.
</div>
<div id="ref-Denz2025" class="csl-entry">
Denz, Robin, and Nina Timmesfeld. 2025. <span>“Simulating Complex
Crossectional and Longitudinal Data Using the simDAG r Package.”</span>
<em>arXiv Preprint</em>. <a href="https://doi.org/10.48550/arXiv.2506.01498" class="external-link">https://doi.org/10.48550/arXiv.2506.01498</a>.
</div>
<div id="ref-Fox2022" class="csl-entry">
Fox, Matthew P., Roch Nianogo, Jacqueline E. Rudolph, and Chanelle J.
Howe. 2022. <span>“Illustrating How to Simulate Data from Directed
Acyclic Graphs to Understand Epidemiologic Concepts.”</span>
<em>American Journal of Epidemiology</em> 191 (7): 1300–1306. <a href="https://doi.org/10.1093/aje/kwac041" class="external-link">https://doi.org/10.1093/aje/kwac041</a>.
</div>
<div id="ref-Goldfeld2020" class="csl-entry">
Goldfeld, Keith, and Jacob Wujciak-Jens. 2020. <span>“Simstudy:
Illuminating Research Methods Through Data Generation.”</span> <em>The
Journal of Open Source Software</em> 5 (54): 1–4. <a href="https://doi.org/10.21105/joss.02763" class="external-link">https://doi.org/10.21105/joss.02763</a>.
</div>
<div id="ref-Green2016" class="csl-entry">
Green, Peter, and Catriona J. MacLeod. 2016. <span>“Simr: An r Package
for Power Analysis of Generalized Linear Mixed Models by
Simulation.”</span> <em>Methods in Ecology and Evolution</em> 7 (4):
493–98. <a href="https://doi.org/10.1111/2041-210X.12504" class="external-link">https://doi.org/10.1111/2041-210X.12504</a>.
</div>
<div id="ref-Gruber2015" class="csl-entry">
Gruber, Susan, Roger W. Logan, Inmaculada Jarrín, Susana Monge, and
Miguel A. Hernán. 2015. <span>“Ensemble Learning of Inverse Probability
Weights for Marginal Structural Modeling in Large Observational
Datasets.”</span> <em>Statistics in Medicine</em> 34 (1): 106–17. <a href="https://doi.org/10.1002/sim.6322" class="external-link">https://doi.org/10.1002/sim.6322</a>.
</div>
<div id="ref-Hajj2023" class="csl-entry">
Hajj, Ghadi S. Al, Johan Pensar, and Geir K. Sandve. 2023.
<span>“DagSim: Combining DAG-Based Model Structure with Unconstrained
Data Types and Relations for Flexible, Transparent, and Modularized Data
Simulation.”</span> <em>PLoS One</em> 18 (4). <a href="https://doi.org/10.1371/journal.pone.0284443" class="external-link">https://doi.org/10.1371/journal.pone.0284443</a>.
</div>
<div id="ref-Haller2014" class="csl-entry">
Haller, Bernhard, and Kurt Ulm. 2014. <span>“Flexible Simulation of
Competing Risks Data Following Prespecified Subdistribution
Hazards.”</span> <em>Journal of Statistical Computation and
Simulation</em> 84 (12): 2557–76. <a href="https://doi.org/10.1080/00949655.2013.793345" class="external-link">https://doi.org/10.1080/00949655.2013.793345</a>.
</div>
<div id="ref-Hendry2013" class="csl-entry">
Hendry, David J. 2013. <span>“Data Generation for the Cox Proportional
Hazards Model with Time-Dependent Covariates: A Method for Medical
Researchers.”</span> <em>Statistics in Medicine</em> 33 (3): 436–54. <a href="https://doi.org/10.1002/sim.5945" class="external-link">https://doi.org/10.1002/sim.5945</a>.
</div>
<div id="ref-Hernan2020" class="csl-entry">
Hernán, Miguel A., and James M. Robins. 2020. <em>Causal Inference: What
If</em>. CRC Press.
</div>
<div id="ref-Huang2020" class="csl-entry">
Huang, Yunda, Yuanyuan Zhang, Zong Zhang, and Peter B. Gilbert. 2020.
<span>“Generating Survival Times Using Cox Proportional Hazards Models
with Cyclic and Piecewise Time-Varying Covariates.”</span>
<em>Statistics in Biosciences</em> 12: 324–39. <a href="https://doi.org/10.1007/s12561-020-09266-3" class="external-link">https://doi.org/10.1007/s12561-020-09266-3</a>.
</div>
<div id="ref-Imbens2020" class="csl-entry">
Imbens, Guido W. 2020. <span>“Potential Outcome and Directed Acyclic
Graph Approaches to Causality: Relevance for Empirical Practice in
Economics.”</span> <em>Journal of Economic Literature</em> 58 (4):
1129–79. <a href="https://doi.org/10.1257/jel.20191597" class="external-link">https://doi.org/10.1257/jel.20191597</a>.
</div>
<div id="ref-Jorgensen2022" class="csl-entry">
Jorgensen, Terrence D., Sunthud Pornprasertmanit, Alexander M.
Schoemann, and Yves Rosseel. 2022. <em>semTools: <span>U</span>seful
Tools for Structural Equation Modeling</em>. <a href="https://CRAN.R-project.org/package=semTools" class="external-link">https://CRAN.R-project.org/package=semTools</a>.
</div>
<div id="ref-Kahn1962" class="csl-entry">
Kahn, A. B. 1962. <span>“Topological Sorting of Large Networks.”</span>
<em>Communications of the ACM</em> 5 (11): 558–62. <a href="https://doi.org/10.1145/368996.369025" class="external-link">https://doi.org/10.1145/368996.369025</a>.
</div>
<div id="ref-Kimko2002" class="csl-entry">
Kimko, Hui C., and Stephen B. Duffull, eds. 2002. <em>Simulation for
Designing Clinical Trials: A Pharmacokinetic-Pharmacodynamic Modeling
Perspective</em>. New York: Marcel Dekker Inc.
</div>
<div id="ref-Kline2023" class="csl-entry">
Kline, Rex B. 2023. <em>Principles and Practice of Structural Equation
Modeling</em>. 5. New York: The Guilford Press.
</div>
<div id="ref-Mersmann2023" class="csl-entry">
Mersmann, Olaf. 2023. <em>Microbenchmark: Accurate Timing
Functions</em>. <a href="https://CRAN.R-project.org/package=microbenchmark" class="external-link">https://CRAN.R-project.org/package=microbenchmark</a>.
</div>
<div id="ref-Morina2017" class="csl-entry">
Moriña, D., and A. Navarro. 2017. <span>“Competing Risks Simulation with
the Survsim r Package.”</span> <em>Communications in Statistics:
Simulation and Computation</em> 46 (7): 5712–22. <a href="https://doi.org/10.18637/jss.v059.i02" class="external-link">https://doi.org/10.18637/jss.v059.i02</a>.
</div>
<div id="ref-Morris2019" class="csl-entry">
Morris, Tim P., Ian R. White, and Michael J. Crowther. 2019.
<span>“Using Simulation Studies to Evaluate Statistical Methods.”</span>
<em>Statistics in Medicine</em> 38 (11): 2074–2102. <a href="https://doi.org/10.1002/sim.8086" class="external-link">https://doi.org/10.1002/sim.8086</a>.
</div>
<div id="ref-Nance2024" class="csl-entry">
Nance, Nerissa, Maya L. Petersen, Mark J. van der Laan, and Laura B.
Balzer. 2024. <span>“The Causal Roadmap and Simulations to Improve the
Rigor and Reproducibility of Real-Data Applications.”</span>
<em>Epidemiology</em> 35 (6): 791–800. <a href="https://doi.org/10.1097/EDE.0000000000001773" class="external-link">https://doi.org/10.1097/EDE.0000000000001773</a>.
</div>
<div id="ref-Ngwa2022" class="csl-entry">
Ngwa, Julius S., Howard J. Cabral, Debbie M. Cheng, David R. Gagnon,
Michael P. LaValley, and L. Adrienne Cupples. 2022. <span>“Generating
Survival Times with Time-Varying Covariates Using the Lambert w
Function.”</span> <em>Communications in Statistics: Simulation and
Computation</em> 51 (1): 135–53. <a href="https://doi.org/10.1080/03610918.2019.1648822" class="external-link">https://doi.org/10.1080/03610918.2019.1648822</a>.
</div>
<div id="ref-Pearl1995" class="csl-entry">
Pearl, Judea. 1995. <span>“Causal Diagrams for Empirical
Research.”</span> <em>Biometrika</em> 82 (4): 669–88. <a href="https://doi.org/10.2307/2337329" class="external-link">https://doi.org/10.2307/2337329</a>.
</div>
<div id="ref-Pearl2009" class="csl-entry">
———. 2009. <em>Causality: Models, Reasoning and Inference</em>. 2nd ed.
Cambridge: Cambridge University Press.
</div>
<div id="ref-Pedersen2022" class="csl-entry">
Pedersen, Thomas Lin. 2022. <em>Ggforce: Accelerating Ggplot2</em>. <a href="https://CRAN.R-project.org/package=ggforce" class="external-link">https://CRAN.R-project.org/package=ggforce</a>.
</div>
<div id="ref-Pitts2024" class="csl-entry">
Pitts, Amy J., and Charlotte R. Fowler. 2024. <span>“Comparison of
Open-Source Software for Producing Directed Acyclic Graphs.”</span>
<em>Journal of Causal Inference</em> 12 (1): 1–10. <a href="https://doi.org/10.1515/jci-2023-0031" class="external-link">https://doi.org/10.1515/jci-2023-0031</a>.
</div>
<div id="ref-Pornprasertmanit2021" class="csl-entry">
Pornprasertmanit, Sunthud, Patrick Miller, Alexander Schoemann, and
Terrence D. Jorgensen. 2021. <em>Simsem: SIMulated Structural Equation
Modeling</em>. <a href="https://CRAN.R-project.org/package=simsem" class="external-link">https://CRAN.R-project.org/package=simsem</a>.
</div>
<div id="ref-RCT2024" class="csl-entry">
R Core Team. 2024. <span>“R: A Language and Environment for Statistical
Computing.”</span> R Foundation for Statistical Computing, Vienna,
Austria. <a href="https://www.r-project.org/" class="external-link">https://www.r-project.org/</a>.
</div>
<div id="ref-Reisach2021" class="csl-entry">
Reisach, Alexander G., Christof Seiler, and Sebastian Weichwald. 2021.
<span>“Beware of the Simulated DAG! Causal Discovery Benchmarks May Be
Easy to Game.”</span> In <em>Advances in Neural Information Processing
Systems 34 (NeurIPS 2021)</em>, edited by Marc’Aurelio Ranzato, Alina
Beygelzimer, Yann N. Dauphin, Percy Liang, and Jennifer Wortman Vaughan.
arXiv:2102.13647v3.
</div>
<div id="ref-Rosseel2012" class="csl-entry">
Rosseel, Yves. 2012. <span>“Lavaan: An r Package for Structural Equation
Modeling.”</span> <em>Journal of Statistical Software</em> 48 (2): 1–36.
<a href="https://doi.org/10.18637/jss.v048.i02" class="external-link">https://doi.org/10.18637/jss.v048.i02</a>.
</div>
<div id="ref-Sigal2016" class="csl-entry">
Sigal, Matthew J., and R. Philip Chalmers. 2016. <span>“Play It Again:
Teaching Statistics with Monte Carlo Simulation.”</span> <em>Journal of
Statistics Education</em> 24 (3): 136–56. <a href="https://doi.org/10.1080/10691898.2016.1246953" class="external-link">https://doi.org/10.1080/10691898.2016.1246953</a>.
</div>
<div id="ref-Sofrygin2017" class="csl-entry">
Sofrygin, Oleg, Mark J. van der Laan, and Romain Neugebauer. 2017.
<span>“Simcausal r Package: Conducting Transparent and Reproducible
Simulation Studies of Causal Effect Estimation with Complex Longitudinal
Data.”</span> <em>Journal of Statistical Software</em> 81 (2): 1–47. <a href="https://doi.org/10.18637/jss.v081.i02" class="external-link">https://doi.org/10.18637/jss.v081.i02</a>.
</div>
<div id="ref-Spirtes2000" class="csl-entry">
Spirtes, Peter, Clark Glymour, and Richard Scheines. 2000.
<em>Causation, Prediction, and Search</em>. 2. Cambridge: MIT Press.
</div>
<div id="ref-Spooner2021" class="csl-entry">
Spooner, Fiona, Jesse F. Abrams, Karyn Morrissey, Gavin Shaddick,
Michael Batty, Richard Milton, Adam Dennett, et al. 2021. <span>“A
Dynamic Microsimulation Model for Epidemics.”</span> <em>Social Science
&amp; Medicine</em> 291 (114461). <a href="https://doi.org/10.1016/j.socscimed.2021.114461" class="external-link">https://doi.org/10.1016/j.socscimed.2021.114461</a>.
</div>
<div id="ref-Tang2020" class="csl-entry">
Tang, Jiangjun, George Leu, and Hussein A. Abbass. 2020. <em>Simulation
and Computational Red Teaming for Problem Solving</em>. Hoboke: John
Wiley &amp; Sons.
</div>
<div id="ref-Templ2017" class="csl-entry">
Templ, Matthias, Bernhard Meindl, Alexander Kowarik, and Olivier
Dupriez. 2017. <span>“Simulation of Synthetic Complex Data: The r
Package simPop.”</span> <em>Journal of Statistical Software</em> 79
(10): 1–38. <a href="https://doi.org/10.18637/jss.v079.i10" class="external-link">https://doi.org/10.18637/jss.v079.i10</a>.
</div>
<div id="ref-Textor2016" class="csl-entry">
Textor, Johannes, Benito van der Zander, Mark S. Gilthorpe, Maciej
Liśkiewicz, and George T. H. Ellison. 2016. <span>“Robust Causal
Inference Using Directed Acyclic Graphs: The r Package Daggity.”</span>
<em>International Journal of Epidemiology</em> 45 (6): 1887–94. <a href="https://doi.org/10.1093/ije/dyw341" class="external-link">https://doi.org/10.1093/ije/dyw341</a>.
</div>
<div id="ref-Therneau2024" class="csl-entry">
Therneau, Terry M. 2024. <em>A Package for Survival Analysis in r</em>.
<a href="https://CRAN.R-project.org/package=survival" class="external-link">https://CRAN.R-project.org/package=survival</a>.
</div>
<div id="ref-Tutz2016" class="csl-entry">
Tutz, Gerhard, and Matthias Schmid. 2016. <em>Modeling Discrete
Time-to-Event Data</em>. Cham: Springer International Publishing
Switzerland.
</div>
<div id="ref-Wang2022" class="csl-entry">
Wang, Wenjie, Haoda Fu, Sy Han, and Jun Yan. 2022. <em>Reda: Recurrent
Event Data Analysis</em>.
</div>
<div id="ref-Wickham2016" class="csl-entry">
Wickham, Hadley. 2016. <em>Ggplot2: Elegant Graphics for Data
Analysis</em>. Springer-Verlag New York. <a href="https://ggplot2.tidyverse.org" class="external-link">https://ggplot2.tidyverse.org</a>.
</div>
<div id="ref-Wouk2019" class="csl-entry">
Wouk, Kathryn, Anna E. Bauer, and Nisha C. Gottfredson. 2019. <span>“How
to Implement Directed Acyclic Graphs to Reduce Bias in Addiction
Research.”</span> <em>Addictive Behaviors</em> 94: 109–16. <a href="https://doi.org/10.1016/j.addbeh.2018.09.032" class="external-link">https://doi.org/10.1016/j.addbeh.2018.09.032</a>.
</div>
<div id="ref-Zhang2018" class="csl-entry">
Zhang, Xiange. 2018. <span>“Application of Discrete Event Simulation in
Health Care: A Systematic Review.”</span> <em>BMC Health Services
Research</em> 18 (687). <a href="https://doi.org/10.1186/s12913-018-3456-4" class="external-link">https://doi.org/10.1186/s12913-018-3456-4</a>.
</div>
<div id="ref-Zhang2018a" class="csl-entry">
Zhang, Zhongzheng, Jaako Reinikainen, Kazeem Adedayo Adeleke, Marcel E.
Pieterse, and Catharina G. M. Groothuis-Oudshoorn. 2018.
<span>“Time-Varying Covariates and Coefficients in Cox Regression
Models.”</span> <em>Annals of Translational Medicine</em> 6 (7): 1–10.
<a href="https://doi.org/10.21037/atm.2018.02.12" class="external-link">https://doi.org/10.21037/atm.2018.02.12</a>.
</div>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Robin Denz, Katharina Meiszl.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.3.</p>
</div>

    </footer>
</div>





  </body>
</html>
