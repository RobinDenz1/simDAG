<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Simulating Data using a Discrete-Event Approach • simDAG</title>
<!-- favicons --><link rel="icon" type="image/png" sizes="96x96" href="../favicon-96x96.png">
<link rel="icon" type="”image/svg+xml”" href="../favicon.svg">
<link rel="apple-touch-icon" sizes="180x180" href="../apple-touch-icon.png">
<link rel="icon" sizes="any" href="../favicon.ico">
<link rel="manifest" href="../site.webmanifest">
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Simulating Data using a Discrete-Event Approach">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">simDAG</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.4.1.9000</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../articles/simDAG.html">Get started</a></li>
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/v_sim_from_dag.html">Simulating Data from a known DAG</a></li>
    <li><a class="dropdown-item" href="../articles/v_using_formulas.html">Specifying Formulas in a DAG</a></li>
    <li><a class="dropdown-item" href="../articles/v_custom_nodes.html">Specifying Custom Node Types in a DAG</a></li>
    <li><a class="dropdown-item" href="../articles/v_sim_discrete_time.html">Simulating Data using a Discrete-Time Approach</a></li>
    <li><a class="dropdown-item" href="../articles/v_sim_discrete_event.html">Simulating Data using a Discrete-Event Approach</a></li>
    <li><a class="dropdown-item" href="../articles/v_covid_example.html">Simulating Covid-19 Vaccine Data using a Discrete-Time Simulation</a></li>
    <li><a class="dropdown-item" href="../articles/v_sim_networks.html">Simulating Data from a DAG with Network Dependencies</a></li>
    <li><a class="dropdown-item" href="../articles/v_cookbook.html">simDAG Cookbook</a></li>
  </ul>
</li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changelog</a></li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/RobinDenz1/siMDAG/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="../logo.png" class="logo" alt=""><h1>Simulating Data using a Discrete-Event Approach</h1>
                        <h4 data-toc-skip class="author">Robin Denz</h4>
            
      
      <small class="dont-index">Source: <a href="https://github.com/RobinDenz1/siMDAG/blob/main/vignettes/v_sim_discrete_event.Rmd" class="external-link"><code>vignettes/v_sim_discrete_event.Rmd</code></a></small>
      <div class="d-none name"><code>v_sim_discrete_event.Rmd</code></div>
    </div>

    
    
<div class="section level2">
<h2 id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<p>In this small vignette, we introduce the
<code><a href="../reference/sim_discrete_event.html">sim_discrete_event()</a></code> function, which can be used to
generate complex longitudinal data with a continuous time scale based on
the discrete-event simulation (DES) framework <span class="citation">(Banks et al. 2014)</span>. It is very similar to the
<code><a href="../reference/sim_discrete_time.html">sim_discrete_time()</a></code> function in spirit, but relies on a
completely different algorithm to generate the data. This algorithm is
usually much faster than the discrete-time approach, while also being
more precise. The drawback is some added complexity and a little less
flexibility. For example, in <code><a href="../reference/sim_discrete_event.html">sim_discrete_event()</a></code>,
continuous, categorical or count-based time-dependent variables are
currently not supported. Only binary variables added using the
<code>"next_time"</code> node type may be used.</p>
<p>The goal of the <code><a href="../reference/sim_discrete_event.html">sim_discrete_event()</a></code> function is not to
provide a general framework for DES. Multiple other R packages, such as
<code>simmer</code> <span class="citation">(Ucar, Smeets, and Azcorra
2019; Degeling et al. 2025)</span> and <code>DES</code> <span class="citation">(Matloff 2017)</span>, as well as software packages
outside R have been developed for that purpose and are much more useful
in this regard. Instead, the aim of this function is to provide a
specific, but fairly general, DES model that may be used to generate
data from DAG based description of the data generation process (DGP). In
other words: if you want to perform a classic DES with interacting
agents using a classic simulation modeling approach, this is probably
not the right package for you. If you want to generate complex
time-dependent data based on a stochastic model, you have come to the
right place.</p>
<p>Throughout the vignette, we assume that the reader is already
familiar with the <code>simDAG</code> syntax. If this is not the case,
we recommend consulting the introductory vignette or the main paper
associated with this package first <span class="citation">(Denz and
Timmesfeld 2025)</span>.</p>
</div>
<div class="section level2">
<h2 id="what-is-discrete-event-simulation-and-why-use-it">What is Discrete-Event Simulation and Why Use it?<a class="anchor" aria-label="anchor" href="#what-is-discrete-event-simulation-and-why-use-it"></a>
</h2>
<p>In a discrete-event simulation (DES), the data is generated according
to a statistical model, which describes a system as a sequence of
distinct (or discrete) events that happen in continuous time and may
influence each other. Any DES starts with the generation of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
individuals at
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">t = 0</annotation></semantics></math>
that have some characteristics, such as values of multiple covariates.
The full description of all individuals is considered to be the
<em>state</em> of the simulation here. This <em>state</em> only ever
changes when some <em>event</em> occurs. A simple example for an
<em>event</em> would be a variable changing its value from
<code>FALSE</code> to <code>TRUE</code> or vice versa. If such an event
occurs, the time of the simulation is advanced to the timing of this
event. The state of the simulation is then updated to reflect the
changes brought on by this event. Next, the time until the next event is
generated and the process is repeated until some condition is met. The
flowchart below gives a generalized description of a DES as considered
here.</p>
<div class="figure" style="text-align: center">
<img src="images_v_sim_discrete_event/flow_chart.png" class="r-plt" alt="A generalized flow-chart of the discrete-event simulation approach" width="500"><p class="caption">
A generalized flow-chart of the discrete-event simulation approach
</p>
</div>
<p>This approach has many names and usages in the literature. In physics
and chemistry, the particular variant discussed here is known as the
Gillespie algorithm <span class="citation">(Gillespie 1976,
1977)</span>, or the <em>next reaction</em> or <em>first reaction</em>
method <span class="citation">(Anderson 2007)</span>. Formally, it is a
mathematically exact method to generate random trajectories from a known
(not necessarily Markovian) stochastic process <span class="citation">(Masuda and Rocha 2018)</span>. Formal descriptions of
the algorithm are given in the cited literature. The most general
description of the DES (or Gillespie algorithm) implemented in
<code><a href="../reference/sim_discrete_event.html">sim_discrete_event()</a></code> is as follows for every
individual:</p>
<ul>
<li><ol style="list-style-type: decimal">
<li>At
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">t = 0</annotation></semantics></math>,
initialize the baseline covariate values and set all
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>
time-dependent covariates to <code>FALSE</code>.</li>
</ol></li>
<li><ol start="2" style="list-style-type: decimal">
<li>For each of the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>
considered time-dependent variables, generate the time until the next
change based on some distributional assumptions (possibly dependent on
any variables contained in the current state)</li>
</ol></li>
<li><ol start="3" style="list-style-type: decimal">
<li>Advance the simulation to the minimum of the values drawn in step
(2).</li>
</ol></li>
<li><ol start="4" style="list-style-type: decimal">
<li>Update the value of the time-dependent variable that generated this
event.</li>
</ol></li>
<li><ol start="5" style="list-style-type: decimal">
<li>Go back to step (2) and repeat until either some condition is met or
no changes are possibly anymore (may happen is every time-dependent
variable has reached a terminal state).</li>
</ol></li>
</ul>
<p>The <code><a href="../reference/sim_discrete_event.html">sim_discrete_event()</a></code> directly implements this
workflow, assuming that individuals (rows in the <code>data</code>) do
not influence each other. A data set at
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">t = 0</annotation></semantics></math>
is either simulated using the <code><a href="../reference/sim_from_DAG.html">sim_from_dag()</a></code> function or
supplied directly by the user (using the <code>t0_data</code> argument).
This data set is then updated according to the time-dependent nodes
added to the <code>dag</code> using <code><a href="../reference/node.html">node_td()</a></code> calls. After
each update, the state of the simulation is saved, so that the final
output is a single dataset in the start-stop format. Below we give a
short example on how this works in practice. We use a similar example to
the one used in the discrete-time simulation vignette, to allow direct
comparisons with the discrete-time approach.</p>
</div>
<div class="section level2">
<h2 id="defining-the-dag">Defining the DAG<a class="anchor" aria-label="anchor" href="#defining-the-dag"></a>
</h2>
<p>As for the other simulation functions in this package, the definition
of a DAG is the first required step. Any amount of time-independent
variables specified using standard <code><a href="../reference/node.html">node()</a></code> function calls
are supported. Time-dependent nodes should be specified using the
<code><a href="../reference/node.html">node_td()</a></code> function instead. Importantly, for
<code><a href="../reference/sim_discrete_event.html">sim_discrete_event()</a></code>, only time-dependent nodes of type
<code>"next_time"</code> are supported. For more examples and guidance
on how to generally define a DAG, please consult the other vignettes and
documentation pages of this package.</p>
</div>
<div class="section level2">
<h2 id="a-single-time-dependent-variable">A single time-dependent variable<a class="anchor" aria-label="anchor" href="#a-single-time-dependent-variable"></a>
</h2>
<p>For illustrative purposes, we will start with a small comparison of
the discrete-time simulation approach and the discrete-event approach.
Consider that we are interested in simulating the time until
<code>death</code> for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
individuals. Lets ignore the influence of any other variables for the
moment and just consider <code>death</code> by itself. Suppose that
<code>death</code> has a fixed probability of 0.01 to occur during each
time-unit.</p>
<div class="section level3">
<h3 id="discrete-time-approach">Discrete-Time approach<a class="anchor" aria-label="anchor" href="#discrete-time-approach"></a>
</h3>
<p>In a discrete-time simulation, we would simply draw Bernoulli trials
with a probability of 0.01 at
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>.
If the trial returns a 1, we are done and save the time. If it returns a
0, we increase
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>
by one and repeat until we are finished. This can be done using the
<code><a href="../reference/sim_discrete_time.html">sim_discrete_time()</a></code> function using the following code:</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/RobinDenz1/simDAG" class="external-link">simDAG</a></span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://r-datatable.com" class="external-link">data.table</a></span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">1234</span><span class="op">)</span></span>
<span></span>
<span><span class="va">dag_dts</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/empty_dag.html">empty_dag</a></span><span class="op">(</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/node.html">node_td</a></span><span class="op">(</span><span class="st">"death"</span>, type<span class="op">=</span><span class="st">"time_to_event"</span>, prob_fun<span class="op">=</span><span class="fl">0.01</span>, event_duration<span class="op">=</span><span class="cn">Inf</span><span class="op">)</span></span>
<span></span>
<span><span class="va">simDTS</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/sim_discrete_time.html">sim_discrete_time</a></span><span class="op">(</span><span class="va">dag_dts</span>, n_sim<span class="op">=</span><span class="fl">10</span>, max_t<span class="op">=</span><span class="fl">10000000</span>,</span>
<span>                            break_if<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/all.html" class="external-link">all</a></span><span class="op">(</span><span class="va">data</span><span class="op">$</span><span class="va">death_event</span><span class="op">==</span><span class="cn">TRUE</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">simDTS</span><span class="op">$</span><span class="va">data</span><span class="op">)</span></span>
<span><span class="co">#&gt;      .id death_event death_time</span></span>
<span><span class="co">#&gt;    &lt;int&gt;      &lt;lgcl&gt;      &lt;int&gt;</span></span>
<span><span class="co">#&gt; 1:     1        TRUE         98</span></span>
<span><span class="co">#&gt; 2:     2        TRUE         20</span></span>
<span><span class="co">#&gt; 3:     3        TRUE         13</span></span>
<span><span class="co">#&gt; 4:     4        TRUE        112</span></span>
<span><span class="co">#&gt; 5:     5        TRUE         36</span></span>
<span><span class="co">#&gt; 6:     6        TRUE         54</span></span></code></pre></div>
<p>Here, we set the <code>max_t</code> argument to a very large number
and told the function to stop once everyone has died using the
<code>break_if</code> argument. This approach works well, but it is also
incredibly inefficient in this simple example. Since <code>death</code>
has a constant probability of 0.01, we could also simply sample time
values from an exponential distribution with <code>rate=0.01</code>.
This is exactly what will be exploited in the DES approach.</p>
</div>
<div class="section level3">
<h3 id="discrete-event-approach">Discrete-Event approach<a class="anchor" aria-label="anchor" href="#discrete-event-approach"></a>
</h3>
<p>Since we are only interested in a single variable, which has a
terminal state (once you are dead, there is no going back), we only need
one time-jump and thus only one iteration in the DES approach, while we
needed potentially hundreds or thousands in the discrete-time approach.
The following code may be used to implement this:</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">dag_des</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/empty_dag.html">empty_dag</a></span><span class="op">(</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/node.html">node_td</a></span><span class="op">(</span><span class="st">"death"</span>, type<span class="op">=</span><span class="st">"next_time"</span>, prob_fun<span class="op">=</span><span class="fl">0.01</span>,</span>
<span>          event_duration<span class="op">=</span><span class="cn">Inf</span><span class="op">)</span></span>
<span></span>
<span><span class="va">simDES</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/sim_discrete_event.html">sim_discrete_event</a></span><span class="op">(</span><span class="va">dag_des</span>, n_sim<span class="op">=</span><span class="fl">10</span>, target_event<span class="op">=</span><span class="st">"death"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">simDES</span><span class="op">)</span></span>
<span><span class="co">#&gt; Key: &lt;.id, start&gt;</span></span>
<span><span class="co">#&gt;      .id    start     stop  death</span></span>
<span><span class="co">#&gt;    &lt;int&gt;    &lt;num&gt;    &lt;num&gt; &lt;lgcl&gt;</span></span>
<span><span class="co">#&gt; 1:     1   0.0000 102.2426   TRUE</span></span>
<span><span class="co">#&gt; 2:     1 102.2426      Inf  FALSE</span></span>
<span><span class="co">#&gt; 3:     2   0.0000 140.1487   TRUE</span></span>
<span><span class="co">#&gt; 4:     2 140.1487      Inf  FALSE</span></span>
<span><span class="co">#&gt; 5:     3   0.0000 104.5491   TRUE</span></span>
<span><span class="co">#&gt; 6:     3 104.5491      Inf  FALSE</span></span></code></pre></div>
<p>There are some differences to the output of the
<code><a href="../reference/sim_discrete_time.html">sim_discrete_time()</a></code> function. First, because we are using
the DES approach, the time is continuous and not discrete. Secondly, the
output is naturally in the start-stop format, because there would be no
other useful way to represent it. Because there is only one change, each
individual only has one row in the dataset and it is thus still almost
equivalent to the output of the discrete-time approach.</p>
<p>In this example the <code><a href="../reference/sim_discrete_event.html">sim_discrete_event()</a></code> output is
exactly equal to just calling <code>rexp(10, rate=0.01)</code>, while
the <code><a href="../reference/sim_discrete_time.html">sim_discrete_time()</a></code> output is a discrete-time
approximation to it.</p>
</div>
</div>
<div class="section level2">
<h2 id="two-interrelated-time-dependent-variables">Two interrelated time-dependent variables<a class="anchor" aria-label="anchor" href="#two-interrelated-time-dependent-variables"></a>
</h2>
<p>We will now make the example a little more complex, by including a
time-dependent variable which directly influences the probability of
death. Consider the following code:</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">prob_death</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">data</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fl">0.001</span> <span class="op">*</span> <span class="fl">0.8</span><span class="op">^</span><span class="op">(</span><span class="va">data</span><span class="op">$</span><span class="va">treatment</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="va">dag</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/empty_dag.html">empty_dag</a></span><span class="op">(</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/node.html">node_td</a></span><span class="op">(</span><span class="st">"treatment"</span>, type<span class="op">=</span><span class="st">"next_time"</span>, prob_fun<span class="op">=</span><span class="fl">0.01</span>,</span>
<span>          event_duration<span class="op">=</span><span class="fl">100</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/node.html">node_td</a></span><span class="op">(</span><span class="st">"death"</span>, type<span class="op">=</span><span class="st">"next_time"</span>, prob_fun<span class="op">=</span><span class="va">prob_death</span>,</span>
<span>          event_duration<span class="op">=</span><span class="cn">Inf</span><span class="op">)</span></span>
<span></span>
<span><span class="va">sim</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/sim_discrete_event.html">sim_discrete_event</a></span><span class="op">(</span><span class="va">dag</span>, n_sim<span class="op">=</span><span class="fl">10</span>, remove_if<span class="op">=</span><span class="va">death</span><span class="op">==</span><span class="cn">TRUE</span>,</span>
<span>                          target_event<span class="op">=</span><span class="st">"death"</span><span class="op">)</span></span></code></pre></div>
<p>Here, we specified two time-dependent nodes of type
<code>"next_time"</code>. The first one denotes the
<code>treatment</code>, which has a fixed probability of being given to
a person. It then has an effect for 100 time units, after which the
variable turns back to <code>FALSE</code>. Once it is <code>FALSE</code>
again, it may be given to the same person again immediatly, with a
probability of 0.01. The probability of the <code>death</code> of a
person is now no longer fixed, but a function of the
<code>treatment</code> status. The general probability of death is 0.001
per time unit, but it is reduced by a factor of 0.8 if the
<code>treatment</code> is currently in effect.</p>
<p>Importantly, in this simulation we had to use one of the three
arguments that define an end of the simulation: <code>max_t</code>,
<code>remove_if</code> or <code>break_if</code>. We specified
<code>remove_if</code>, so that all individuals who die are no longer
part of the simulation. Alternatively, we could have gotten a similar
effect using the <code>break_if</code> argument, or limit the amount of
time the simulation may run with <code>max_t</code>. The latter is not
very useful here, because we are interested in the time of death. If we
hadn’t used any of these arguments, the simulation would be updated
exactly <code>1000</code> times per person (default value of the
<code>max_iter</code> argument), because <code>treatment</code> does not
have a terminal state (both its <code>event_duration</code> and
<code>immunity_duration</code> are finite). The
<code>target_event</code> argument is only used to make the output a
little prettier.</p>
<p>The generated data for the first individual look like this:</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">sim</span>, <span class="fl">9</span><span class="op">)</span></span>
<span><span class="co">#&gt; Key: &lt;.id, start&gt;</span></span>
<span><span class="co">#&gt;      .id     start      stop treatment  death</span></span>
<span><span class="co">#&gt;    &lt;int&gt;     &lt;num&gt;     &lt;num&gt;    &lt;lgcl&gt; &lt;lgcl&gt;</span></span>
<span><span class="co">#&gt; 1:     1   0.00000  15.65804     FALSE  FALSE</span></span>
<span><span class="co">#&gt; 2:     1  15.65804 115.65804      TRUE  FALSE</span></span>
<span><span class="co">#&gt; 3:     1 115.65804 168.33340     FALSE  FALSE</span></span>
<span><span class="co">#&gt; 4:     1 168.33340 268.33340      TRUE  FALSE</span></span>
<span><span class="co">#&gt; 5:     1 268.33340 420.23653     FALSE  FALSE</span></span>
<span><span class="co">#&gt; 6:     1 420.23653 520.23653      TRUE  FALSE</span></span>
<span><span class="co">#&gt; 7:     1 520.23653 606.02564     FALSE  FALSE</span></span>
<span><span class="co">#&gt; 8:     1 606.02564 706.02564      TRUE  FALSE</span></span>
<span><span class="co">#&gt; 9:     1 706.02564 860.85932     FALSE   TRUE</span></span></code></pre></div>
<p>As can be seen, the treatment keeps switching between
<code>TRUE</code> and <code>FALSE</code> until the <code>death</code> is
eventually reached. If we increased <code>n_sim</code> and fit a Cox
proportional hazards regression model with the time-to
<code>death</code> as the endpoint and the <code>treatment</code> as
covariate, we would be able to recover the 0.8 as the hazard ratio for
the treatment. The same strategy could of course be used for any amount
of time-varying variables.</p>
<p>Above, we used the <code>prob_fun</code> argument to specify the
probabilities, so that the connection to the
<code><a href="../reference/sim_discrete_time.html">sim_discrete_time()</a></code> approach is more clear. Alternatively,
we could also use the much more convenient <code>formula</code>
interface:</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">dag</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/empty_dag.html">empty_dag</a></span><span class="op">(</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/node.html">node_td</a></span><span class="op">(</span><span class="st">"treatment"</span>, type<span class="op">=</span><span class="st">"next_time"</span>, prob_fun<span class="op">=</span><span class="fl">0.01</span>,</span>
<span>          event_duration<span class="op">=</span><span class="fl">100</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/node.html">node_td</a></span><span class="op">(</span><span class="st">"death"</span>, type<span class="op">=</span><span class="st">"next_time"</span>,</span>
<span>          formula<span class="op">=</span> <span class="op">~</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="fl">0.001</span><span class="op">)</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="fl">0.8</span><span class="op">)</span><span class="op">*</span><span class="va">treatment</span>, link<span class="op">=</span><span class="st">"log"</span>,</span>
<span>          event_duration<span class="op">=</span><span class="cn">Inf</span><span class="op">)</span></span>
<span></span>
<span><span class="va">sim</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/sim_discrete_event.html">sim_discrete_event</a></span><span class="op">(</span><span class="va">dag</span>, n_sim<span class="op">=</span><span class="fl">10</span>, remove_if<span class="op">=</span><span class="va">death</span><span class="op">==</span><span class="cn">TRUE</span>,</span>
<span>                          target_event<span class="op">=</span><span class="st">"death"</span><span class="op">)</span></span></code></pre></div>
<p>Here, we simply specified the log-binomial model as one would when
specifying a simple binomial regression model (see
<code><a href="../reference/node_binomial.html">?node_binomial</a></code>). Note that although the results are
theoretically equivalent when the same seed is used, they are not
identical in practice, due to small floating point errors. This should
not be an issue in practice.</p>
</div>
<div class="section level2">
<h2 id="some-things-to-consider">Some things to consider<a class="anchor" aria-label="anchor" href="#some-things-to-consider"></a>
</h2>
<div class="section level3">
<h3 id="time-dependent-probabilities-and-effects">Time-Dependent probabilities and effects<a class="anchor" aria-label="anchor" href="#time-dependent-probabilities-and-effects"></a>
</h3>
<p>By default, the time until the next event is generated using a random
draw from an exponential distribution. This approach, however, assumes
that the probability of occurrence is independent of the time. We can
relax this assumption by using the <code>redraw_at_t</code> argument.
This argument allows users to specify points in time at which the time
to the next event should be re-drawn. By additionally making the
probability function supplied to a time-dependent node time-specific, we
can then use a piecewise-constant probability instead. Consider the
following code:</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">prob_death</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">data</span><span class="op">)</span> <span class="op">{</span></span>
<span>  </span>
<span>  <span class="va">base_p</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdatatable.gitlab.io/data.table/reference/fifelse.html" class="external-link">fifelse</a></span><span class="op">(</span><span class="va">data</span><span class="op">$</span><span class="va">.time</span> <span class="op">&gt;</span> <span class="fl">300</span>, <span class="fl">0.005</span>, <span class="fl">0.001</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="va">base_p</span> <span class="op">*</span> <span class="fl">0.8</span><span class="op">^</span><span class="op">(</span><span class="va">data</span><span class="op">$</span><span class="va">treatment</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="va">dag</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/empty_dag.html">empty_dag</a></span><span class="op">(</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/node.html">node_td</a></span><span class="op">(</span><span class="st">"treatment"</span>, type<span class="op">=</span><span class="st">"next_time"</span>, prob_fun<span class="op">=</span><span class="fl">0.01</span>,</span>
<span>          event_duration<span class="op">=</span><span class="fl">100</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/node.html">node_td</a></span><span class="op">(</span><span class="st">"death"</span>, type<span class="op">=</span><span class="st">"next_time"</span>, prob_fun<span class="op">=</span><span class="va">prob_death</span>,</span>
<span>          event_duration<span class="op">=</span><span class="cn">Inf</span><span class="op">)</span></span>
<span></span>
<span><span class="va">sim</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/sim_discrete_event.html">sim_discrete_event</a></span><span class="op">(</span><span class="va">dag</span>, n_sim<span class="op">=</span><span class="fl">10</span>, remove_if<span class="op">=</span><span class="va">death</span><span class="op">==</span><span class="cn">TRUE</span>,</span>
<span>                          target_event<span class="op">=</span><span class="st">"death"</span>, redraw_at_t<span class="op">=</span><span class="fl">300</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">sim</span><span class="op">)</span></span>
<span><span class="co">#&gt; Key: &lt;.id, start&gt;</span></span>
<span><span class="co">#&gt;      .id     start      stop treatment  death</span></span>
<span><span class="co">#&gt;    &lt;int&gt;     &lt;num&gt;     &lt;num&gt;    &lt;lgcl&gt; &lt;lgcl&gt;</span></span>
<span><span class="co">#&gt; 1:     1   0.00000  32.13286     FALSE  FALSE</span></span>
<span><span class="co">#&gt; 2:     1  32.13286 132.13286      TRUE  FALSE</span></span>
<span><span class="co">#&gt; 3:     1 132.13286 300.00000     FALSE  FALSE</span></span>
<span><span class="co">#&gt; 4:     1 300.00000 440.08265     FALSE  FALSE</span></span>
<span><span class="co">#&gt; 5:     1 440.08265 540.08265      TRUE  FALSE</span></span>
<span><span class="co">#&gt; 6:     1 540.08265 648.71324     FALSE  FALSE</span></span></code></pre></div>
<p>In this code, the baseline probability is 0.001 until
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mn>300</mn></mrow><annotation encoding="application/x-tex">t = 300</annotation></semantics></math>
and then increases to 0.005. It is not sufficient to only define the
probability function this way, because then there would be no way for
the simulation itself to know that the event durations have to be
re-drawn. For example, lets say the <code>death</code> time drawn at
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">t = 0</annotation></semantics></math>
for some person is 678 and assume that <code>treatment</code> has no
effect for this individual. This time was generated using a rate of
0.001, so only the time until 300 is valid. At
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mn>300</mn></mrow><annotation encoding="application/x-tex">t = 300</annotation></semantics></math>,
we therefore have to re-draw another time from a truncated exponential
distribution with the new rate of 0.005 (truncated at 300).</p>
<p>The same strategy could be used to define piecewise-constant
time-dependent effects as well. One would only need to adjust the
<code>prob_death()</code> function so that it has a different factor for
<code>treatment</code> depending on the time. Using continuously
changing probabilities is more difficult, but possible. If for example,
we assume that the baseline probability follows a Weibull distribution,
we could use the same algorithm that is used in the
<code><a href="../reference/node_cox.html">node_cox()</a></code> function to draw the event times instead. This
could be done by changing the <code>distr_fun</code> argument inside the
relevant <code><a href="../reference/node.html">node_td()</a></code> call appropriately.</p>
</div>
<div class="section level3">
<h3 id="categorical-count-continuous-variables">Categorical / Count / Continuous variables<a class="anchor" aria-label="anchor" href="#categorical-count-continuous-variables"></a>
</h3>
<p>With the current implementation, only time-dependent variables are
supported. There is no way to easily integrate time-dependent
categorical, count or continuous variables instead. If these are
required, users may need to use the <code><a href="../reference/sim_discrete_time.html">sim_discrete_time()</a></code>
function.</p>
</div>
<div class="section level3">
<h3 id="ties-in-event-times">Ties in event times<a class="anchor" aria-label="anchor" href="#ties-in-event-times"></a>
</h3>
<p>Conceptually, no complications arise from multiple events happening
at the same exact time, which we will call <em>ties</em> from here on.
If ties occur, the algorithm should simply update the respective
variables at the same time, generating only one new row for the
start-stop dataset. The simulation may then proceed as usual.
Computationally, it does make a difference though. The
<code><a href="../reference/sim_discrete_event.html">sim_discrete_event()</a></code> function internally uses a mix of a
long- and wide-format dataset. Updating this dataset is fast and
efficient if it can be assumed that only one event occurs, but somewhat
more involved if we have to allow ties. This is where the
<code>allow_ties</code> argument comes in.</p>
<p>By default, the time until the next event is drawn from a (truncated)
exponential distribution and thus truly continuous. In this case, the
likelihood that two generated event times, lets say for variable
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>
are exactly equal are astronomically small. For all intents and
purposes, we may ignore this possibility. The <code>allow_ties</code>
argument is therefore set to <code>FALSE</code> by default, allowing
computations to be a lot faster. If, however, the user supplies a custom
function that generates integer based times, this argument needs to be
set to <code>TRUE</code> (otherwise an error will be returned).</p>
<p>For example, consider the following code:</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">integer_rtexp</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">n</span>, <span class="va">rate</span>, <span class="va">l</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/Round.html" class="external-link">ceiling</a></span><span class="op">(</span><span class="fu"><a href="../reference/rtexp.html">rtexp</a></span><span class="op">(</span>n<span class="op">=</span><span class="va">n</span>, rate<span class="op">=</span><span class="va">rate</span>, l<span class="op">=</span><span class="va">l</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="va">dag</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/empty_dag.html">empty_dag</a></span><span class="op">(</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/node.html">node_td</a></span><span class="op">(</span><span class="st">"treatment"</span>, type<span class="op">=</span><span class="st">"next_time"</span>, prob_fun<span class="op">=</span><span class="fl">0.01</span>,</span>
<span>          event_duration<span class="op">=</span><span class="fl">100</span>, distr_fun<span class="op">=</span><span class="va">integer_rtexp</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/node.html">node_td</a></span><span class="op">(</span><span class="st">"death"</span>, type<span class="op">=</span><span class="st">"next_time"</span>,</span>
<span>          formula<span class="op">=</span> <span class="op">~</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="fl">0.001</span><span class="op">)</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="fl">0.8</span><span class="op">)</span><span class="op">*</span><span class="va">treatment</span>, link<span class="op">=</span><span class="st">"log"</span>,</span>
<span>          event_duration<span class="op">=</span><span class="cn">Inf</span>, distr_fun<span class="op">=</span><span class="va">integer_rtexp</span><span class="op">)</span></span>
<span></span>
<span><span class="va">sim</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/sim_discrete_event.html">sim_discrete_event</a></span><span class="op">(</span><span class="va">dag</span>, n_sim<span class="op">=</span><span class="fl">1000</span>, remove_if<span class="op">=</span><span class="va">death</span><span class="op">==</span><span class="cn">TRUE</span>,</span>
<span>                          target_event<span class="op">=</span><span class="st">"death"</span>, allow_ties<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<p>Here, we use an artificially discretized version of the truncated
exponential distribution to generate the time until the next change.
This may lead to ties, so we need to set <code>allow_ties=TRUE</code>.
Note that for sample sizes below 10000, the computational differences
are very small. Only with large <code>n_sim</code> does the difference
between <code>allow_ties=TRUE</code> and <code>allow_ties=FALSE</code>
become more noticeable.</p>
</div>
</div>
<div class="section level2">
<h2 id="discussion">Discussion<a class="anchor" aria-label="anchor" href="#discussion"></a>
</h2>
<p>The <code><a href="../reference/sim_discrete_event.html">sim_discrete_event()</a></code> function has multiple
advantages over its sibling, the <code><a href="../reference/sim_discrete_time.html">sim_discrete_time()</a></code>
function. As a general rule, if a DGP can be described in terms of only
binary time-dependent variables (plus an arbitrary amount of
time-constant variable) it should be possibly to use both functions. In
this case, the <code><a href="../reference/sim_discrete_event.html">sim_discrete_event()</a></code> approach is often much
faster and more efficient and thus preferable. If more complex data is
required, the discrete-time simulation approach offers more flexibility,
while also being easier to understand, at the cost of computational
time.</p>
</div>
<div class="section level2">
<h2 class="unnumbered" id="references">References<a class="anchor" aria-label="anchor" href="#references"></a>
</h2>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-Anderson2007" class="csl-entry">
Anderson, David F. 2007. <span>“A Modified Next Reaction Method for
Simulating Chemical Systems with Time Dependent Propensities and
Delays.”</span> <em>The Journal of Chemical Physics</em> 127 (21).
</div>
<div id="ref-Banks2014" class="csl-entry">
Banks, Jerry, John S. Carson II, Barry L. Nelson, and David M. Nicol.
2014. <em>Discrete-Event System Simulation</em>. Vol. 5. Edinburgh Gate:
Pearson Education Limited.
</div>
<div id="ref-Degeling2025" class="csl-entry">
Degeling, Koen, Jonathan Karnon, Michiel van de Ven, alan Brennan, and
Hendrik Koffijberg. 2025. <span>“Discrete Event Simulation in r Using
the ’Simmer’ Package for Health Economic Modelling: A Tutorial and
Illustration in Colon Cancer.”</span> <em>Applied Health Economics and
Health Policy</em> 23: 961–75.
</div>
<div id="ref-Denz2025" class="csl-entry">
Denz, Robin, and Nina Timmesfeld. 2025. <span>“Simulating Complex
Crossectional and Longitudinal Data Using the simDAG r Package.”</span>
<em>arXiv Preprint</em>. <a href="https://doi.org/10.48550/arXiv.2506.01498" class="external-link">https://doi.org/10.48550/arXiv.2506.01498</a>.
</div>
<div id="ref-Gillespie1976" class="csl-entry">
Gillespie, Daniel T. 1976. <span>“A General Method for Numerically
Simulating the Stochastic Time Evolution of Coupled Chemical
Reactions.”</span> <em>Journal of Computational Physics</em> 22 (4):
403–34.
</div>
<div id="ref-Gillespie1977" class="csl-entry">
———. 1977. <span>“Exact Stochastic Simulation of Coupled Chemical
Reactions.”</span> <em>The Journal of Physical Chemistry</em> 81 (25):
2340–61.
</div>
<div id="ref-Masuda2018" class="csl-entry">
Masuda, Naoki, and Luis E. C. Rocha. 2018. <span>“A Gillespie Algorithm
for Non-Markovian Stochastic Processes.”</span> <em>SIAM Review</em> 60
(1): 95–115.
</div>
<div id="ref-Matloff2017" class="csl-entry">
Matloff, Norm. 2017. <em>DES: Discrete Event Simulation</em>. <a href="https://doi.org/10.32614/CRAN.package.DES" class="external-link">https://doi.org/10.32614/CRAN.package.DES</a>.
</div>
<div id="ref-Ucar2019" class="csl-entry">
Ucar, Iñaki, Bart Smeets, and Arturo Azcorra. 2019. <span>“Simmer:
Discrete-Event Simulation for r.”</span> <em>Journal of Statistical
Software</em> 90 (2). <a href="https://doi.org/10.18637/jss.v090.i02" class="external-link">https://doi.org/10.18637/jss.v090.i02</a>.
</div>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Robin Denz, Katharina Meiszl.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.2.0.</p>
</div>

    </footer>
</div>





  </body>
</html>
