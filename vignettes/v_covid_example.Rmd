---
title: "Simulating Covid-19 Vaccine Data using a Discrete-Time Simulation"
output: rmarkdown::html_vignette
author: "Robin Denz"
vignette: >
  %\VignetteIndexEntry{Simulating Covid-19 Vaccine Data using a Discrete-Time Simulation}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include=FALSE}
knitr::opts_chunk$set(
  collapse=TRUE,
  comment="#>"
)
```

# Introduction

This vignette contains an in-depth example on how to use the `sim_discrete_time` function to generate complex time-to-event data. Unlike the other vignettes, we will not rely on a simple example here. Instead, our aim is to generate realistic data about the Covid-19 pandemic. In particular, we are interested in generating a longitudinal data set containing Covid-19 infections, vaccines and adverse side effects of those vaccines. The aim was to create a data set that is reasonably close to real data, including measurement problems as described below. This data generation algorithm was then used to identify a suitable data analysis strategy for the real data. We only describe the data generation part here to give a detailed example on how the `sim_discrete_time` function may be used effectively.

We strongly recommend reading the other two vignettes of this package first.

# How to get started

Simulating data that is reasonably close to a complex real system is not a trivial task, even when using this package. Dividing the big task of obtaining a valid data generation model into multiple sub-tasks is a great first step in the right direction. We suggest following the 7 steps below:

## **1.)** Formulate the goal of your research project in a detailed fashion.

If you haven't done this yet, now is the time. Try to make your goal as explicit as possible. This will help you in deciding which aspects of the system are important to you and which can be safely ignored.

## **2.)** Build a theoretical model of the system you want to simulate.

This entails reading up on relevant literature and writing down any assumptions you may already have about the system. Perhaps (and usually most likely) other researchers have tried to build a simulation model for the same system (or a very similar system). A great way to encode your causal assumptions of the system is time-dependent DAG, as discussed in the other vignettes.

## **3.)** Identify the parts of the system that you are most interested in.

Real systems are incredibly complex. Any simulation will have to make some simplifying assumptions. After building a moderately detailed version of the theoretical model, you will have to decide which aspects are of interest to your research project and which aren't.

## **4.)** Obtain and analyze real data.

If the simulated data should correspond to real data, it is crucial to base the input of the model on actual empirical data. Using the empirical data, you may be able to derive appropriate distributions for the root nodes and appropriate functional forms of the relationship between the considered variables.

## **5.)** Simulate data for $t = 0$.

After having specified suitable distributions and relationships, generate the initial data used in the simulation process. It is important to check this data thoroughly, as it will be used as a basis for all subsequent steps of the simulation. The `sim_from_dag` function might be very helpful for this step.

## **6.)** Write functions for each time-varying node, one at a time.

Each time-varying node requires a user written function that transforms the data at $t$ to the data at $t + 1$. It might be helpful to add one time-varying node at a time and proceeding to step **7.)** before adding other variables, if possible.

## **7.)** Inspect the resulting data for inconsistencies.

Validating your simulation code is important to ensure that no mistakes slipped through. This may be done by fitting models relying on your modeling assumptions to the generated data and checking whether those models produce the expected results.


# Our research goal and the theoretical model

Since this vignette is mostly concerned with the practical implementation of the discrete-time simulation approach using this R-package, we will not spend too much time on the first 4 steps of the process mentioned in the previous section. We only briefly present the most important points.

## Research goal

Our main goal was to identify a suitable data analysis strategy for the assessment of Covid-19 vaccine side-effects for a particular real-life data set. To do this we decided to simulate data that is as close to the real data as possible. Using this data we could then try out different analysis strategies and see which one performed adequately.

## Theoretical model

There is a seemingly endless amount of literature describing models for the Covid-19 pandemic and the associated Covid-19 vaccines (see for example ZITATE). Trying to include all relevant aspects would be an unfeasible task. After deliberating on this literature we decided to include only a few key variables:

* `age`: The age of the individual in years.
* `sex`: The biological sex (male/female) of the individual.
* `region`: An identifier of a geographical region.
* `vacc_type`: The type of vaccine the person received.
* `vacc_1`: The time at which the person received the first vaccine.
* `vacc_2`: The time at which the person received the second vaccine.
* `covid`: Whether a Covid-19 infection occurred.
* `sickness`: Whether the person has developed the sickness of interest.

For our first tryouts, we decided to use the following causal DAG to represent our causal assumptions:



# Data at t0

In our case, the data at the beginning of the simulation contains only the geographic entity `kreis`, the age of the person `sex` and the sex of the person `sex`. The `kreis` and `sex` are treated as root nodes, while the age distribution is generated to be different in each `kreis`, making `age` a child node with `kreis` as a single parent. The `sim_from_dag` function is used to directly generate a data set using these specifications:

```{r}
library(simDAG)
library(Rfast)
library(data.table)

## node kreis
generate_kreis <- function(n) {
  
  probs_kreis <- rbeta(n=400, shape1=1.4, shape2=0.6)
  probs_kreis <- probs_kreis / sum(probs_kreis)
  
  kreis <- sample(c(1:400), size=n, replace=TRUE, prob=probs_kreis)
  
  return(kreis)
}

## node age
node_generate_age <- function(data, parents, betas=NULL) {
  age <- rep(NA, nrow(data))
  for (i in seq_len(400)) {
    dist_mean <- rnorm(n=1, sd=10, mean=55)
    dist_sd <- rnorm(n=1, mean=15, sd=10)
    age[data$kreis==i] <- rnorm(n=sum(data$kreis==i),
                                mean=dist_mean,
                                sd=dist_sd)
  }
  return(age)
}

dag <- empty_dag() +
  node("kreis", type="generate_kreis") +
  node("sex", type="rbernoulli", p=0.5) +
  node("vacc_type", type="rcategorical", probs=c(0.73919444, 0.17035600,
                                                 0.06936522, 0.02032859),
       labels=c(1, 2, 3, 4)) +
  node("age", type="generate_age", parents="kreis")

start_data <- sim_from_dag(dag=dag, n_sim=10)
```

This is how the resulting data looks:

```{r}
head(start_data)
```

## Data at tx:

Our next task is to define what kind of time-dependent nodes we want to use and how exactly they should work.

```{r}

## node age (to increase it as the simulation goes on)
node_advance_age <- function(data) {
  return(data$age + 1/365)
}

## probability of first vaccination
prob_first_vacc <- function(data, sim_time, start_vaccinations,
                            impf_dat, beta_age) {
  
  if (sim_time < start_vaccinations) {
    return(0)
  }
  # There is only so much data yet, afterwards simply return a small but
  # constant value.
  if (sim_time - start_vaccinations >= 600) {
    return(0.000000001)
  }
  
  p <- impf_dat$impf_prob[impf_dat$time==(sim_time - start_vaccinations + 1)]
  p <- p + data$age * beta_age
  
  return(p)
}

## time of second vaccination
node_generate_vacc_2 <- function(data) {
  vacc_2 <- data$vacc_1_time + ((data$vacc_type <= 2) * 42 + 
                                (data$vacc_type==3) * 84) * 
    NA^(data$vacc_type==4)
  return(vacc_2)
}

## base probability of getting covid 19 depending on time
base_p_covid <- function(sim_time) {
  # where do we get this?
  return(0.001)
}

## probability of getting covid 19, depending on time, age and previous vaccine
prob_covid <- function(data, sim_time, start_covid, rr_vacc_start,
                       dur_vacc, vacc_delay, beta_age) {
  
  if (sim_time < start_covid) {
    return(0)
  }
  
  # Alternatively we could use the linear equation defined by the two points:
  # y = ((y2-y1) / (x2-x1)) * x + ((x2*y1-x1*y2) / (x2-x1))
  # to find the person and time specific RR
  # y2 <- 1
  # y1 <- rr_vacc_start
  x1 <- fifelse(data$vacc_type==4, data$vacc_1_time, data$vacc_2) + vacc_delay
  x2 <- x1 + dur_vacc
  
  vacc_reduction <- rr_vacc_start^pmax((1-(sim_time-x1)/x2)*(sim_time-x1 >=0),0)
  
  # set to 1 if NA
  vacc_reduction[is.na(vacc_reduction)] <- 1
  
  # get probability
  p <- (base_p_covid(sim_time) + data$age * beta_age) * vacc_reduction
  
  return(p)
}

## probability of getting sickness
prob_sickness <- function(data, sim_time, rr_vacc_1, rr_vacc_2,
                          rr_covid, risk_dur_vacc, risk_dur_covid,
                          beta_age, base_p) {
  
  # check if in risk periods
  in_vacc_1_risk <- fifelse(is.na(data$vacc_1_time), FALSE,
                            fifelse((sim_time - data$vacc_1_time) < 
                                    risk_dur_vacc, TRUE, FALSE))
  in_vacc_2_risk <- fifelse(is.na(data$vacc_2), FALSE,
                           fifelse(((sim_time - data$vacc_2) < risk_dur_vacc) & 
                                   ((sim_time - data$vacc_2) > 0), TRUE, FALSE))
  in_covid_risk <- fifelse(is.na(data$covid_time), FALSE,
                           fifelse((sim_time - data$covid_time) < 
                                   risk_dur_covid, TRUE, FALSE))
  
  # choose which relative risk to apply to baseline risk
  time_dep_risk <- fifelse(!in_vacc_1_risk & !in_vacc_2_risk &
                           !in_covid_risk, 1,
                          fifelse(in_covid_risk, rr_covid,
                          fifelse(in_vacc_1_risk, rr_vacc_1[data$vacc_type],
                                  rr_vacc_2[data$vacc_type])))
  
  # put all risks together
  p <- (base_p + data$age * beta_age) * time_dep_risk
    
  return(p)
}

# read and clean Impfdata
#impf_dat <- read.xlsx("P:/BMG_Covid19Impfen/Auswertung/Auswertungsplan_Stufen/Simulation_Testdaten/Impfquotenmonitoring.xlsx", sheetIndex=4)
#impf_dat <- impf_dat[1:(nrow(impf_dat)-4),]
#impf_dat$Datum <- as.Date(impf_dat$Datum, format="%d.%m.%Y")
#impf_dat$NA. <- NULL
#
## probability of first vaccination
#impf_dat$time <- 1:nrow(impf_dat)
#impf_dat$cumsum <- cumsum(impf_dat$Erstimpfung)
#impf_dat$cumsum <- c(0, impf_dat$cumsum[1:(nrow(impf_dat)-1)])
#
#impf_dat$impf_prob <- impf_dat$Erstimpfung / (83020000 - impf_dat$cumsum)
#
## definition of time-dependent nodes
#tx_nodes <- list(list(name="age",
#                      parents="age",
#                      type="advance_age"),
#                 list(name="vacc_1",
#                      parents=c("age", "vacc_1_time", "vacc_1_event"),
#                      type="time_to_event",
#                      prob_fun=prob_first_vacc,
#                      prob_fun_args=list(start_vaccinations=365*2,
#                                         impf_dat=impf_dat,
#                                         beta_age=0.000001),
#                      event_duration=Inf,
#                      save_past_events=FALSE),
#                 list(name="vacc_2",
#                      parents=c("vacc_1_event", "vacc_1_time", "vacc_type"),
#                      type="generate_vacc_2"),
#                 list(name="covid",
#                      parents=c("vacc_1_time", "vacc_2", "vacc_type", "age",
#                                "covid_event", "covid_time"),
#                      type="time_to_event",
#                      prob_fun=prob_covid,
#                      prob_fun_args=list(start_covid=365,
#                                         rr_vacc_start=0.8,
#                                         dur_vacc=180,
#                                         vacc_delay=14,
#                                         beta_age=0.000000001),
#                      event_duration=21,
#                      immunity_duration=150,
#                      save_past_events=TRUE),
#                 list(name="sickness",
#                      parents=c("vacc_1_event", "vacc_1_time", "vacc_2",
#                                "age", "covid_event", "covid_time",
#                                "vacc_type", "sickness_event", "sickness_time",
#                                "sickness_past_event_times"),
#                      type="time_to_event",
#                      prob_fun=prob_sickness,
#                      prob_fun_args=list(rr_vacc_1=c(3.24, 3.24, 1, 1),
#                                         rr_vacc_2=c(3.24, 3.24, 1, 1),
#                                         rr_covid=3,
#                                         risk_dur_vacc=21,
#                                         risk_dur_covid=21,
#                                         beta_age=0.00000001,
#                                         base_p=0.00000001),
#                      event_duration=21,
#                      immunity_duration=50,
#                      save_past_events=TRUE))
#
#out <- sim_discrete_time(n_sim=100000,
#                         t0_root_nodes=t0_root_nodes,
#                         t0_child_nodes=t0_child_nodes,
#                         t0_sort_dag=TRUE,
#                         max_t=365*3,
#                         tx_nodes=tx_nodes,
#                         save_states="last")$data
#
```
