[{"path":"https://robindenz1.github.io/simDAG/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"GNU General Public License","title":"GNU General Public License","text":"Version 3, 29 June 2007Copyright © 2007 Free Software Foundation, Inc. <http://fsf.org/> Everyone permitted copy distribute verbatim copies license document, changing allowed.","code":""},{"path":"https://robindenz1.github.io/simDAG/LICENSE.html","id":"preamble","dir":"","previous_headings":"","what":"Preamble","title":"GNU General Public License","text":"GNU General Public License free, copyleft license software kinds works. licenses software practical works designed take away freedom share change works. contrast, GNU General Public License intended guarantee freedom share change versions program–make sure remains free software users. , Free Software Foundation, use GNU General Public License software; applies also work released way authors. can apply programs, . speak free software, referring freedom, price. General Public Licenses designed make sure freedom distribute copies free software (charge wish), receive source code can get want , can change software use pieces new free programs, know can things. protect rights, need prevent others denying rights asking surrender rights. Therefore, certain responsibilities distribute copies software, modify : responsibilities respect freedom others. example, distribute copies program, whether gratis fee, must pass recipients freedoms received. must make sure , , receive can get source code. must show terms know rights. Developers use GNU GPL protect rights two steps: (1) assert copyright software, (2) offer License giving legal permission copy, distribute /modify . developers’ authors’ protection, GPL clearly explains warranty free software. users’ authors’ sake, GPL requires modified versions marked changed, problems attributed erroneously authors previous versions. devices designed deny users access install run modified versions software inside , although manufacturer can . fundamentally incompatible aim protecting users’ freedom change software. systematic pattern abuse occurs area products individuals use, precisely unacceptable. Therefore, designed version GPL prohibit practice products. problems arise substantially domains, stand ready extend provision domains future versions GPL, needed protect freedom users. Finally, every program threatened constantly software patents. States allow patents restrict development use software general-purpose computers, , wish avoid special danger patents applied free program make effectively proprietary. prevent , GPL assures patents used render program non-free. precise terms conditions copying, distribution modification follow.","code":""},{"path":[]},{"path":"https://robindenz1.github.io/simDAG/LICENSE.html","id":"id_0-definitions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"0. Definitions","title":"GNU General Public License","text":"“License” refers version 3 GNU General Public License. “Copyright” also means copyright-like laws apply kinds works, semiconductor masks. “Program” refers copyrightable work licensed License. licensee addressed “”. “Licensees” “recipients” may individuals organizations. “modify” work means copy adapt part work fashion requiring copyright permission, making exact copy. resulting work called “modified version” earlier work work “based ” earlier work. “covered work” means either unmodified Program work based Program. “propagate” work means anything , without permission, make directly secondarily liable infringement applicable copyright law, except executing computer modifying private copy. Propagation includes copying, distribution (without modification), making available public, countries activities well. “convey” work means kind propagation enables parties make receive copies. Mere interaction user computer network, transfer copy, conveying. interactive user interface displays “Appropriate Legal Notices” extent includes convenient prominently visible feature (1) displays appropriate copyright notice, (2) tells user warranty work (except extent warranties provided), licensees may convey work License, view copy License. interface presents list user commands options, menu, prominent item list meets criterion.","code":""},{"path":"https://robindenz1.github.io/simDAG/LICENSE.html","id":"id_1-source-code","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"1. Source Code","title":"GNU General Public License","text":"“source code” work means preferred form work making modifications . “Object code” means non-source form work. “Standard Interface” means interface either official standard defined recognized standards body, , case interfaces specified particular programming language, one widely used among developers working language. “System Libraries” executable work include anything, work whole, () included normal form packaging Major Component, part Major Component, (b) serves enable use work Major Component, implement Standard Interface implementation available public source code form. “Major Component”, context, means major essential component (kernel, window system, ) specific operating system () executable work runs, compiler used produce work, object code interpreter used run . “Corresponding Source” work object code form means source code needed generate, install, (executable work) run object code modify work, including scripts control activities. However, include work’s System Libraries, general-purpose tools generally available free programs used unmodified performing activities part work. example, Corresponding Source includes interface definition files associated source files work, source code shared libraries dynamically linked subprograms work specifically designed require, intimate data communication control flow subprograms parts work. Corresponding Source need include anything users can regenerate automatically parts Corresponding Source. Corresponding Source work source code form work.","code":""},{"path":"https://robindenz1.github.io/simDAG/LICENSE.html","id":"id_2-basic-permissions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"2. Basic Permissions","title":"GNU General Public License","text":"rights granted License granted term copyright Program, irrevocable provided stated conditions met. License explicitly affirms unlimited permission run unmodified Program. output running covered work covered License output, given content, constitutes covered work. License acknowledges rights fair use equivalent, provided copyright law. may make, run propagate covered works convey, without conditions long license otherwise remains force. may convey covered works others sole purpose make modifications exclusively , provide facilities running works, provided comply terms License conveying material control copyright. thus making running covered works must exclusively behalf, direction control, terms prohibit making copies copyrighted material outside relationship . Conveying circumstances permitted solely conditions stated . Sublicensing allowed; section 10 makes unnecessary.","code":""},{"path":"https://robindenz1.github.io/simDAG/LICENSE.html","id":"id_3-protecting-users-legal-rights-from-anti-circumvention-law","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"3. Protecting Users’ Legal Rights From Anti-Circumvention Law","title":"GNU General Public License","text":"covered work shall deemed part effective technological measure applicable law fulfilling obligations article 11 WIPO copyright treaty adopted 20 December 1996, similar laws prohibiting restricting circumvention measures. convey covered work, waive legal power forbid circumvention technological measures extent circumvention effected exercising rights License respect covered work, disclaim intention limit operation modification work means enforcing, work’s users, third parties’ legal rights forbid circumvention technological measures.","code":""},{"path":"https://robindenz1.github.io/simDAG/LICENSE.html","id":"id_4-conveying-verbatim-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"4. Conveying Verbatim Copies","title":"GNU General Public License","text":"may convey verbatim copies Program’s source code receive , medium, provided conspicuously appropriately publish copy appropriate copyright notice; keep intact notices stating License non-permissive terms added accord section 7 apply code; keep intact notices absence warranty; give recipients copy License along Program. may charge price price copy convey, may offer support warranty protection fee.","code":""},{"path":"https://robindenz1.github.io/simDAG/LICENSE.html","id":"id_5-conveying-modified-source-versions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"5. Conveying Modified Source Versions","title":"GNU General Public License","text":"may convey work based Program, modifications produce Program, form source code terms section 4, provided also meet conditions: ) work must carry prominent notices stating modified , giving relevant date. b) work must carry prominent notices stating released License conditions added section 7. requirement modifies requirement section 4 “keep intact notices”. c) must license entire work, whole, License anyone comes possession copy. License therefore apply, along applicable section 7 additional terms, whole work, parts, regardless packaged. License gives permission license work way, invalidate permission separately received . d) work interactive user interfaces, must display Appropriate Legal Notices; however, Program interactive interfaces display Appropriate Legal Notices, work need make . compilation covered work separate independent works, nature extensions covered work, combined form larger program, volume storage distribution medium, called “aggregate” compilation resulting copyright used limit access legal rights compilation’s users beyond individual works permit. Inclusion covered work aggregate cause License apply parts aggregate.","code":""},{"path":"https://robindenz1.github.io/simDAG/LICENSE.html","id":"id_6-conveying-non-source-forms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"6. Conveying Non-Source Forms","title":"GNU General Public License","text":"may convey covered work object code form terms sections 4 5, provided also convey machine-readable Corresponding Source terms License, one ways: ) Convey object code , embodied , physical product (including physical distribution medium), accompanied Corresponding Source fixed durable physical medium customarily used software interchange. b) Convey object code , embodied , physical product (including physical distribution medium), accompanied written offer, valid least three years valid long offer spare parts customer support product model, give anyone possesses object code either (1) copy Corresponding Source software product covered License, durable physical medium customarily used software interchange, price reasonable cost physically performing conveying source, (2) access copy Corresponding Source network server charge. c) Convey individual copies object code copy written offer provide Corresponding Source. alternative allowed occasionally noncommercially, received object code offer, accord subsection 6b. d) Convey object code offering access designated place (gratis charge), offer equivalent access Corresponding Source way place charge. need require recipients copy Corresponding Source along object code. place copy object code network server, Corresponding Source may different server (operated third party) supports equivalent copying facilities, provided maintain clear directions next object code saying find Corresponding Source. Regardless server hosts Corresponding Source, remain obligated ensure available long needed satisfy requirements. e) Convey object code using peer--peer transmission, provided inform peers object code Corresponding Source work offered general public charge subsection 6d. separable portion object code, whose source code excluded Corresponding Source System Library, need included conveying object code work. “User Product” either (1) “consumer product”, means tangible personal property normally used personal, family, household purposes, (2) anything designed sold incorporation dwelling. determining whether product consumer product, doubtful cases shall resolved favor coverage. particular product received particular user, “normally used” refers typical common use class product, regardless status particular user way particular user actually uses, expects expected use, product. product consumer product regardless whether product substantial commercial, industrial non-consumer uses, unless uses represent significant mode use product. “Installation Information” User Product means methods, procedures, authorization keys, information required install execute modified versions covered work User Product modified version Corresponding Source. information must suffice ensure continued functioning modified object code case prevented interfered solely modification made. convey object code work section , , specifically use , User Product, conveying occurs part transaction right possession use User Product transferred recipient perpetuity fixed term (regardless transaction characterized), Corresponding Source conveyed section must accompanied Installation Information. requirement apply neither third party retains ability install modified object code User Product (example, work installed ROM). requirement provide Installation Information include requirement continue provide support service, warranty, updates work modified installed recipient, User Product modified installed. Access network may denied modification materially adversely affects operation network violates rules protocols communication across network. Corresponding Source conveyed, Installation Information provided, accord section must format publicly documented (implementation available public source code form), must require special password key unpacking, reading copying.","code":""},{"path":"https://robindenz1.github.io/simDAG/LICENSE.html","id":"id_7-additional-terms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"7. Additional Terms","title":"GNU General Public License","text":"“Additional permissions” terms supplement terms License making exceptions one conditions. Additional permissions applicable entire Program shall treated though included License, extent valid applicable law. additional permissions apply part Program, part may used separately permissions, entire Program remains governed License without regard additional permissions. convey copy covered work, may option remove additional permissions copy, part . (Additional permissions may written require removal certain cases modify work.) may place additional permissions material, added covered work, can give appropriate copyright permission. Notwithstanding provision License, material add covered work, may (authorized copyright holders material) supplement terms License terms: ) Disclaiming warranty limiting liability differently terms sections 15 16 License; b) Requiring preservation specified reasonable legal notices author attributions material Appropriate Legal Notices displayed works containing ; c) Prohibiting misrepresentation origin material, requiring modified versions material marked reasonable ways different original version; d) Limiting use publicity purposes names licensors authors material; e) Declining grant rights trademark law use trade names, trademarks, service marks; f) Requiring indemnification licensors authors material anyone conveys material (modified versions ) contractual assumptions liability recipient, liability contractual assumptions directly impose licensors authors. non-permissive additional terms considered “restrictions” within meaning section 10. Program received , part , contains notice stating governed License along term restriction, may remove term. license document contains restriction permits relicensing conveying License, may add covered work material governed terms license document, provided restriction survive relicensing conveying. add terms covered work accord section, must place, relevant source files, statement additional terms apply files, notice indicating find applicable terms. Additional terms, permissive non-permissive, may stated form separately written license, stated exceptions; requirements apply either way.","code":""},{"path":"https://robindenz1.github.io/simDAG/LICENSE.html","id":"id_8-termination","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"8. Termination","title":"GNU General Public License","text":"may propagate modify covered work except expressly provided License. attempt otherwise propagate modify void, automatically terminate rights License (including patent licenses granted third paragraph section 11). However, cease violation License, license particular copyright holder reinstated () provisionally, unless copyright holder explicitly finally terminates license, (b) permanently, copyright holder fails notify violation reasonable means prior 60 days cessation. Moreover, license particular copyright holder reinstated permanently copyright holder notifies violation reasonable means, first time received notice violation License (work) copyright holder, cure violation prior 30 days receipt notice. Termination rights section terminate licenses parties received copies rights License. rights terminated permanently reinstated, qualify receive new licenses material section 10.","code":""},{"path":"https://robindenz1.github.io/simDAG/LICENSE.html","id":"id_9-acceptance-not-required-for-having-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"9. Acceptance Not Required for Having Copies","title":"GNU General Public License","text":"required accept License order receive run copy Program. Ancillary propagation covered work occurring solely consequence using peer--peer transmission receive copy likewise require acceptance. However, nothing License grants permission propagate modify covered work. actions infringe copyright accept License. Therefore, modifying propagating covered work, indicate acceptance License .","code":""},{"path":"https://robindenz1.github.io/simDAG/LICENSE.html","id":"id_10-automatic-licensing-of-downstream-recipients","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"10. Automatic Licensing of Downstream Recipients","title":"GNU General Public License","text":"time convey covered work, recipient automatically receives license original licensors, run, modify propagate work, subject License. responsible enforcing compliance third parties License. “entity transaction” transaction transferring control organization, substantially assets one, subdividing organization, merging organizations. propagation covered work results entity transaction, party transaction receives copy work also receives whatever licenses work party’s predecessor interest give previous paragraph, plus right possession Corresponding Source work predecessor interest, predecessor can get reasonable efforts. may impose restrictions exercise rights granted affirmed License. example, may impose license fee, royalty, charge exercise rights granted License, may initiate litigation (including cross-claim counterclaim lawsuit) alleging patent claim infringed making, using, selling, offering sale, importing Program portion .","code":""},{"path":"https://robindenz1.github.io/simDAG/LICENSE.html","id":"id_11-patents","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"11. Patents","title":"GNU General Public License","text":"“contributor” copyright holder authorizes use License Program work Program based. work thus licensed called contributor’s “contributor version”. contributor’s “essential patent claims” patent claims owned controlled contributor, whether already acquired hereafter acquired, infringed manner, permitted License, making, using, selling contributor version, include claims infringed consequence modification contributor version. purposes definition, “control” includes right grant patent sublicenses manner consistent requirements License. contributor grants non-exclusive, worldwide, royalty-free patent license contributor’s essential patent claims, make, use, sell, offer sale, import otherwise run, modify propagate contents contributor version. following three paragraphs, “patent license” express agreement commitment, however denominated, enforce patent (express permission practice patent covenant sue patent infringement). “grant” patent license party means make agreement commitment enforce patent party. convey covered work, knowingly relying patent license, Corresponding Source work available anyone copy, free charge terms License, publicly available network server readily accessible means, must either (1) cause Corresponding Source available, (2) arrange deprive benefit patent license particular work, (3) arrange, manner consistent requirements License, extend patent license downstream recipients. “Knowingly relying” means actual knowledge , patent license, conveying covered work country, recipient’s use covered work country, infringe one identifiable patents country reason believe valid. , pursuant connection single transaction arrangement, convey, propagate procuring conveyance , covered work, grant patent license parties receiving covered work authorizing use, propagate, modify convey specific copy covered work, patent license grant automatically extended recipients covered work works based . patent license “discriminatory” include within scope coverage, prohibits exercise , conditioned non-exercise one rights specifically granted License. may convey covered work party arrangement third party business distributing software, make payment third party based extent activity conveying work, third party grants, parties receive covered work , discriminatory patent license () connection copies covered work conveyed (copies made copies), (b) primarily connection specific products compilations contain covered work, unless entered arrangement, patent license granted, prior 28 March 2007. Nothing License shall construed excluding limiting implied license defenses infringement may otherwise available applicable patent law.","code":""},{"path":"https://robindenz1.github.io/simDAG/LICENSE.html","id":"id_12-no-surrender-of-others-freedom","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"12. No Surrender of Others’ Freedom","title":"GNU General Public License","text":"conditions imposed (whether court order, agreement otherwise) contradict conditions License, excuse conditions License. convey covered work satisfy simultaneously obligations License pertinent obligations, consequence may convey . example, agree terms obligate collect royalty conveying convey Program, way satisfy terms License refrain entirely conveying Program.","code":""},{"path":"https://robindenz1.github.io/simDAG/LICENSE.html","id":"id_13-use-with-the-gnu-affero-general-public-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"13. Use with the GNU Affero General Public License","title":"GNU General Public License","text":"Notwithstanding provision License, permission link combine covered work work licensed version 3 GNU Affero General Public License single combined work, convey resulting work. terms License continue apply part covered work, special requirements GNU Affero General Public License, section 13, concerning interaction network apply combination .","code":""},{"path":"https://robindenz1.github.io/simDAG/LICENSE.html","id":"id_14-revised-versions-of-this-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"14. Revised Versions of this License","title":"GNU General Public License","text":"Free Software Foundation may publish revised /new versions GNU General Public License time time. new versions similar spirit present version, may differ detail address new problems concerns. version given distinguishing version number. Program specifies certain numbered version GNU General Public License “later version” applies , option following terms conditions either numbered version later version published Free Software Foundation. Program specify version number GNU General Public License, may choose version ever published Free Software Foundation. Program specifies proxy can decide future versions GNU General Public License can used, proxy’s public statement acceptance version permanently authorizes choose version Program. Later license versions may give additional different permissions. However, additional obligations imposed author copyright holder result choosing follow later version.","code":""},{"path":"https://robindenz1.github.io/simDAG/LICENSE.html","id":"id_15-disclaimer-of-warranty","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"15. Disclaimer of Warranty","title":"GNU General Public License","text":"WARRANTY PROGRAM, EXTENT PERMITTED APPLICABLE LAW. EXCEPT OTHERWISE STATED WRITING COPYRIGHT HOLDERS /PARTIES PROVIDE PROGRAM “” WITHOUT WARRANTY KIND, EITHER EXPRESSED IMPLIED, INCLUDING, LIMITED , IMPLIED WARRANTIES MERCHANTABILITY FITNESS PARTICULAR PURPOSE. ENTIRE RISK QUALITY PERFORMANCE PROGRAM . PROGRAM PROVE DEFECTIVE, ASSUME COST NECESSARY SERVICING, REPAIR CORRECTION.","code":""},{"path":"https://robindenz1.github.io/simDAG/LICENSE.html","id":"id_16-limitation-of-liability","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"16. Limitation of Liability","title":"GNU General Public License","text":"EVENT UNLESS REQUIRED APPLICABLE LAW AGREED WRITING COPYRIGHT HOLDER, PARTY MODIFIES /CONVEYS PROGRAM PERMITTED , LIABLE DAMAGES, INCLUDING GENERAL, SPECIAL, INCIDENTAL CONSEQUENTIAL DAMAGES ARISING USE INABILITY USE PROGRAM (INCLUDING LIMITED LOSS DATA DATA RENDERED INACCURATE LOSSES SUSTAINED THIRD PARTIES FAILURE PROGRAM OPERATE PROGRAMS), EVEN HOLDER PARTY ADVISED POSSIBILITY DAMAGES.","code":""},{"path":"https://robindenz1.github.io/simDAG/LICENSE.html","id":"id_17-interpretation-of-sections-15-and-16","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"17. Interpretation of Sections 15 and 16","title":"GNU General Public License","text":"disclaimer warranty limitation liability provided given local legal effect according terms, reviewing courts shall apply local law closely approximates absolute waiver civil liability connection Program, unless warranty assumption liability accompanies copy Program return fee. END TERMS CONDITIONS","code":""},{"path":"https://robindenz1.github.io/simDAG/LICENSE.html","id":"how-to-apply-these-terms-to-your-new-programs","dir":"","previous_headings":"","what":"How to Apply These Terms to Your New Programs","title":"GNU General Public License","text":"develop new program, want greatest possible use public, best way achieve make free software everyone can redistribute change terms. , attach following notices program. safest attach start source file effectively state exclusion warranty; file least “copyright” line pointer full notice found. Also add information contact electronic paper mail. program terminal interaction, make output short notice like starts interactive mode: hypothetical commands show w show c show appropriate parts General Public License. course, program’s commands might different; GUI interface, use “box”. also get employer (work programmer) school, , sign “copyright disclaimer” program, necessary. information , apply follow GNU GPL, see <http://www.gnu.org/licenses/>. GNU General Public License permit incorporating program proprietary programs. program subroutine library, may consider useful permit linking proprietary applications library. want , use GNU Lesser General Public License instead License. first, please read <http://www.gnu.org/philosophy/--lgpl.html>.","code":"<one line to give the program's name and a brief idea of what it does.> Copyright (C) <year>  <name of author>  This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program.  If not, see <http://www.gnu.org/licenses/>. <program>  Copyright (C) <year>  <name of author> This program comes with ABSOLUTELY NO WARRANTY; for details type 'show w'. This is free software, and you are welcome to redistribute it under certain conditions; type 'show c' for details."},{"path":[]},{"path":"https://robindenz1.github.io/simDAG/articles/simDAG.html","id":"motivation","dir":"Articles","previous_headings":"Introduction","what":"Motivation","title":"Simulating Complex Crossectional and Longitudinal Data using the simDAG R Package","text":"Applied researchers statisticians frequently use Monte-Carlo simulation techniques variety ways. used estimate required sample sizes (Arnold et al. 2011), formally compare different statistical methods (Morris, White, Crowther 2019; Denz, Klaaßen-Mielke, Timmesfeld 2023), help design plan clinical trials (Kimko Duffull 2002; Nance et al. 2024) teaching purposes (Sigal Chalmers 2016; Fox et al. 2022). main reason broad usage researcher full control true data generation process (DGP). general, researcher define DGP appropriate situation generate multiple datasets . statistical analysis technique applied dataset results analyzed. crucial step every kind Monte-Carlo simulation study thus generation datasets. Depending DGP required researcher, step may become difficult time consuming. example, Monte-Carlo simulations require generation complex longitudinal data variables different types causally related various ways (Asparouhov Muthén 2020). possible data types continuous variables, categorical variables, count variables time--event variables. require different parametrizations simulation strategies. interactions non-linear relationships variables required, simulating data DGP becomes even challenging. Generating artificial data requires (1) formal description DGP, (2) knowledge algorithm may used generate data DGP, (3) ability create software application implement algorithm. Although many statisticians may problem theses steps, might case applied researchers. importantly, third step particular may require high level expertise programming, resulting program validated extensively also computationally efficient enough allow potentially thousands datasets generated reasonable amount time. Additionally, also flexible enough allow user easily make changes DGP useful cases (Sofrygin, van der Laan, Neugebauer 2017). comprehensive software application automates required work therefore great benefit scientific community. article present simDAG R package, offers easy use consistent framework generate arbitrarily complex crossectional longitudinal data. aim package make three steps data generation process easier giving users standardized way define desired DGP, can used directly generate data without user input. requiring user define directed acyclic graph (DAG) additional information associations supplied variables (Pearl 2009). package created using R programming language (R Core Team 2024) available Comprehensive R Archive Network (CRAN) https://cran.r-project.org/package=simDAG.","code":""},{"path":"https://robindenz1.github.io/simDAG/articles/simDAG.html","id":"using-dags-to-define-data-generation-processes","dir":"Articles","previous_headings":"Introduction","what":"Using DAGs to define data generation processes","title":"Simulating Complex Crossectional and Longitudinal Data using the simDAG R Package","text":"package, user required describe desired DGP causal DAG. Formally, DAG mathematical graph consisting set VV nodes (vertices) set EE edges (links) connecting pairs nodes. ’ name suggests, DAG consists directed edges acyclic, meaning cycles following directed paths DAG (Byeon Lee 2023). causal DAG special sort DAG nodes represent random variables edges represent directed causal relationships variables (Pearl 2009). simple example containing three nodes time-dependencies given Figure 1. DAG figure contains directed arrow AA CC BB CC. translates assumptions direct causal effect AA CC BB CC, direct causal relationship AA BB (due absence arrow ). example DAG three nodes. DAGs cornerstone structural approach causal inference developed Pearl (2009) Spirtes, Glymour, Scheines (2000). used extensively social research (Wouk, Bauer, Gottfredson 2019), economics (Imbens 2020) epidemiology (Byeon Lee 2023) encode causal assumptions real underlying DGP empirical data. empirical research graphs useful give clear overview causal assumptions made researchers. using causal graphical methods backdoor criterion (Pearl 2009) frontdoor criterion (Pearl 1995), also possible use graphs determine variables need adjusted order get unbiased estimates certain causal effects. daggitty R package directly implements multiple tools kind usage (Textor et al. 2016). kind DAGs can formally described using structural equations. equations describe node distributed. example, general set structural equations may used describe DAG Figure 1 : ∼fA(UA),B∼fB(UB),C∼fC(,B,UC).     \\begin{aligned}         \\sim & f_A(U_A), \\\\         B \\sim & f_B(U_B), \\\\         C \\sim & f_C(, B, U_C). \\\\     \\end{aligned} equations, unspecified functions fAf_A, fBf_B fCf_C describe exactly nodes distributed, possibly conditional nodes. terms UAU_A, UBU_B UCU_C denote random errors disturbances. functions structural equations specified assumption probability distribution error terms made, equivalent non-parametric structural equation model (Pearl 2009; Sofrygin, van der Laan, Neugebauer 2017). make generation data DAG possible, however, enough specify variables causally related one another. structural equations now also fully specified. means distribution functions node defined way user. popular way use regression models parametric distributions (Kline 2023), theory kind function may used, allowing definition arbitrarily complex DGPs. Continuing example , define structural equations DAG follows: ∼N(0,1),B∼N(0,1),C∼−2+⋅0.3+B⋅−2+N(0,1).     \\begin{aligned}         \\sim & N(0, 1), \\\\         B \\sim & N(0, 1), \\\\         C \\sim & -2 + \\cdot0.3 + B\\cdot-2 + N(0, 1). \\\\     \\end{aligned} means AA BB independent standard normally distributed variables CC follows simple linear regression model based AA BB independent normally distributed error term mean zero. structural equations distribution functions defined, data may generated DAG using fairly simple algorithm. algorithm essentially generates data one node time, using supplied definitions data generated previous steps. step-wise method relies fact every DAG can topologically sorted, means always ordering nodes every link (ui,uj)(u_i, u_j) nodes uiu_i uju_j, uiu_i comes uju_j(Kahn 1962). generation data starts ordering nodes graph topologically sorted way. means nodes DAG arrows pointing , sometimes called root nodes, processed first. Data kinds nodes can generated sampling pre-specified parametric distribution, Gaussian distribution beta distribution, process, re-sampling based strategies (Carsey Harden 2014). data nodes generated, data next node topological order generated, based already generated data. nodes called child nodes, dependent nodes, called parent nodes (Byeon Lee 2023). example DAG shown earlier, two possible topological sortings : (,B,C)(B,,C).     (, B, C) \\quad \\text{} \\quad (B, , C). , AA BB root nodes parents CC child node ’ parents AA BB. generate data example using algorithm described , one first generate nn random draws standard normal distribution AA BB. Next, one calculate linear combination values specified linear regression model earlier Equation add nn random draws another standard normal distribution (represents error term). R, simple example simulated using following code: Although manual code required example fairly simple, longer case DAGs nodes /complex DGP (example one including different data types). simDAG package offers standardized way define possible DAG required distribution functions facilitate clear reproducible workflow. previous explanations given example focused simple case crossectional data without time-dependencies. , however, fairly straightforward include time-varying structure DAG well simply adding time-index time-varying nodes repeating node point time considered (Hernán Robins 2020). proposed package features computationally efficient functions automate process large amounts time-points using discrete-time simulation approach (Tang, Leu, Abbass 2020). Although procedure relies discrete time scale, can used generate data semi-continuous time-scale using small steps time. described detail later Section. Note also causal DAGs imply specific causal structure, algorithms code described necessitate causal structure interpreted generated data. example, structural equations shown earlier state AA BB direct causes CC, datasets can generated equations also interpreted AA BB associated CC unknown reasons. long desired DGP can described DAG, almost always case, strategy may used effectively generate data even Monte-Carlo studies concerned causal inference. Although data-generation algorithm described appropriate applications, may best choice validating causal discovery methods, due marginal variance variable increasing along order topological sorting (Reisach, Seiler, Weichwald 2021). methods, onion method proposed Andrews Kummerfeld (2024) may preferable particular case.","code":"set.seed(43) n <- 100  A <- stats::rnorm(n) B <- stats::rnorm(n) C <- -2 + A*0.3 + B*-2 + stats::rnorm(n)"},{"path":"https://robindenz1.github.io/simDAG/articles/simDAG.html","id":"comparison-with-existing-software","dir":"Articles","previous_headings":"Introduction","what":"Comparison with existing software","title":"Simulating Complex Crossectional and Longitudinal Data using the simDAG R Package","text":"many different software packages may used generate data R programming language languages Python. infeasible summarise , focus offer functionality similar simDAG package instead. following review therefore intended exhaustive. merely aim show existing software differs proposed package. Multiple R packages support generation synthetic data fully specified structural equation models. lavaan package (Rosseel 2012), semTools package (Jorgensen et al. 2022) simsem package (Pornprasertmanit et al. 2021) examples. However, packages focus solely structural equation models linear relationships allow generation data different data types. example, none packages allow generation time--event data, type data often needed simulation studies. Specialized R packages survsim (Moriña Navarro 2017), simsurv (Brilleman et al. 2021), rsurv (Demarqui 2024) reda (Wang et al. 2022) packages may used simulate data instead. Although packages allow generation recurrent events, competing events general multi-state time--event data, unlike simDAG package, none support arbitrary mixtures data types time-varying covariates. packages, simPop package (Templ et al. 2017) simFrame package (Alfons, Templ, Filzmoser 2010) allow generation complex synthetic data structures well, mostly focused generating data mimicks real datasets. Similarly, simtrial package offers flexible tools generation randomized controlled trial data, difficult use generate data types. Software directly based causal DAGs DGPs also exists. Although stated package documentation directly, simstudy package (Goldfeld Wujciak-Jens 2020) also relies DAG based algorithm described earlier. supports use different data types custom generation functions, partial support generation longitudinal data. Alternatively, Python library DagSim (Hajj, Pensar, Sandve 2023) allows users generate arbitrary forms data, also allowing user supply custom functions data generation process. price flexibility , however, many default options implemented library. Finally, simcausal R package (Sofrygin, van der Laan, Neugebauer 2017) similar simDAG package fact big inspiration . Like simDAG package, also based causal DAG framework. syntax defining DAG nearly , differences formula objects can specified. Unlike proposed package, however, simcausal package focused mostly generating data simulation studies dealing causal inference. , also directly supports generation data performing interventions DAG (Pearl 2009). Although proposed package lacks functionality, lot flexible terms data can generated. simDAG supports use arbitrary data generation functions, definition interactions, non-linear relationships mixed model syntax ’ formula interface categorical input data nodes. None features present simcausal (Sofrygin, van der Laan, Neugebauer 2017).","code":""},{"path":"https://robindenz1.github.io/simDAG/articles/simDAG.html","id":"organization-of-this-article","dir":"Articles","previous_headings":"Introduction","what":"Organization of this article","title":"Simulating Complex Crossectional and Longitudinal Data using the simDAG R Package","text":"First, introduce important functionality proposed package describing core functions usual workflow employing package. includes detailed description translate theoretical description desired DGP DAG object, may used generate data. Afterwards illustrate capabilities package reproducing DGPs multiple real Monte-Carlo simulation studies. Two DGPs describing generation crossectional data longitudinal data considered points time considered first. Afterwards, introduction generation complex longitudinal data utilizing discrete-time simulation approach presented. Finally, package potential usefulness discussed.","code":""},{"path":[]},{"path":"https://robindenz1.github.io/simDAG/articles/simDAG.html","id":"included-functions","dir":"Articles","previous_headings":"The workflow","what":"Included functions","title":"Simulating Complex Crossectional and Longitudinal Data using the simDAG R Package","text":"following functions used typical workflow using simDAG R package. package additionally includes multiple functions starting node_. functions used generate data different types using different specifications. Usually called directly user. Instead specified types node() node_td() functions called internally. additional convenience functions also included, discussed article. Instead choose focus describing core functionality detail refer interested user official documentation information.","code":""},{"path":"https://robindenz1.github.io/simDAG/articles/simDAG.html","id":"defining-the-dag","dir":"Articles","previous_headings":"The workflow","what":"Defining the DAG","title":"Simulating Complex Crossectional and Longitudinal Data using the simDAG R Package","text":"Regardless kind data user want generate, always necessary first define DAG object adequately describes DGP user wants simulate. cases done using following steps: (1) Initialize empty DAG object using empty_dag() function. (2) Define one multiple nodes using node() node_td() functions. (3) Add nodes DAG using + syntax add_node() function. empty_dag() function simple, arguments. merely used setup initial DAG object. actual definition nodes done using either node() function (node single point time) node_td() function (node varies time), following syntax: arguments : name: character string name node generated, character vector including multiple names. character vector one name supplied, multiple independent nodes definition added DAG object. type: character string specifying type node suitable function can used generate data node. details supported node types given next Section. parents: node child node argument contain names ’ parents, unless formula supplied instead. formula: optional formula object specifies additive combination coefficients variables required generalized linear models example. argument may used built-node types user-defined functions. allows inclusion internally generated dummy variables (using categorical variables parents), interaction terms arbitrarily high orders, cubic terms arbitrary mixed model syntax node types. ...: Additional arguments passed function defined type argument. example, simple DAG described earlier may created using following code: First, empty DAG object initialized using empty_dag() function, nodes added directly using + syntax. , node() function required, nodes defined single point time, since DAG supposed describe crossectional data. Additionally, since AA BB structural equation , one call node() needed define nodes. setting type=\"rnorm\" leaving parents formula arguments default values, nodes specified root nodes values generated using rnorm() function additional arguments passed afterwards. CC supposed follow linear regression model, type=\"gaussian\" used structural equation specified using formula argument. result DAG object. re-create Figure 1, users may use associated S3 plot() method, internally uses igraph package (Csárdi et al. 2024) put nodes position ggplot2 package (Wickham 2016) ggforce (Pedersen 2022) actual plotting:  output exactly Figure 1 space reasons, similar. Additionally, underlying structural equations may printed directly using associated S3 summary() method: methods may useful check whether DAG defined intended user, formally describe DGP publication.","code":"node(name, type, parents=NULL, formula=NULL, ...)  node_td(name, type, parents=NULL, formula=NULL, ...) library(\"simDAG\") dag <- empty_dag() +   node(c(\"A\", \"B\"), type=\"rnorm\", mean=0, sd=1) +   node(\"C\", type=\"gaussian\", formula=~-2 + A*0.3 + B*-2,        error=1) library(\"igraph\") library(\"ggplot2\") library(\"ggforce\") plot(dag, layout=\"as_tree\", node_size=0.15, node_fill=\"grey\",      node_text_fontface=\"italic\") summary(dag) #> A DAG object using the following structural equations: #>  #> A ~ N(0, 1) #> B ~ N(0, 1) #> C ~ N(-2 + A*0.3 + B*-2, 1)"},{"path":"https://robindenz1.github.io/simDAG/articles/simDAG.html","id":"supported-node-types","dir":"Articles","previous_headings":"The workflow","what":"Supported node types","title":"Simulating Complex Crossectional and Longitudinal Data using the simDAG R Package","text":"Different types nodes supported, depending kind node specified. node root node, function argument called n specifies many observations kind generated may used. example, base R runif() function may used type generate uniformly distributed node. popular choices rnorm() normally distributed nodes rgamma() gamma distributed node. convenience, proposed package also includes implementations fast Bernoulli trials (rbernoulli()), fast sampling discrete probability distributions (rcategorical()) function set node constant value (rconstant()). node one parent nodes, function can generate data based nodes arguments data (containing data generated point) parents (vector names parent nodes) may used type. Multiple popular choices directly implemented package. include nodes based generalized linear models potentially complex functions sample conditional distributions. Finally, package also includes two specialized functions may used discrete-time simulations. functions able generate binary categorical time-varying covariates, well multiple forms time--event data repeatedly performing Bernoulli trials multinomial trials time. details given Section discrete-time simulation. brief overview implemented node types given following Table. Note using node types, user may either pass respective function directly type argument, use string name without node_ prefix. Table 1: brief overview implemented node types. first section contains functions may used generate root nodes, second section contains functions may used generate child nodes. Nodes sections may used node() node_td() calls. nodes mentioned third section meant used discrete-time simulations.","code":""},{"path":"https://robindenz1.github.io/simDAG/articles/simDAG.html","id":"simulating-crossectional-data","dir":"Articles","previous_headings":"","what":"Simulating crossectional data","title":"Simulating Complex Crossectional and Longitudinal Data using the simDAG R Package","text":"following Section illustrate use simDAG package simulate complex crossectional data. Instead using made artificial example, partially replicating real Monte-Carlo simulation study Denz, Klaaßen-Mielke, Timmesfeld (2023), published prestigious peer-reviewed journal Statistics Medicine. package strictly focuses data generation step Monte-Carlo studies reasons brevity, reproduce entire simulation study. Instead replicate DGP used generate data study. Denz, Klaaßen-Mielke, Timmesfeld (2023) recently performed neutral comparison study multiple different methods estimate counterfactual survival curves crossectional observational data. Monte-Carlo simulation study wanted investigate different kinds misspecifications nuisance models, used methods estimate counterfactual survival curves, affect estimates produced different methods. , DGP required includes multiple interrelated binary continuous variables, well right-censored time--event variable. particular, data sets generated simulation run included six covariates, two binary (X1,X3X_1, X_3) four continuous (X2,X4,X5,X6X_2, X_4, X_5, X_6). additionally included binary treatment variable (ZZ) right-censored time--event outcome (TT). two binary covariates X1X_1 X3X_3 followed simple Bernoulli distribution success probability 0.5. X2X_2 generated linear regression model, dependent X3X_3. two continuous covariates X4X_4 X6X_6 standard normally distributed, X5X_5 generated according linear regression model dependent X6X_6. treatment variable ZZ followed logistic regression model, dependent X2X_2, X3X_3, X5X_5 X6X_6, X2X_2 included squared term. Finally, outcome TT generated according Cox model, dependent X1X_1, X2X_2, X4X_4, X5X_5 ZZ, X5X_5 included squared term. Data TT generated using method (Bender, Augustin, Blettner 2005), based Weibull distribution (λ=2,γ=2.4\\lambda=2, \\gamma=2.4). time censoring generated independently second Weibull distribution (λ=1,γ=2\\lambda=1, \\gamma=2). DGP used includes two confounders (X2X_2, X5X_5) causal effect ZZ TT, correlated non-confounding variables. inclusion non-linear relationships allowed Denz, Klaaßen-Mielke, Timmesfeld (2023) investigate different kinds misspecified models. details DGP simulation study given original manuscript. replicate DGP study, following DAG definition may used: , can define nodes X1X_1 X3X_3 nodes X4X_4 X5X_5 using single call node(), definition. Since directly supported regression models required DGP, able use formula argument directly type structural equations. Plotting DAG using plot() method produces following output:  underlying structural equations : Finally, can generate single data.table DAG using sim_from_dag() function. first rows generated data look like : Although eight nodes defined corresponding DAG, includes nine columns. reason nodes generated using type=\"cox\" default generate two columns: one observed time one indicating whether observation right-censored . standard data format time--event data one reasons supplied node functions allowed output multiple columns time. course also extends custom user-defined node types. censoring distribution supplied, also possible return simulated time--event single column setting as_two_cols=FALSE node() call TT.","code":"dag <- empty_dag() +   node(c(\"X1\", \"X3\"), type=\"rbernoulli\", p=0.5,        output=\"numeric\") +   node(c(\"X4\", \"X6\"), type=\"rnorm\", mean=0, sd=1) +   node(\"X2\", type=\"gaussian\", formula=~0.3 + X3*0.1,        error=1) +   node(\"X5\", type=\"gaussian\", formula=~0.3 + X6*0.1,        error=1) +   node(\"Z\", type=\"binomial\", formula=~-1.2 + I(X2^2)*log(3)         + X3*log(1.5) + X5*log(1.5) + X6*log(2),        output=\"numeric\") +   node(\"T\", type=\"cox\", formula=~X1*log(1.8) + X2*log(1.8) +         X4*log(1.8) + I(X5^2)*log(2.3) + Z*-1,        surv_dist=\"weibull\", lambda=2, gamma=2.4,        cens_dist=\"rweibull\",        cens_args=list(shape=1, scale=2)) plot(dag, node_size=0.3, node_fill=\"grey\",      node_text_fontface=\"italic\") summary(dag) #> A DAG object using the following structural equations: #>  #>   X1 ~ Bernoulli(0.5) #>   X3 ~ Bernoulli(0.5) #>   X4 ~ N(0, 1) #>   X6 ~ N(0, 1) #>   X2 ~ N(0.3 + X3*0.1, 1) #>   X5 ~ N(0.3 + X6*0.1, 1) #>    Z ~ Bernoulli(logit(-1.2 + I(X2^2)*log(3) + X3*log(1.5) + #>                   X5*log(1.5) + X6*log(2))) #> T[T] ~ (-(log(Unif(0, 1))/(2*exp(X1*log(1.8) + X2*log(1.8) + #>          X4*log(1.8) + I(X5^2)*log(2.3) + Z*-1))))^(1/2.4) #> T[C] ~ rweibull(shape=1, scale=2) library(\"data.table\") dat <- sim_from_dag(dag, n_sim=500) head(round(dat, 3)) #>       X1    X3     X4     X6     X2     X5     Z T_time T_status #>    <num> <num>  <num>  <num>  <num>  <num> <num>  <num>    <num> #> 1:     0     0 -0.646  1.186 -0.628  1.395     1  0.318        0 #> 2:     1     0  0.968 -2.368  0.101 -0.040     0  0.135        1 #> 3:     0     0  0.125  2.012  0.662  0.694     1  0.758        1 #> 4:     0     1 -0.142 -2.610 -0.826  0.588     1  1.100        1 #> 5:     0     0 -0.273  0.632  1.462  0.007     1  0.890        1 #> 6:     1     1 -0.198  0.379  0.693  2.416     1  0.058        1"},{"path":"https://robindenz1.github.io/simDAG/articles/simDAG.html","id":"simulating-longitudinal-data-with-few-points-in-time","dir":"Articles","previous_headings":"","what":"Simulating longitudinal data with few points in time","title":"Simulating Complex Crossectional and Longitudinal Data using the simDAG R Package","text":"many applications desired DGP may contain one variables change time. case, longitudinal data must generated. two approaches using algorithm implemented proposed package: (1) defining one node per point time interest (2) constructing one node definition points time considered simultaneously. Section first approach illustrated replicating DGP used Monte-Carlo simulation study performed Gruber et al. (2015). study, Gruber et al. (2015) compared efficiency different methods estimating inverse probability weights marginal structural models. models often used estimate marginal causal effects treatment-regimes longitudinal observational data time-varying variables (Hernán Robins 2020). main aim quantify benefits using ensemble methods versus using traditional methods, logistic regression models, estimating required weights. DGP therefore required inclusion time-varying variables. focus DGP theses authors used first simulation scenario. DGP consisted four variables: binary treatment variable AA, binary unmeasured baseline covariate UU, continuous confounder LL binary outcome YY. Since UU represents baseline variable, vary time. variables, however, generated two distinct time points. LL AA generated time 00 11, time-lagged outcome YY generated times 11 22. simplicity, AA affected present past LL previous values AA . LL hand caused previous values AA UU. Finally, YY caused UU, meaning neither treatment confounder actual effect outcome. generate continuous child nodes relied linear regression models. binary child nodes, logistic regression models used. detailed description data generation process given original article (Gruber et al. 2015). DAG object define DGP proposed package given . Shown graphically, DAG looks like :  structural equations can printed using summary() function: Finally, can call sim_from_dag() function DAG generate data: variables AA, LL YY generated different points time, include one node definition per variable per point time get appropriate DAG. Apart syntax exactly generating crossectional data. points time added simply adding calls node() DAG object, using appropriate regression models. main advantage method allows flexible changes DGP time. However, obvious shortcoming easily extend scenarios many points time. Although authors considered three time-varying variables two distinct points time , DAG definition already quite cumbersome. every point time, three new calls node() necessary. hundreds points time considered, using method essentially -feasible. circumvent problems describe slightly different way generating longitudinal data .","code":"dag <- empty_dag() +   node(\"U\", type=\"rbernoulli\", p=0.5, output=\"numeric\") +   node(\"L0\", type=\"gaussian\", formula=~0.1 + 0.6*U,        error=1) +   node(\"A0\", type=\"binomial\", formula=~-0.4 + 0.6*L0,        output=\"numeric\") +   node(\"Y1\", type=\"binomial\", formula=~-3.5 + -0.9*U,        output=\"numeric\") +   node(\"L1\", type=\"gaussian\", formula=~0.5 + 0.02*L0 +         0.5*U + 1.5*A0, error=1) +   node(\"A1\", type=\"binomial\", formula=~-0.4 + 0.02*L0 +         0.58*L1, output=\"numeric\") +   node(\"Y2\", type=\"binomial\", formula=~-2.5 + 0.9*U,        output=\"numeric\") plot(dag, node_size=0.2, node_fill=\"grey\",      node_text_fontface=\"italic\", layout=\"in_circle\") summary(dag) #> A DAG object using the following structural equations: #>  #>  U ~ Bernoulli(0.5) #> L0 ~ N(0.1 + 0.6*U, 1) #> A0 ~ Bernoulli(logit(-0.4 + 0.6*L0)) #> Y1 ~ Bernoulli(logit(-3.5 + -0.9*U)) #> L1 ~ N(0.5 + 0.02*L0 + 0.5*U + 1.5*A0, 1) #> A1 ~ Bernoulli(logit(-0.4 + 0.02*L0 + 0.58*L1)) #> Y2 ~ Bernoulli(logit(-2.5 + 0.9*U)) dat <- sim_from_dag(dag, n_sim=1000) head(dat) #>        U         L0    A0    Y1         L1    A1    Y2 #>    <num>      <num> <num> <num>      <num> <num> <num> #> 1:     0  1.3086008     0     0 -0.1642422     1     0 #> 2:     1 -0.4978996     1     0  3.2424318     0     0 #> 3:     1  0.5125773     1     0  2.4114821     1     0 #> 4:     1  1.1811591     1     0  3.2285778     0     1 #> 5:     1  1.3826790     1     0  1.7878382     1     0 #> 6:     1 -0.3077301     0     0  1.1737307     0     0"},{"path":[]},{"path":"https://robindenz1.github.io/simDAG/articles/simDAG.html","id":"formal-description","dir":"Articles","previous_headings":"Simulating longitudinal data with many points in time","what":"Formal description","title":"Simulating Complex Crossectional and Longitudinal Data using the simDAG R Package","text":"Instead defining node every point time separately, often possible define structural equations generic time-dependent fashion, equation can applied point time, simplifying workflow considerably. result description specific stochastic process. example, consider simple DAG one time-dependent node YY three points time, t∈{0,1,2}t \\\\{0, 1, 2\\}:  DAG, YtY_t caused values t−1t-1. Suppose YY binary event indicator zero everyone t=0t = 0. every point time tt, YY set 1 probability 0.01. YY set 1, never changes back 0. following structural equation may used describe DAG: Yt∼Bernoulli(PY(t)),     Y_t \\sim Bernoulli(P_Y(t)), PY(t)={0ift=01ifYt−1=10.01,otherwise.     P_Y(t) =     \\begin{cases}         0 & \\text{} \\quad t = 0 \\\\         1 & \\text{} \\quad Y_{t-1} = 1 \\\\         0.01, & \\text{otherwise}     \\end{cases}. number points time increased arbitrary number structural equation still used. Note time points may stand period time, minutes, days years. course trivial example, approach may also used define complex DGPs, illustrated . example, arbitrary dependencies variables measured time earlier time may used defining node. generate data type DAG, algorithm described first Section may used. Since discrete points time considered, type simulation also called discrete-time simulation (Tang, Leu, Abbass 2020) dynamic microsimulation (Spooner et al. 2021) literature closely related discrete-event simulation (Banks et al. 2014).","code":""},{"path":"https://robindenz1.github.io/simDAG/articles/simDAG.html","id":"a-simple-example","dir":"Articles","previous_headings":"Simulating longitudinal data with many points in time","what":"A simple example","title":"Simulating Complex Crossectional and Longitudinal Data using the simDAG R Package","text":"generate data simple example considered proposed package, first define appropriate DAG object . can done using node_td() function type=\"time_to_event\" shown . default, value node defined using type=\"time_to_event\" 0 individuals t=0t = 0. prob_fun argument defines function determines occurrence probability point time. set 0.01 , indicating individuals regardless value tt probability experiencing event constant. Usually argument passed appropriate function generate occurrence probability individual point time separately, necessary yet. setting event_duration argument Inf, indicating events infinite duration, making first event final event person. contrast , sim_discrete_time() function now used generate data DAG object, contains time-varying node: max_t argument specifies many points time simulated. Instead just three points time consider 80 . Contrary sim_from_dag() function, sim_discrete_time() function return single data.table. Instead returns simDT object, usually processed using sim2data() function useful. case, however, enough simply extract last state simulation get information need. last simulation state stored $data parameter simDT object: specified, simulation contains variable YY, split two columns. first called Y_event binary indicator whether individual currently experiencing event. second column called Y_time shows time event happened, set NA event currently happening. Since every event final, information generated . Individuals value NA Y_time can considered right-censored t=80t = 80. trivial example, lot easier generate equivalent data sampling appropriate parametric distributions. following Section illustrate benefits approach using involved example.","code":"dag <- empty_dag() +   node_td(\"Y\", type=\"time_to_event\", prob_fun=0.01,           event_duration=Inf) sim <- sim_discrete_time(dag, n_sim=1000, max_t=80) head(sim$data) #>      .id Y_event Y_time #>    <int>  <lgcl>  <int> #> 1:     1   FALSE     NA #> 2:     2   FALSE     NA #> 3:     3   FALSE     NA #> 4:     4    TRUE     62 #> 5:     5    TRUE     11 #> 6:     6    TRUE     24"},{"path":"https://robindenz1.github.io/simDAG/articles/simDAG.html","id":"simulating-adverse-events-after-covid-19-vaccination","dir":"Articles","previous_headings":"Simulating longitudinal data with many points in time","what":"Simulating adverse events after Covid-19 vaccination","title":"Simulating Complex Crossectional and Longitudinal Data using the simDAG R Package","text":"Suppose want generate data Covid-19 pandemic, containing individual level information Covid-19 vaccinations denoted AA development acute myocarditis denoted YY. Different individuals get vaccinated different times, possible multiple times. Additionally, might experience zero multiple cases myocarditis, also different times. variables therefore time-dependent binary variables, related one another. target interest estimate effect vaccination time occurrence myocarditis, vaccination may considered time-dependent variable myocarditis non-terminal, possibly recurrent, time--event outcome. setup interest Denz et al. (2025), performed Monte-Carlo simulation study investigate impact linkage errors estimating vaccine-safety observational data. illustrate simplified version DGP used therein. simplicity, make multiple simplifying assumptions made original simulation study. First, assume probability vaccinated base probability developing myocarditis constant time equal individuals. risk factor developing myocarditis example Covid-19 vaccination . precisely, structural equation myocarditis node tt given : Yt∼Bernoulli(PY(t)),     Y_t \\sim Bernoulli(P_{Y}(t)), : PY(t)={PY0⋅RRA,t∈[TA(t),TA(t)+drisk]PY0,otherwise,     P_{Y}(t) =     \\begin{cases}         P_{Y0} \\cdot RR_{}, & \\text{} t \\ \\left[T_{}(t), T_{}(t) + d_{risk}\\right] \\\\         P_{Y0}, & \\text{otherwise}     \\end{cases}, PY0P_{Y0} denotes base probability developing myocarditis, TA(t)T_{}(t) denotes time last performed vaccination driskd_{risk} defines duration vaccination risk developing myocarditis elevated RRARR_{}. particular case, tt represent single day. Similarly, vaccination node can described formally : ∼Bernoulli(PA(t)),     A_t \\sim Bernoulli(P_{}(t)), : PA(t)={1,t∈[TA(t),TA(t)+20]0,t∈[TA(t)+21,TA(t)+150]PA0,otherwise,     P_{}(t) =     \\begin{cases}         1, & \\text{} t \\ \\left[T_{}(t), T_A(t) + 20 \\right] \\\\         0, & \\text{} t \\ \\left[T_{}(t) + 21, T_A(t) + 150\\right] \\\\         P_{A0}, & \\text{otherwise}     \\end{cases}, PA0P_{A0} denotes base probability getting vaccinated. Figure illustrates result applying structural equations fictional person gets vaccinated t=100t = 100. simple graph showing PA(t)P_A(t) PY(t)P_Y(t) fictional individual got vaccinated t=100t = 100, PA0=0.01P_{A0} = 0.01, PY0=0.005P_{Y0} = 0.005, drisk=20d_{risk} = 20 RRA=3.24RR_A = 3.24. following code may used define DGP: First, define function calculates PY(t)P_Y(t) simulated day individuals, called prob_myoc(). function simply checks whether binary event indicator vaccination event, \"A_event\", currently TRUE multiplies baseline probability developing myocarditis PY0P_{Y0} relative risk case. Otherwise just returns baseline probability directly. function passed directly prob_fun argument node_td() call defining myocarditis node. sensible strategy, need ensure \"A_event\" TRUE person currently elevated risk myocarditis, defined earlier Equation. words, \"A_event\" actually indicator whether someone just received vaccination, indicator whether person currently risk period 20 days following vaccination. can achieve setting event_duration parameter node definition vaccination node 20, meaning vaccination node equal 1 20 days vaccination performed. argument direct feature node_time_to_event() function, called internally whenever type=\"time_to_event\" used time-dependent node. base probability vaccination myocarditis events set arbitrary values 0.01 0.005 respectively. RRARR_{} set 3.24, value used actual simulation study Denz et al. (2025). immunity_duration parameter used vaccination node additionally specifies person receive another vaccination first 150 days vaccination performed. specifically, settings ensure \"A_event\" set FALSE 130 days event_duration 20 days . another feature \"time_to_event\" nodes. run simulation two simulated years, following code may used: Since included variables change time may multiple events, appropriate just look last state simulation case. Instead use sim2data() function obtain useful dataset. following code may used get dataset start-stop format: format, multiple rows per person, corresponding periods time variables stayed . intervals defined start column (time period starts) stop columns (time period ends). overlap argument specifies whether intervals overlapping . setting target_event=\"Y\", function treats Y node outcome instead another time-dependent covariate. resulting data exactly format needed fit standard time--event models, Cox model time-varying covariates (Z. Zhang et al. 2018). Using survival package (Therneau 2024), can using following code: DGP fulfills assumptions Cox model sample size large, resulting hazard ratio close relative risk 3.24 specified DAG object. types models, discrete-time survival models, may require different data formats (Tutz Schmid 2016). , sim2data() function also supports transformation long- wide- format data. assumed presence myocarditis event effect whether person gets vaccinated . reality, unlikely person currently experiencing myocarditis get Covid-19 vaccine. can include DGP modifying prob_fun argument defining vaccination node shown : extension, probability getting vaccinated set 0 whenever respective person currently experiencing myocarditis event. additionally setting event_duration parameter myocarditis node arbitrary value 80, defining 80 days experiencing event vaccination person. Data generated transformed using code .","code":"prob_myoc <- function(data, P_0, RR_A) {   fifelse(data$A_event, P_0*RR_A, P_0) }  dag <- empty_dag() +   node_td(\"A\", type=\"time_to_event\", prob_fun=0.01,           event_duration=20, immunity_duration=150) +   node_td(\"Y\", type=\"time_to_event\", prob_fun=prob_myoc,           parents=c(\"A_event\"), P_0=0.005, RR_A=3.24) sim <- sim_discrete_time(dag, n_sim=10000, max_t=365*2) dat <- sim2data(sim, to=\"start_stop\", target_event=\"Y\",                 keep_only_first=TRUE, overlap=TRUE) head(dat) #>      .id start  stop      A      Y #>    <int> <int> <num> <lgcl> <lgcl> #> 1:     1     1    17  FALSE  FALSE #> 2:     1    17    19   TRUE   TRUE #> 3:     2     1    56  FALSE  FALSE #> 4:     2    56    75   TRUE   TRUE #> 5:     3     1    83  FALSE  FALSE #> 6:     3    83   103   TRUE  FALSE library(\"survival\") mod <- coxph(Surv(start, stop, Y) ~ A, data=dat) summary(mod) #> Call: #> coxph(formula = Surv(start, stop, Y) ~ A, data = dat) #>  #>   n= 24969, number of events= 9864  #>  #>          coef exp(coef) se(coef)     z Pr(>|z|)     #> ATRUE 1.15063   3.16018  0.02377 48.41   <2e-16 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>  #>       exp(coef) exp(-coef) lower .95 upper .95 #> ATRUE      3.16     0.3164     3.016     3.311 #>  #> Concordance= 0.581  (se = 0.002 ) #> Likelihood ratio test= 1901  on 1 df,   p=<2e-16 #> Wald test            = 2343  on 1 df,   p=<2e-16 #> Score (logrank) test = 2606  on 1 df,   p=<2e-16 prob_vacc <- function(data, P_0) {   fifelse(data$Y_event, 0, P_0) }  dag <- empty_dag() +   node_td(\"A\", type=\"time_to_event\", prob_fun=prob_vacc,           event_duration=20, immunity_duration=150, P_0=0.01) +   node_td(\"Y\", type=\"time_to_event\", prob_fun=prob_myoc,           parents=c(\"A_event\"), P_0=0.005, RR_A=3.24,           event_duration=80)"},{"path":"https://robindenz1.github.io/simDAG/articles/simDAG.html","id":"additionally-supported-features","dir":"Articles","previous_headings":"Simulating longitudinal data with many points in time","what":"Additionally supported features","title":"Simulating Complex Crossectional and Longitudinal Data using the simDAG R Package","text":"example shown illustrates small fraction possible features included DGP using discrete-time simulation algorithm implemented proposed package. name features theoretically added DGP. Examples actually implement extensions given appendix. Time-Dependent Probabilities Effects: example base probabilities relative risks always set constant, regardless simulation time. may also changed re-defining prob_fun argument named argument called sim_time. Internally, current time simulation passed directly prob_fun, allowing users define time-dependencies. Non-Linear Effects: , considered simple scenario probability event occurrence another event follows simple step function, e.g., set P0P_0 general increased fixed factor fixed duration event. may also changed using complex definitions prob_fun based _event column exposure, directly time occurrence. Adding Binary Time-Dependent Variables: two time-dependent variables considered example. course possible add many variables desired user simply adding appropriate node_td() calls DAG object. sim_discrete_time() function sim2data() function still work exactly described earlier. Adding Baseline Covariates: course also possible define DAG contains time-independent time-dependent variables time. can achieved adding nodes node() node_td() function. Data time-independent variables generated first (t=0t = 0) time-dependent simulation performed , albeit possibly dependent time-independent variables. Adding Categorical Time-Dependent Variables: Sometimes may appropriate describe time-varying variable using two classes. theses cases, proposed package also includes \"competing_events\" node type, similar \"time_to_event\" node type. difference instead Bernoulli trials multinomial trials performed point time individuals, allowing generation mutually exclusive events. Adding Arbitrarily Distributed Time-Dependent Variables: sim_from_dag() function, kind function may used type time-dependent variables. appropriately defining , possible generate count continuous time-varying variables well. Adding Ordered Events: events possible something else already happened. example, person usually receive PhD graduating high school. type data may also generated, appropriately specifying required probability functions. mentioned shown features may course used arbitrary combinations. Additionally, list meant exhaustive. merely supposed highlight versatile implemented approach .","code":""},{"path":"https://robindenz1.github.io/simDAG/articles/simDAG.html","id":"computational-considerations","dir":"Articles","previous_headings":"Simulating longitudinal data with many points in time","what":"Computational considerations","title":"Simulating Complex Crossectional and Longitudinal Data using the simDAG R Package","text":"Although discrete-time simulation procedure described incredibly flexible, also computationally expensive theoretically. example, using nodes type \"time_to_event\". shown , program re-calculate event probabilities point time, every individual every node. Increasing either number nodes, number time points number considered individuals therefore non-linearly increases number required computations. fact, together lack available appropriate software packages, probably main reason type simulation strategy rarely used Monte-Carlo simulation studies. Since Monte-Carlo studies often require thousands replications hundreds different scenarios, even runtime seconds generate dataset may long keep simulation computationally feasible. presented implementation therefore designed explicitly fast possible. ensure can run multiple processing cores parallel, additionally designed use little random access memory (RAM) possible. code package, exclusively uses data.table package (Barrett et al. 2024) perform required computations. data.table package arguably best choice data wrangling R ecosystem terms computational efficiency similar performance corresponding software libraries R Julia (Chiou, Xu, Huang 2023). proposed package additionally relies tricks keep amount memory used small. example, using nodes type \"time_to_event\", default every state simulation saved. times event occurred recorded. information efficiently pieced together sim2data() function creating actual dataset. Although none code optimizations can entirely overcome inherent computational complexity approach, ensure usage method feasible generate reasonably large data many points time regular office computer. example, generating dataset 1000 individuals 730 distinct points time first DAG, shown Section containing Covid example, takes 1.11 seconds average authors personal computer, using single processing core (Intel(R) Core(TM) i7-9700 CPU @ 3.00GHz, 32GB RAM). , however, also important note runtime highly depends efficient functions supplied prob_fun arguments written well. give additional limited code illustrate increased runtime sim_discrete_time() function increasing n_sim increasing max_t values. example, use first DGP shown Section Covid example generate data multiple different values argument. include calls sim2data() function runtime calculations, calling function necessary obtain usable data considered part DGP. runtime calculated using microbenchmark package (Mersmann 2023).  runtime increases sharply higher values max_t higher values n_sim, additional considered point time internally translates one iteration R loop, additional considered individual translates one row generated data, processed using optimized data.table code directly.","code":"# NOTE: This part of the code is not run here, because it would take too long # on CRAN and would introduce another dependency on the \"microbenchmark\" # package. Results may also vary depending on the hardware this is run on.  library(microbenchmark)  set.seed(1234)  prob_myoc <- function(data, P_0, RR_A) {   fifelse(data$A_event, P_0*RR_A, P_0) }  run_example <- function(n, max_t) {   dag <- empty_dag() +     node_td(\"A\", type=\"time_to_event\", prob_fun=0.01,             event_duration=20, immunity_duration=150) +     node_td(\"Y\", type=\"time_to_event\", prob_fun=prob_myoc,             parents=c(\"A_event\"), P_0=0.005, RR_A=3.24)    sim <- sim_discrete_time(dag, n_sim=n, max_t=max_t)    dat <- sim2data(sim, to=\"start_stop\", target_event=\"Y\",                   keep_only_first=TRUE, overlap=TRUE) }  n <- c(10, 100, 1000, 10000, 100000) max_t <- c(10, 100, 1000, 10000)  params <- data.frame(max_t=rep(max_t, each=length(n)),                      n=rep(n), time=NA)  for (i in seq_len(nrow(params))) {   n_i <- params$n[i]   max_t_i <- params$max_t[i]    bench <- microbenchmark(run_example(n=n_i, max_t=max_t_i),                           times=1)   params$time[i] <- mean(bench$time / 1000000000) }  params <- within(params, {   max_t <- factor(max_t) })  ggplot(params, aes(x=n, y=time, color=max_t)) +   geom_point() +   geom_line() +   theme_bw() +   labs(x=\"n_sim\", y=\"Runtime in Seconds\", color=\"max_t\") +   scale_x_continuous(labels=scales::label_comma(),                      transform=\"log10\") +   scale_y_log10()"},{"path":"https://robindenz1.github.io/simDAG/articles/simDAG.html","id":"discussion","dir":"Articles","previous_headings":"","what":"Discussion","title":"Simulating Complex Crossectional and Longitudinal Data using the simDAG R Package","text":"article presented simDAG R package illustrated can used generate various forms artificial data may required Monte-Carlo simulation studies. particular, showed package may used generate crossectional longitudinal data multiple variables different data types, non-linear effects arbitrary causal dependencies. showed similar syntax different kinds DGP closely required code resembles actual underlying structural equations using built-node types. package based defining DAG describe DGP, lends particularly well simulation studies dealing causal inference, means limited applications field, shown second last Section article. addition main data generation functions, package also includes multiple functions facilitate accurate description underlying DGP. descriptions great importance facilitate understanding reproducibility simulation studies, emphasized literature (Morris, White, Crowther 2019; Cheng et al. 2016). Among plot.DAG() function, used throughout article graphically display defined DAG objects. function useful , users may prefer use one many options display DAGs R (Pitts Fowler 2024). make easier users package also contains dag2matrix() function, returns underlying adjacency matrix DAG object .igraph.DAG() function direct integration igraph R package (Csárdi et al. 2024). Additionally, summary.DAG() method may used directly print used structural equations, shown throughout article. distinguishing feature package capability carrying discrete-time simulations generate longitudinal data hundreds points time suitable amount time. packages, simcausal package (Sofrygin, van der Laan, Neugebauer 2017) offer similar features generate crossectional data, ’ implementation generation longitudinal data different proposed package. simcausal new node defined point time internally. Although user direct access nodes (therefore value point time), provided formula interface naturally support definition nodes events occur point time last certain amount time. can done little effort simDAG package using provided \"time_to_event\" node type. type node can used specify outcomes specify binary time-varying covariates, illustrated main text used two nodes describe Covid-19 vaccination status associated adverse event. Using just node type therefore possible define DGPs including time--event outcome (possibly recurrent events) multiple time-varying covariates. multiple methods generate forms time--event data time-varying covariates (Hendry 2013; Austin 2012; Huang et al. 2020; Ngwa et al. 2022), require strict parametrizations support use multiple, arbitrarily distributed time-varying variables. Additionally, neither methods allows inclusion recurrent events competing events. None restrictions apply discrete-time simulation approach. However, method also two main disadvantages. First, lot computationally expensive methods, secondly usually require user define appropriate functions generate time- individual specific probabilities per node. Although inherent computational complexity removed, alleviated implementation package use optimized code data.table back-end (Barrett et al. 2024). shown article, presented implementation allows generation large datasets reasonable amount time. computationally efficient alternative considered package discrete-event simulation (Banks et al. 2014), time next event modeled directly instead simulating entire process time. Performing simulations , however, usually lot demanding conceptually terms required software development (X. Zhang 2018). burden specifying appropriate input prob_fun argument approach comparatively small, might still concern users. hope many provided examples explanations article extensive documentation multiple vignettes package help users overcome issue. keep article reasonable length, necessary omit implemented features simDAG package. One features capability generate data complex multi-level DGPs. internally using code simr package (Green MacLeod 2016), allows users add arbitrarily complex random effects random slopes nodes type \"gaussian\", \"binomial\" \"poisson\". can done directly adding standard mixed model R syntax formula interface. Additionally, main focus package generating data user-defined DGP, package offers limited support generating data mimics already existing data dag_from_data() function. function requires user specify causal dependencies assumed present data type node directly extracts coefficients intercepts available data fitting various models . returned DAG fully specified can used directly standard sim_from_dag() call obtain data similar one supplied. Note function directly support available node types. main goal user generate synthetic mimicked datasets, using packages simPop (Templ et al. 2017) might preferable. Finally, like note package still active development. currently working multiple new features make package even versatile users. example, future versions package planned support definition interventions DAG, much like simcausal package (Sofrygin, van der Laan, Neugebauer 2017), make even easier generate data causal inference based simulations, without re-define DAG multiple times. also plan extend internal library available node types, example including node functions simulate competing events data without use discrete-time simulation (Moriña Navarro 2017; Haller Ulm 2014).","code":""},{"path":"https://robindenz1.github.io/simDAG/articles/simDAG.html","id":"computational-details","dir":"Articles","previous_headings":"","what":"Computational details","title":"Simulating Complex Crossectional and Longitudinal Data using the simDAG R Package","text":"results paper obtained using R 4.5.2 data.table 1.17.8 package, survival 3.8.3 package, igraph 2.2.1 package, ggplot2 4.0.1 package simDAG 0.4.1.9000 package. R packages used available Comprehensive R Archive Network (CRAN) https://CRAN.R-project.org/.","code":""},{"path":"https://robindenz1.github.io/simDAG/articles/simDAG.html","id":"acknowledgments","dir":"Articles","previous_headings":"","what":"Acknowledgments","title":"Simulating Complex Crossectional and Longitudinal Data using the simDAG R Package","text":"like thank Katharina Meiszl valuable input contributing unit tests input checks proposed package. also like thank anonymous reviewers, whose feedback suggestions greatly improved manuscript package .","code":""},{"path":"https://robindenz1.github.io/simDAG/articles/simDAG.html","id":"appendix-a-further-features-of-discrete-time-simulation","dir":"Articles","previous_headings":"","what":"Appendix A: Further Features of Discrete-Time Simulation","title":"Simulating Complex Crossectional and Longitudinal Data using the simDAG R Package","text":"mentioned main text, lot possible features included DGP using discrete-time simulation approach, shown main text. give simple examples use discrete-time simulation approach implemented simDAG package generate artificial data useful features. examples, first DGP shown Covid example Section extended.","code":""},{"path":"https://robindenz1.github.io/simDAG/articles/simDAG.html","id":"time-dependent-base-probabilities","dir":"Articles","previous_headings":"Appendix A: Further Features of Discrete-Time Simulation","what":"Time-Dependent Base Probabilities","title":"Simulating Complex Crossectional and Longitudinal Data using the simDAG R Package","text":"make PY0P_{Y0} time-dependent, sim_time argument may used change definition function generates myocarditis probabilities. following code gives example : example, base probability myocarditis grows 0.001 passing day, relative risk infection given vaccination stays constant. complex time-dependencies may course implemented well. procedure also used make vaccination probabilities time-dependent well.","code":"prob_myoc <- function(data, P_0, RR_A, sim_time) {   P_0 <- P_0 + 0.001*sim_time   fifelse(data$A_event, P_0*RR_A, P_0) }  dag <- empty_dag() +   node_td(\"A\", type=\"time_to_event\", prob_fun=0.01,           event_duration=20, immunity_duration=150) +   node_td(\"Y\", type=\"time_to_event\", prob_fun=prob_myoc,           parents=c(\"A_event\"), P_0=0.005, RR_A=3.24)  sim <- sim_discrete_time(dag, n_sim=100, max_t=200) data <- sim2data(sim, to=\"start_stop\") head(data) #>      .id start  stop      A      Y #>    <int> <int> <num> <lgcl> <lgcl> #> 1:     1     1    27  FALSE  FALSE #> 2:     1    28    28  FALSE   TRUE #> 3:     1    29    32  FALSE  FALSE #> 4:     1    33    33  FALSE   TRUE #> 5:     1    34    63  FALSE  FALSE #> 6:     1    64    64  FALSE   TRUE"},{"path":"https://robindenz1.github.io/simDAG/articles/simDAG.html","id":"time-dependent-effects","dir":"Articles","previous_headings":"Appendix A: Further Features of Discrete-Time Simulation","what":"Time-Dependent Effects","title":"Simulating Complex Crossectional and Longitudinal Data using the simDAG R Package","text":"scenarios may also required make effect vary time. , make size relative risk developing myocarditis given recent Covid-19 vaccination dependent calender time, using sim_time argument respective prob_fun: , relative risk increases 0.01 passing day, meaning risk myocarditis given recent vaccination increases time.","code":"prob_myoc <- function(data, P_0, RR_A, sim_time) {   RR_A <- RR_A + 0.01*sim_time   fifelse(data$A_event, P_0*RR_A, P_0) }  dag <- empty_dag() +   node_td(\"A\", type=\"time_to_event\", prob_fun=0.01,           event_duration=20, immunity_duration=150) +   node_td(\"Y\", type=\"time_to_event\", prob_fun=prob_myoc,           parents=c(\"A_event\"), P_0=0.005, RR_A=3.24)  sim <- sim_discrete_time(dag, n_sim=100, max_t=200) data <- sim2data(sim, to=\"start_stop\") head(data) #>      .id start  stop      A      Y #>    <int> <int> <num> <lgcl> <lgcl> #> 1:     1     1    16  FALSE  FALSE #> 2:     1    17    17  FALSE   TRUE #> 3:     1    18    44  FALSE  FALSE #> 4:     1    45    45  FALSE   TRUE #> 5:     1    46   139  FALSE  FALSE #> 6:     1   140   140  FALSE   TRUE"},{"path":"https://robindenz1.github.io/simDAG/articles/simDAG.html","id":"non-linear-effects","dir":"Articles","previous_headings":"Appendix A: Further Features of Discrete-Time Simulation","what":"Non-Linear Effects","title":"Simulating Complex Crossectional and Longitudinal Data using the simDAG R Package","text":"previous examples, assumed effect vaccination probability developing myocarditis follows step-function. risk instantly elevated constant factor (RRARR_A) vaccination, lasts specified amount time instantly drops back baseline risk. kind relationship may also simulated, changing prob_myoc() function accordingly. following code may used: code, RRARR_A decreases day person vaccinated. contrast previous example, happens person-specific time-scale total calender time level. properly, set time_since_last argument inside node_td() call vaccination definition TRUE. argument supported using nodes type \"time_to_event\". adds another column dataset includes time since last vaccination performed individual. column also added parents vector, can use prob_myoc() function. simply substract 0.1 RRARR_A day vaccination. essentially means day vaccination , relative risk 3.24 specified DAG. first day vaccination, however, relative risk 3.14 forth. words, extent adverse effect vaccination decreases time linearly. , complex functions may also used model type non-linear effects.","code":"prob_myoc <- function(data, P_0, RR_A) {   RR_A <- RR_A - 0.1*data$A_time_since_last   fifelse(data$A_event, P_0*RR_A, P_0) }  dag <- empty_dag() +   node_td(\"A\", type=\"time_to_event\", prob_fun=0.01,           event_duration=20, immunity_duration=150,           time_since_last=TRUE) +   node_td(\"Y\", type=\"time_to_event\", prob_fun=prob_myoc,           parents=c(\"A_event\", \"A_time_since_last\"),           P_0=0.005, RR_A=3.24)  sim <- sim_discrete_time(dag, n_sim=100, max_t=200) data <- sim2data(sim, to=\"start_stop\") head(data) #>      .id start  stop      A      Y #>    <int> <int> <num> <lgcl> <lgcl> #> 1:     1     1   119  FALSE  FALSE #> 2:     1   120   120  FALSE   TRUE #> 3:     1   121   147  FALSE  FALSE #> 4:     1   148   148  FALSE   TRUE #> 5:     1   149   152  FALSE  FALSE #> 6:     1   153   172   TRUE  FALSE"},{"path":"https://robindenz1.github.io/simDAG/articles/simDAG.html","id":"multiple-interrelated-binary-time-dependent-variables","dir":"Articles","previous_headings":"Appendix A: Further Features of Discrete-Time Simulation","what":"Multiple Interrelated Binary Time-Dependent Variables","title":"Simulating Complex Crossectional and Longitudinal Data using the simDAG R Package","text":"Another possibility extent DGP add \"time_to_event\" variables. example, may want additionally consider effect Covid-19 infection , denoted CtC_t . simplicity assume Covid-19 constant probability occurrence time individuals.example assume vaccination reduces risk getting Covid-19 infection 0 dimmuned_{immune} days vaccination performed. may use following structural equation describe variable: Ct∼Bernoulli(PC(t)),     C_t \\sim Bernoulli(P_{C}(t)), : PC(t)={0,t∈[TA(t),TA(t)+dimmune]PC0,otherwise,     P_{C}(t) =     \\begin{cases}         0, & \\text{} t \\ \\left[T_{}(t), T_{}(t) + d_{immune}\\right] \\\\         P_{C0}, & \\text{otherwise}     \\end{cases}, PC0P_{C0} baseline probability experiencing Covid-19 infection TA(t)T_A(t) still defined time last Covid-19 vaccination . addition , also change definition myocarditis node (YtY_t). Instead dependent AtA_t, Covid-19 Infection now also raise probability developing myocarditis constant factor RRCRR_C dC.riskd_{C.risk} days Covid-19 infection. structural equation can changed : Yt∼Bernoulli(PY(t)),     Y_t \\sim Bernoulli(P_{Y}(t)), : PY(t)={PY0⋅RRA⋅RRC,t∈[TA(t),TA(t)+dA.risk] t∈[TA(t),TA(t)+dC.risk]PY0⋅RRC,t∈[TA(t),TA(t)+dC.risk]PY0⋅RRA,t∈[TA(t),TA(t)+dA.risk]PY0,otherwise,     P_{Y}(t) =     \\begin{cases}         P_{Y0} \\cdot RR_{} \\cdot RR_{C}, & \\text{} t \\ \\left[T_{}(t), T_{}(t) + d_{.risk}\\right] \\text{ } t \\ \\left[T_{}(t), T_{}(t) + d_{C.risk}\\right] \\\\         P_{Y0} \\cdot RR_{C}, & \\text{} t \\ \\left[T_{}(t), T_{}(t) + d_{C.risk}\\right] \\\\         P_{Y0} \\cdot RR_{}, & \\text{} t \\ \\left[T_{}(t), T_{}(t) + d_{.risk}\\right] \\\\         P_{Y0}, & \\text{otherwise}     \\end{cases}, dA.riskd_{.risk} duration vaccination risk developing myocarditis elevated RRARR_A. structural equation AA defined previous Equations. following code may used generate data DGP: code first re-define prob_myoc() function include effect Covid-19 infection. utilizes small computational trick, relying fact number power 0 1 number power 1 . Since TRUE treated 1 FALSE interpreted 0 R, can simply take relative risks power current event indicator multiply baseline risk respective relative risks currently risk durations. Next, define new function called prob_covid() include immunity duration, using time_since_last functionality. finally adding another node_td() call DAG object, able specify DGP desired way.","code":"prob_myoc <- function(data, P_0, RR_A, RR_C) {   P_0 * RR_A^(data$A_event) * RR_C^(data$C_event) }  prob_covid <- function(data, P_0, d_immune) {   fifelse(data$A_time_since_last < d_immune, 0, P_0, na=P_0) }  dag <- empty_dag() +   node_td(\"A\", type=\"time_to_event\", prob_fun=0.01,           event_duration=20, immunity_duration=150,           time_since_last=TRUE) +   node_td(\"C\", type=\"time_to_event\", prob_fun=prob_covid,           parents=c(\"A_time_since_last\"), event_duration=14,           P_0=0.01, d_immune=120) +   node_td(\"Y\", type=\"time_to_event\", prob_fun=prob_myoc,           parents=c(\"A_event\", \"A_time_since_last\", \"C_event\"),           P_0=0.005, RR_A=3.24, RR_C=2.5)  sim <- sim_discrete_time(dag, n_sim=100, max_t=200) data <- sim2data(sim, to=\"start_stop\") head(data) #>      .id start  stop      A      C      Y #>    <int> <int> <num> <lgcl> <lgcl> <lgcl> #> 1:     1     1    66  FALSE  FALSE  FALSE #> 2:     1    67    67  FALSE  FALSE   TRUE #> 3:     1    68    75  FALSE  FALSE  FALSE #> 4:     1    76    76  FALSE  FALSE   TRUE #> 5:     1    77   114  FALSE  FALSE  FALSE #> 6:     1   115   115   TRUE  FALSE  FALSE"},{"path":"https://robindenz1.github.io/simDAG/articles/simDAG.html","id":"using-baseline-covariates","dir":"Articles","previous_headings":"Appendix A: Further Features of Discrete-Time Simulation","what":"Using Baseline Covariates","title":"Simulating Complex Crossectional and Longitudinal Data using the simDAG R Package","text":"Previously, time-dependent variable included DGP. adding calls simple node() function DAG object , however, also possible additionally include time-independent variables well. Suppose want baseline probability PA0P_{A0} vaccination vary biological sex first DGP described Covid example Section. using following code: , everything kept original example, small change now add call node() adding time-dependent variables define Sex node using simple Bernoulli distribution. Additionally, now define function appropriately generates probabilities vaccination per Sex. done simply increasing P0P_0 factor 2 whenever value Sex TRUE (might stand males females). also possible add child time-independent child nodes well, left exercise interested reader.","code":"prob_myoc <- function(data, P_0, RR_A) {   fifelse(data$A_event, P_0*RR_A, P_0) }  prob_vacc <- function(data, P_0) {   fifelse(data$Sex, P_0*2, P_0) }  dag <- empty_dag() +   node(\"Sex\", type=\"rbernoulli\", p=0.4) +   node_td(\"A\", type=\"time_to_event\", prob_fun=0.01,           event_duration=20, immunity_duration=150) +   node_td(\"Y\", type=\"time_to_event\", prob_fun=prob_myoc,           parents=c(\"A_event\"), P_0=0.005, RR_A=3.24)  sim <- sim_discrete_time(dag, n_sim=100, max_t=200) data <- sim2data(sim, to=\"start_stop\") head(data) #>      .id start  stop      A      Y    Sex #>    <int> <int> <num> <lgcl> <lgcl> <lgcl> #> 1:     1     1   143  FALSE  FALSE  FALSE #> 2:     1   144   163   TRUE  FALSE  FALSE #> 3:     1   164   200  FALSE  FALSE  FALSE #> 4:     2     1     1  FALSE  FALSE   TRUE #> 5:     2     2     2  FALSE   TRUE   TRUE #> 6:     2     3     3  FALSE   TRUE   TRUE"},{"path":"https://robindenz1.github.io/simDAG/articles/simDAG.html","id":"using-categorical-time-dependent-variables","dir":"Articles","previous_headings":"Appendix A: Further Features of Discrete-Time Simulation","what":"Using Categorical Time-Dependent Variables","title":"Simulating Complex Crossectional and Longitudinal Data using the simDAG R Package","text":"previous examples included binary time-dependent variables. applications may necessary used categorical time-dependent variables. example, instead generating vaccination status binary, may want model categorical variable multiple levels, indicating kind vaccine person received (). may done using \"competing_events\" node type. simple example: \"competing_events\" node type works much way \"time_to_event\" node type, main difference instead using Bernoulli trials relies multinomial trials, equivalent drawing simple random sample unequal probabilities element. Instead supplying single probability success per person per point time, prob_fun supplied \"competing_events\" node therefore expected provide vector probabilities. example , simply define probabilities everyone regardless simulated time. first category represents “vaccination” next two categories specify vaccinations vaccines different kinds. Note code, prob_myoc() function checks whether vaccination, really make difference whether one uses \"competing_events\" \"time_to_event\" node . get useful person specific multinomial probabilities, node_multinomial() function may useful. underlying code multinomial trials bit complex code simple Bernoulli trials, using type node may lead increased runtime. node type usually useful goal generate artificial time--event data mutually exclusive types events, also known competing events competing risks data. Also note example set save_states argument sim_discrete_time() function \"\". required goal transform data start-stop format later, DGP consist solely time-dependent nodes type \"time_to_event\".","code":"prob_myoc <- function(data, P_0, RR_A) {   fifelse(data$A_event > 0, P_0*RR_A, P_0) }  prob_vacc <- function(data) {   n <- nrow(data)   p_mat <- matrix(c(rep(0.99, n), rep(0.0005, n),                     rep(0.0005, n)),                   byrow=FALSE, ncol=3)   return(p_mat) }  dag <- empty_dag() +   node_td(\"A\", type=\"competing_events\", prob_fun=prob_vacc,           event_duration=c(20, 20), immunity_duration=150) +   node_td(\"Y\", type=\"time_to_event\", prob_fun=prob_myoc,           parents=c(\"A_event\"), P_0=0.005, RR_A=3.24)  sim <- sim_discrete_time(dag, n_sim=100, max_t=200,                          save_states=\"all\") data <- sim2data(sim, to=\"start_stop\") head(data) #>      .id start  stop     A      Y #>    <int> <int> <int> <num> <lgcl> #> 1:     1     1   200     0  FALSE #> 2:     2     1   172     0  FALSE #> 3:     2   173   173     0   TRUE #> 4:     2   174   200     0  FALSE #> 5:     3     1   108     0  FALSE #> 6:     3   109   109     0   TRUE"},{"path":"https://robindenz1.github.io/simDAG/articles/simDAG.html","id":"using-continuous-time-dependent-variables","dir":"Articles","previous_headings":"Appendix A: Further Features of Discrete-Time Simulation","what":"Using Continuous Time-Dependent Variables","title":"Simulating Complex Crossectional and Longitudinal Data using the simDAG R Package","text":"also possible use continuous variables time-dependent variables proposed package. following code gives simple example: example, first generate normally distributed root node called calories using standard node() call. represents value variable t=0t = 0. specify variable, code return error message t=1t = 1, value calories use subsequently defined regression model. Next, call node_td() added DAG object specify variable changes step time. use simple linear regression model, independent variable last value variable . subsequent simulation set save_states=\"\" specify data points time saved. necessary DAG consists time-dependent nodes type \"time_to_event\", variable changes every point time every individual. nature data, also make sense transform data start-stop format. Instead, long format choosen .","code":"dag <- empty_dag() +   node(\"calories\", type=\"rnorm\", mean=2500, sd=150) +   node_td(\"calories\", type=\"gaussian\",           formula= ~ 1 + calories*1.1, error=1)  sim <- sim_discrete_time(dag, n_sim=100, max_t=200,                          save_states=\"all\") data <- sim2data(sim, to=\"long\") head(data) #> Key: <.id, .time> #>      .id .time calories #>    <int> <int>    <num> #> 1:     1     1 2501.065 #> 2:     1     2 2751.109 #> 3:     1     3 3027.282 #> 4:     1     4 3329.963 #> 5:     1     5 3664.729 #> 6:     1     6 4030.849"},{"path":"https://robindenz1.github.io/simDAG/articles/simDAG.html","id":"ordered-events","dir":"Articles","previous_headings":"Appendix A: Further Features of Discrete-Time Simulation","what":"Ordered Events","title":"Simulating Complex Crossectional and Longitudinal Data using the simDAG R Package","text":"following code gives example events simulated specific order events always respected: specification, try simulate educational status person time. assume individuals can obtain bachelors degree finished high school can receive masters degree finished bachelors degree. keep order events tact, can split variable three constituent parts. First, indicator whether someone graduated highschool simulated using simple Bernoulli trials implemented \"time_to_event\" node type. setting event_duration=Inf, ensure one ever “looses” degree. afterwards generate whether person also received bachelors degree. using standard fifelse() call, can easily specify probability obtaining bachelors degree 0 individuals without highschool degree. Subsequently, masters node. , simulation made much realistic. example, example used limitations close different graduations can . individual might receive three degrees time unit. changed using sim_time argument definition probability functions, discussed earlier.","code":"prob_bachelors <- function(data) {   fifelse(data$highschool_event, 0.01, 0) }  prob_masters <- function(data) {   fifelse(data$bachelors_event, 0.01, 0) }  dag <- empty_dag() +   node_td(\"highschool\", type=\"time_to_event\", prob_fun=0.01,           event_duration=Inf) +   node_td(\"bachelors\", type=\"time_to_event\", prob_fun=prob_bachelors,           event_duration=Inf, parents=\"highschool_event\") +   node_td(\"masters\", type=\"time_to_event\", prob_fun=prob_masters,           event_duration=Inf, parents=\"bachelors_event\")  sim <- sim_discrete_time(dag, n_sim=100, max_t=200) data <- sim2data(sim, to=\"start_stop\") head(data) #>      .id start  stop highschool bachelors masters #>    <int> <int> <num>     <lgcl>    <lgcl>  <lgcl> #> 1:     1     1   200      FALSE     FALSE   FALSE #> 2:     2     1     6      FALSE     FALSE   FALSE #> 3:     2     7   200       TRUE     FALSE   FALSE #> 4:     3     1    80      FALSE     FALSE   FALSE #> 5:     3    81   142       TRUE     FALSE   FALSE #> 6:     3   143   180       TRUE      TRUE   FALSE"},{"path":[]},{"path":"https://robindenz1.github.io/simDAG/articles/v_cookbook.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"simDAG Cookbook","text":"simDAG package can used generate kinds data, shown many examples vignettes package. vignette illustrate capabilities package, giving short simplified examples use simDAG generate multiple different kinds data. vignette can seen sort “cookbook”, sense includes building blocks many different possible data generation processes (DGP), users can expand specific needs. Note examples shown meant realistic, meant show general structure required code. vignette assumes reader already somewhat familiar simDAG syntax. detailed explanations simulate data using time-fixed DAG DAGs including time-dependent variables given vignettes documentation functions. recommend consulting vignettes first get feeling required syntax diving specific examples.","code":"library(simDAG) library(data.table) library(survival)  set.seed(23414)"},{"path":"https://robindenz1.github.io/simDAG/articles/v_cookbook.html","id":"simulating-randomized-controlled-trials","dir":"Articles","previous_headings":"","what":"Simulating Randomized Controlled Trials","title":"simDAG Cookbook","text":"First, give examples data randomized controlled trials (RCT) generated. classic RCT, treatment interest (named Treatment) randomly assigned individuals study, making “root node” (variable direct causes) terminology DAGs.","code":""},{"path":"https://robindenz1.github.io/simDAG/articles/v_cookbook.html","id":"two-treatment-groups","dir":"Articles","previous_headings":"Simulating Randomized Controlled Trials","what":"Two Treatment Groups","title":"simDAG Cookbook","text":"example RCT two treatment groups, binary outcome two baseline covariates (Age Sex):","code":"dag <- empty_dag() +   node(\"Age\", type=\"rnorm\", mean=55, sd=5) +   node(\"Sex\", type=\"rbernoulli\", p=0.5) +   node(\"Treatment\", type=\"rbernoulli\", p=0.5) +   node(\"Outcome\", type=\"binomial\",        formula= ~ -12 + Age*0.2 + Sex*1.1 + Treatment*-0.5)  data <- sim_from_dag(dag, n_sim=1000) head(data) #>         Age    Sex Treatment Outcome #>       <num> <lgcl>    <lgcl>  <lgcl> #> 1: 52.44476   TRUE      TRUE   FALSE #> 2: 54.20709   TRUE     FALSE   FALSE #> 3: 56.40461   TRUE      TRUE    TRUE #> 4: 50.26406  FALSE     FALSE   FALSE #> 5: 61.16070   TRUE      TRUE    TRUE #> 6: 60.00081   TRUE      TRUE    TRUE"},{"path":"https://robindenz1.github.io/simDAG/articles/v_cookbook.html","id":"three-or-more-treatment-groups","dir":"Articles","previous_headings":"Simulating Randomized Controlled Trials","what":"Three or More Treatment Groups","title":"simDAG Cookbook","text":"example earlier can easily made little complex, including three treatment groups instead just two. can achieved using rcategorical() function node type instead rbernoulli() function. setting probs=c(0.33333, 0.33333, 0.33333), treatment group choosen probability 0.33333, meaning resulting groups roughly equal size expectation.","code":"dag <- empty_dag() +   node(\"Age\", type=\"rnorm\", mean=55, sd=5) +   node(\"Sex\", type=\"rbernoulli\", p=0.5, output=\"numeric\") +   node(\"Treatment\", type=\"rcategorical\", probs=c(0.33333, 0.33333, 0.33333),        labels=c(\"Placebo\", \"Med1\", \"Med2\"), output=\"factor\") +   node(\"Outcome\", type=\"binomial\",        formula= ~ -12 + Age*0.2 + Sex*1.1 + TreatmentMed1*-0.5 +           TreatmentMed2*-1)  data <- sim_from_dag(dag, n_sim=1000) head(data) #>         Age   Sex Treatment Outcome #>       <num> <num>    <fctr>  <lgcl> #> 1: 57.72406     1      Med1   FALSE #> 2: 60.79561     0   Placebo    TRUE #> 3: 58.59577     1   Placebo    TRUE #> 4: 48.17102     1      Med1   FALSE #> 5: 57.22410     0      Med1    TRUE #> 6: 60.58842     0      Med2   FALSE"},{"path":"https://robindenz1.github.io/simDAG/articles/v_cookbook.html","id":"multiple-outcome-measurements","dir":"Articles","previous_headings":"Simulating Randomized Controlled Trials","what":"Multiple Outcome Measurements","title":"simDAG Cookbook","text":"previous two examples assumed single fixed time binary outcome measured. switch things bit using continuous outcome measured 5 different points time baseline. syntax nearly , major difference now use node_td() call define outcome, time-dependent. Additionally, inclusion time-dependent node, use sim_discrete_time() function instead sim_from_dag() function. Finally, sim2data() called obtain desired output long-format.","code":"dag <- empty_dag() +   node(\"Age\", type=\"rnorm\", mean=55, sd=5) +   node(\"Sex\", type=\"rbernoulli\", p=0.5, output=\"numeric\") +   node(\"Treatment\", type=\"rbernoulli\", p=0.5) +   node_td(\"Outcome\", type=\"gaussian\",           formula= ~ -12 + Age*0.2 + Sex*1.1 + Treatment*-0.5, error=1)  sim <- sim_discrete_time(dag, n_sim=1000, max_t=5, save_states=\"all\") data <- sim2data(sim, to=\"long\") head(data) #> Key: <.id, .time> #>      .id .time      Age   Sex Treatment   Outcome #>    <int> <int>    <num> <num>    <lgcl>     <num> #> 1:     1     1 61.94304     1     FALSE 1.8466496 #> 2:     1     2 61.94304     1     FALSE 0.7907009 #> 3:     1     3 61.94304     1     FALSE 3.3109942 #> 4:     1     4 61.94304     1     FALSE 0.6094475 #> 5:     1     5 61.94304     1     FALSE 0.5008469 #> 6:     2     1 56.87963     1      TRUE 0.8499893"},{"path":"https://robindenz1.github.io/simDAG/articles/v_cookbook.html","id":"non-compliance-to-treatment-assignment","dir":"Articles","previous_headings":"Simulating Randomized Controlled Trials","what":"Non-Compliance to Treatment Assignment","title":"simDAG Cookbook","text":"Previously assumed treatment assigned baseline never changed throughout study. real RCTs, individuals often assigned treatment strategies instead (example: one pill per week). individuals might adhere assigned treatment strategy, example “switching back” taking pill. following code shows one possible way simulate data. shown DGP, individuals assigned treatment strategy baseline. , Treatment = FALSE refers control condition individual take pills. intervention group (Treatment = TRUE), however, individual assigned take pill every week. average, 5% individuals stop taking pills passing week. stop, never start taking . continuous outcome observation time depends many pills individual took total. None individuals control group start taking pills. simplicity, simulation run without covariates 5 weeks. DAG essentially means first, Treatment_event column generated, includes assigned treatment baseline. called Treatment_event instead just Treatment, value column updated iteration nodes type \"time_to_event\" always split node two columns: status time. setting event_count=TRUE node_td() call Treatment node, count amount pills taken tt directly calculated point time (column Treatment_event_count), can used directly generate Outcome node. simulation made realistic (just complex), example adding either following things: making probability switching dependent outcome t−1t - 1 making probability switching dependent variables allowing patients switch back taking pill discontinuation allowing patients control group switch treatment additions left exercise user.","code":"# function to calculate the probability of taking the pill at t, # given the current treatment status of the person prob_treat <- function(data) {   fifelse(!data$Treatment_event, 0, 0.95) }  dag <- empty_dag() +   node(\"Treatment_event\", type=\"rbernoulli\", p=0.5) +   node_td(\"Treatment\", type=\"time_to_event\", parents=c(\"Treatment_event\"),           prob_fun=prob_treat, event_count=TRUE, event_duration=1) +   node_td(\"Outcome\", type=\"gaussian\", formula= ~ -2 +              Treatment_event_count*-0.3, error=2) sim <- sim_discrete_time(dag, n_sim=1000, max_t=5, save_states=\"all\") data <- sim2data(sim, to=\"long\") head(data) #> Key: <.id, .time> #>      .id .time Treatment    Outcome Treatment_event_count #>    <int> <int>    <lgcl>      <num>                 <num> #> 1:     1     1      TRUE -3.4368080                     1 #> 2:     1     2      TRUE -0.5167935                     2 #> 3:     1     3      TRUE -4.4188412                     3 #> 4:     1     4      TRUE -2.9598534                     4 #> 5:     1     5      TRUE -1.0813427                     5 #> 6:     2     1     FALSE -1.7865979                     0"},{"path":"https://robindenz1.github.io/simDAG/articles/v_cookbook.html","id":"with-cluster-randomization","dir":"Articles","previous_headings":"Simulating Randomized Controlled Trials","what":"With Cluster Randomization","title":"simDAG Cookbook","text":"Instead randomly assigning individuals treatment, many trials actually randomly assign treatment level clinics forms clusters, fittingly called cluster randomization. may implemented simDAG using following syntax: DGP, individual randomly assigned one 50 Clinics equal probability. patients clinics numbered 0-24 assigned control group, patients assigned treatment group. outcome generated using Poisson regression random intercept based clinic.","code":"dag <- empty_dag() +   node(\"Clinic\", type=\"rcategorical\", probs=rep(0.02, 50)) +   node(\"Treatment\", type=\"identity\", formula= ~ Clinic >= 25) +   node(\"Outcome\", type=\"poisson\", formula= ~ -1 + Treatment*4 + (1|Clinic),        var_corr=0.5) data <- sim_from_dag(dag, n_sim=1000) head(data) #>    Clinic Treatment Outcome #>     <int>    <lgcl>   <int> #> 1:     16     FALSE       0 #> 2:     11     FALSE       0 #> 3:     41      TRUE      26 #> 4:     36      TRUE      61 #> 5:     30      TRUE      12 #> 6:     13     FALSE       0"},{"path":"https://robindenz1.github.io/simDAG/articles/v_cookbook.html","id":"simulating-observational-studies","dir":"Articles","previous_headings":"","what":"Simulating Observational Studies","title":"simDAG Cookbook","text":"previous examples, variable interest treatment randomly assigned depend variables (excluding Clinic cluster randomization example). observational studies, variable interest usually randomly assigned. examples generating observational study data.","code":""},{"path":"https://robindenz1.github.io/simDAG/articles/v_cookbook.html","id":"crossectional-data","dir":"Articles","previous_headings":"Simulating Observational Studies","what":"Crossectional Data","title":"simDAG Cookbook","text":"following example, treatment probability dependent categorical continuous variable, also cause outcome: goal estimate causal effect treatment outcome, need adjust cat cont , using example linear regression model (DGP) something like inverse probability treatment weighting.","code":"dag <- empty_dag() +   node(\"cat\", type=\"rcategorical\", probs=c(0.4, 0.2, 0.2),        labels=LETTERS[1:3]) +   node(\"cont\", type=\"rbeta\", shape1=0.2, shape2=1.2) +   node(\"treatment\", type=\"binomial\",        formula= ~ -0.2 + catB*0.3 + catC*1 + cont*0.2) +   node(\"outcome\", type=\"gaussian\",        formula= ~ 3 + catB*1.1 + catC*0.2 + cont*-0.1,        error=1) data <- sim_from_dag(dag, n_sim=100) head(data) #>       cat         cont treatment  outcome #>    <char>        <num>    <lgcl>    <num> #> 1:      B 0.0485645707      TRUE 3.862287 #> 2:      C 0.4544629918      TRUE 3.426110 #> 3:      B 0.0007678235     FALSE 4.866626 #> 4:      C 0.2277772334      TRUE 3.601459 #> 5:      B 0.4191175999     FALSE 2.892944 #> 6:      B 0.1157079692      TRUE 4.361019"},{"path":"https://robindenz1.github.io/simDAG/articles/v_cookbook.html","id":"longitudinal-data","dir":"Articles","previous_headings":"Simulating Observational Studies","what":"Longitudinal Data","title":"simDAG Cookbook","text":"give small example longitudinal non-randomized study treatment tt dependent past values , past values outcome. Additionally, outcome dependent past values current treatment. use discrete-time simulation approach implemented sim_discrete_time() function achieve : simulation, individuals start treatment without experienced outcome. baseline probability get treatment 0.05 (base_p=0.05). twice likely someone got treatment last period time gets next period time (rr_treat=2), much less likely someone experienced outcome t−1t-1 start treatment (rr_outcome=0.5). Similarly, baseline probability outcome base_p=0.01, much lower probability experiencing currently receiving treatment (rr_treat=0.3) slightly higher chance experiencing t−1t-1 (rr_outcome=1.2).","code":"## function that generates the probability of treatment at t  ## for all individuals, given the current state of the simulation prob_treat <- function(data, base_p, rr_treat, rr_outcome) {   base_p * rr_treat^(data$treatment_event) * rr_outcome^(data$outcome_event) }  ## function that generates the probability of the outcome at t  ## for all individuals, given the current state of the simulation prob_outcome <- function(data, base_p, rr_treat, rr_outcome) {   base_p * rr_treat^(data$treatment_event) * rr_outcome^(data$outcome_event) }  dag <- empty_dag() +   node_td(\"treatment\", type=\"time_to_event\", prob_fun=prob_treat,           parents=c(\"outcome_event\"), event_duration=1,           base_p=0.05, rr_treat=2, rr_outcome=0.5) +   node_td(\"outcome\", type=\"time_to_event\", prob_fun=prob_outcome,           parents=c(\"treatment_event\"),           event_duration=1, immunity_duration=40,           base_p=0.01, rr_treat=0.3, rr_outcome=1.2)  sim <- sim_discrete_time(dag, n_sim=100, max_t=500) data <- sim2data(sim, to=\"start_stop\", overlap=TRUE) head(data) #>      .id start  stop treatment outcome #>    <int> <int> <num>    <lgcl>  <lgcl> #> 1:     1     1     2      TRUE   FALSE #> 2:     1     2     9     FALSE   FALSE #> 3:     1     9    10      TRUE   FALSE #> 4:     1    10    26     FALSE   FALSE #> 5:     1    26    27      TRUE   FALSE #> 6:     1    27    28     FALSE   FALSE"},{"path":"https://robindenz1.github.io/simDAG/articles/v_cookbook.html","id":"cox-model-with-time-varying-covariates","dir":"Articles","previous_headings":"Simulating Observational Studies","what":"Cox Model with Time-Varying Covariates","title":"simDAG Cookbook","text":"give small example simulating data Cox model time-dependent covariate using discrete-time simulation approach. example, one time-dependent covariate named single time--event outcome called Y. specifically, treatment causes general probability given (0.01). given, stays active 20 days. time-frame, probability developing outcome Y reduced 50%. time first occurrence Y can described Cox proportional hazards model, time-dependent variable: λ(t)=λ0(t)exp(βAA(t))\\lambda(t) = \\lambda_0(t) \\exp(\\beta_AA(t)). , λ0(t)\\lambda_0(t) baseline hazard, example constant time equal 0.01. relative risk used simulation can recovered hazard ratio, e.g. equal exp(βA)\\exp(\\beta_A). can recovered : Note estimate show exact hazard ratio 0.5, 500 individuals simulated. increasing n_sim, estimated value closer true value 0.5.","code":"## function that generates the probability of the outcome at t  ## for all individuals, given the current state of the simulation prob_Y <- function(data, base_p, rr_treat) {   base_p * rr_treat^(data$A_event) }  dag <- empty_dag() +   node_td(\"A\", type=\"time_to_event\", prob_fun=0.01,           event_duration=20) +   node_td(\"Y\", type=\"time_to_event\", prob_fun=prob_Y,           parents=c(\"A_event\"),           event_duration=Inf, base_p=0.01, rr_treat=0.5)  sim <- sim_discrete_time(dag, n_sim=500, max_t=500) data <- sim2data(sim, to=\"start_stop\", overlap=TRUE, target_event=\"Y\",                  keep_only_first=TRUE) head(data) #>      .id start  stop      A      Y #>    <int> <int> <num> <lgcl> <lgcl> #> 1:     1     1    86  FALSE   TRUE #> 2:     2     1    14  FALSE  FALSE #> 3:     2    14    34   TRUE  FALSE #> 4:     2    34   120  FALSE   TRUE #> 5:     3     1    27  FALSE  FALSE #> 6:     3    27    47   TRUE  FALSE mod <- coxph(Surv(start, stop, Y) ~ A, data=data) summary(mod) #> Call: #> coxph(formula = Surv(start, stop, Y) ~ A, data = data) #>  #>   n= 1351, number of events= 495  #>  #>          coef exp(coef) se(coef)      z Pr(>|z|)     #> ATRUE -0.9235    0.3971   0.1740 -5.308 1.11e-07 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>  #>       exp(coef) exp(-coef) lower .95 upper .95 #> ATRUE    0.3971      2.518    0.2824    0.5585 #>  #> Concordance= 0.541  (se = 0.007 ) #> Likelihood ratio test= 36.56  on 1 df,   p=1e-09 #> Wald test            = 28.17  on 1 df,   p=1e-07 #> Score (logrank) test = 30.19  on 1 df,   p=4e-08"},{"path":"https://robindenz1.github.io/simDAG/articles/v_cookbook.html","id":"aalen-additive-hazards-model-with-time-dependent-covariates","dir":"Articles","previous_headings":"Simulating Observational Studies","what":"Aalen Additive Hazards Model with Time-Dependent Covariates","title":"simDAG Cookbook","text":"Similar Cox model shown , Aalen additive hazards model time-dependent covariate defined : λ(t)=λ0(t)+βAA(t)\\lambda(t) = \\lambda_0(t) + \\beta_AA(t) main difference coefficients directly hazard difference scale log hazard ratio scale. Data model can simulated slightly adapting prob_Y() function: coefficients recovered using aalen() model timereg R package. code shown avoid unneeded dependency package.","code":"## function that generates the probability of the outcome at t  ## for all individuals, given the current state of the simulation prob_Y <- function(data, intercept, beta_treat) {   h <- intercept + beta_treat*data$A_event   return(1 - exp(-(h))) }  dag <- empty_dag() +   node_td(\"A\", type=\"time_to_event\", prob_fun=0.01,           event_duration=20) +   node_td(\"Y\", type=\"time_to_event\", prob_fun=prob_Y,           parents=c(\"A_event\"),           event_duration=Inf, intercept=0.001, beta_treat=0.05)  sim <- sim_discrete_time(dag, n_sim=500, max_t=500) data <- sim2data(sim, to=\"start_stop\", overlap=TRUE, target_event=\"Y\",                  keep_only_first=TRUE) head(data) #>      .id start  stop      A      Y #>    <int> <int> <num> <lgcl> <lgcl> #> 1:     1     1   105  FALSE   TRUE #> 2:     2     1    49  FALSE   TRUE #> 3:     3     1   254  FALSE  FALSE #> 4:     3   254   274   TRUE  FALSE #> 5:     3   274   322  FALSE  FALSE #> 6:     3   322   342   TRUE  FALSE"},{"path":[]},{"path":"https://robindenz1.github.io/simDAG/articles/v_cookbook.html","id":"simulating-multi-level-data","dir":"Articles","previous_headings":"Miscellaneous Simulations","what":"Simulating Multi-Level Data","title":"simDAG Cookbook","text":"simDAG package directly supports inclusion arbitrary mixed model syntax formula interface nodes type \"gaussian\", \"binomial\" \"poisson\", makes relatively straightforward simulate multi-level data well. following example, consider students nested different schools. outcome continuous score kind. example, single random effect school, standard deviation 0.5. example expanded include random slope age per school, exchanging (1|school) (age|school), although also need adjust var_corr argument accordingly. examples given formula vignette.","code":"dag <- empty_dag() +   node(\"school\", type=\"rcategorical\", probs=rep(0.1, 10),        labels=LETTERS[1:10]) +   node(\"female\", type=\"rbernoulli\", p=0.5) +   node(\"age\", type=\"rnorm\", mean=12, sd=3) +   node(\"score\", type=\"gaussian\",        formula= ~ -2 + female*3 + age*0.1 + (1|school),        var_corr=0.5, error=1) data <- sim_from_dag(dag, n_sim=10) head(data) #>    school female       age      score #>    <char> <lgcl>     <num>      <num> #> 1:      J   TRUE  9.060191  0.6103906 #> 2:      G   TRUE 18.758197  0.5601779 #> 3:      J   TRUE 14.948317  1.4862632 #> 4:      C  FALSE  9.978993 -3.2609397 #> 5:      D  FALSE 14.413468 -1.6006045 #> 6:      A  FALSE 13.147173 -1.4654531"},{"path":"https://robindenz1.github.io/simDAG/articles/v_cookbook.html","id":"simulating-mixture-distributions","dir":"Articles","previous_headings":"Miscellaneous Simulations","what":"Simulating Mixture Distributions","title":"simDAG Cookbook","text":"Instead using random effects random slopes, another possibility simulate sort “mixed” variables directly model using different regression models different individuals. can done using \"mixture\" node type. Consider following example: Using distr argument, can easily define simulated individuals corresponding node definitions applied . example , defined different linear regression models individuals strata==0 individuals strata==1. also possible use entirely different node types etc.","code":"dag <- empty_dag() +   node(\"strata\", type=\"rbernoulli\", p=0.5) +   node(c(\"var1\", \"var2\"), type=\"rnorm\", mean=0, sd=1) +   node(\"Y\", type=\"mixture\", parents=c(\"strata\", \"var1\", \"var2\"),        distr=list(          \"strata==0\", node(\".\", type=\"gaussian\",                            formula= ~ -2 + var1*2 + var2*-0.5, error=1),          \"strata==1\", node(\".\", type=\"gaussian\",                            formula= ~ 5 + var1*-1 + var2*2.3, error=1.5)        )) data <- sim_from_dag(dag, n_sim=10) head(data) #>    strata       var1       var2          Y #>    <lgcl>      <num>      <num>      <num> #> 1:   TRUE  1.8650262  1.3216871  6.2860129 #> 2:   TRUE  0.5357810 -0.4622341  4.0256795 #> 3:  FALSE -0.5255262 -1.0383955 -0.3599495 #> 4:  FALSE -0.4952464 -0.4233173 -1.1806965 #> 5:   TRUE -0.5181156  0.6334964  6.6033972 #> 6:   TRUE  0.6530059 -1.4336485  3.1526539"},{"path":"https://robindenz1.github.io/simDAG/articles/v_cookbook.html","id":"simulating-outliers","dir":"Articles","previous_headings":"Miscellaneous Simulations","what":"Simulating Outliers","title":"simDAG Cookbook","text":"One possibility introduce kind outliers variable, defining variable contain kind mixture distribution, made two parts, similar zero-inflated models work. First, values generated general distribution. , variable exceeds value, sample different values . simple example: , first simulate 3 standard normal variables , B C, used predictor variables desired outcome Y. Y , use \"mixture\" node type, allows us define node mix multiple node types, based conditions, generated one one. set first condition TRUE, linear model next gets applied individuals first run, generating values specified linear model individuals. next run condition Y , instructing function simulate new values Y > 3. values drawn normal distribution high mean.","code":"dag <- empty_dag() +   node(c(\"A\", \"B\", \"C\"), type=\"rnorm\") +   node(\"Y\", type=\"mixture\", parents=c(\"A\", \"B\", \"C\"),        distr=list(          \"TRUE\", node(\".\", type=\"gaussian\", formula= ~ -2 + A*0.1 + B*1 + C*-2,                       error=1),          \"Y > 3\", node(\".\", type=\"rnorm\", mean=10000, sd=500)        )) data <- sim_from_dag(dag, n_sim=10000)"},{"path":"https://robindenz1.github.io/simDAG/articles/v_cookbook.html","id":"simulating-missing-values","dir":"Articles","previous_headings":"Miscellaneous Simulations","what":"Simulating Missing Values","title":"simDAG Cookbook","text":"Real data usually includes least missing values key variables. simple example users include missing values data: DAG, real values node generated first. Afterwards, indicator whether corresponding values observed drawn randomly individual node A_missing. actually observed value, denoted A_observed, generated simply using either value A_real simple NA A_missing==TRUE. missingness shown correspond missing completely random (MCAR) categorisation XX. Although might seem little cumbersome first, allow quite lot flexibility specification different missingness mechanisms. example, simulate missing random (MAR) patterns, use following code instead: , missingness A_observed MCAR, independent everything. missingness B_observed, however, MAR probability missingness dependent actually observed value A_real.","code":"dag <- empty_dag() +   node(\"A_real\", type=\"rnorm\", mean=10, sd=3) +   node(\"A_missing\", type=\"rbernoulli\", p=0.5) +   node(\"A_observed\", type=\"identity\",        formula= ~ fifelse(A_missing, NA, A_real))  data <- sim_from_dag(dag, n_sim=10) head(data) #>       A_real A_missing A_observed #>        <num>    <lgcl>      <num> #> 1: 11.556228     FALSE  11.556228 #> 2: 11.204382      TRUE         NA #> 3: 12.000508     FALSE  12.000508 #> 4:  8.320528      TRUE         NA #> 5:  5.679615     FALSE   5.679615 #> 6: 13.858496      TRUE         NA dag <- empty_dag() +   node(\"A_real\", type=\"rnorm\", mean=0, sd=1) +   node(\"B_real\", type=\"rbernoulli\", p=0.5) +   node(\"A_missing\", type=\"rbernoulli\", p=0.1) +   node(\"B_missing\", type=\"binomial\", formula= ~ -5 + A_real*0.1) +   node(\"A_observed\", type=\"identity\",        formula= ~ fifelse(A_missing, NA, A_real)) +   node(\"B_observed\", type=\"identity\",        formula= ~ fifelse(B_missing, NA, B_real))  data <- sim_from_dag(dag, n_sim=10) head(data) #>          A_real B_real A_missing B_missing   A_observed B_observed #>           <num> <lgcl>    <lgcl>    <lgcl>        <num>     <lgcl> #> 1:  0.007654443  FALSE     FALSE     FALSE  0.007654443      FALSE #> 2: -1.504186161  FALSE     FALSE     FALSE -1.504186161      FALSE #> 3:  0.402660828  FALSE     FALSE     FALSE  0.402660828      FALSE #> 4:  0.686922785  FALSE     FALSE     FALSE  0.686922785      FALSE #> 5: -0.140018261   TRUE     FALSE     FALSE -0.140018261       TRUE #> 6: -0.141692283  FALSE      TRUE     FALSE           NA      FALSE"},{"path":"https://robindenz1.github.io/simDAG/articles/v_cookbook.html","id":"simulating-measurement-error","dir":"Articles","previous_headings":"Miscellaneous Simulations","what":"Simulating Measurement Error","title":"simDAG Cookbook","text":"Measurement error refers situations variables interest measured perfectly. example, disease interest may detected 90% patients disease may falsely detected 1% patients without disease. strategy shown missing values used simulate data using simDAG: example, disease present 50% individuals. using node type=\"conditional_prob\" can easily draw new values observed disease status specifying probs argument correctly. similarly extend example make probability misclassification dependent another variable: extended example, Sex equally distributed among population (TRUE = “female” FALSE = “male”). example, probability diagnosed disease (Disease_observed) disease actually present 0.9 females 0.8 males. Similarly, probability diagnosed disease present 0.01 females 0.05 males.","code":"probs <- list(`TRUE`=0.9, `FALSE`=0.01)  dag <- empty_dag() +   node(\"Disease_real\", type=\"rbernoulli\", p=0.5) +   node(\"Disease_observed\", type=\"conditional_prob\", parents=\"Disease_real\",        probs=probs)  data <- sim_from_dag(dag, n_sim=10) head(data) #>    Disease_real Disease_observed #>          <lgcl>           <lgcl> #> 1:         TRUE             TRUE #> 2:        FALSE            FALSE #> 3:        FALSE            FALSE #> 4:        FALSE            FALSE #> 5:         TRUE             TRUE #> 6:        FALSE            FALSE # first TRUE / FALSE refers to Sex = TRUE / FALSE # second TRUE / FALSE refers to Disease = TRUE / FALSE probs <- list(TRUE.TRUE=0.9, TRUE.FALSE=0.01,               FALSE.TRUE=0.8, FALSE.FALSE=0.05)  dag <- empty_dag() +   node(\"Sex\", type=\"rbernoulli\", p=0.5) +   node(\"Disease_real\", type=\"rbernoulli\", p=0.5) +   node(\"Disease_observed\", type=\"conditional_prob\",        parents=c(\"Sex\", \"Disease_real\"), probs=probs)  data <- sim_from_dag(dag, n_sim=1000) head(data) #>       Sex Disease_real Disease_observed #>    <lgcl>       <lgcl>           <lgcl> #> 1:  FALSE        FALSE            FALSE #> 2:  FALSE         TRUE             TRUE #> 3:   TRUE        FALSE            FALSE #> 4:   TRUE        FALSE            FALSE #> 5:   TRUE         TRUE             TRUE #> 6:   TRUE        FALSE            FALSE"},{"path":"https://robindenz1.github.io/simDAG/articles/v_covid_example.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Simulating Covid-19 Vaccine Data using a Discrete-Time Simulation","text":"vignette contains -depth example use sim_discrete_time() function generate complex time--event data. Unlike vignettes, rely overly simple example . Instead, aim generate somewhat realistic data Covid-19 pandemic. particular, interested generating longitudinal data set containing Covid-19 infections, vaccines adverse side effects vaccines. aim real study create data set reasonably close real data, including measurement problems described . data generation algorithm used identify suitable data analysis strategy real data. describe slightly simplified version data generation part give detailed example sim_discrete_time() function may used effectively. Note algorithm described completely one originally used, require us include confidential data vignette, sadly impossible. also strongly recommend reading two vignettes package first.","code":""},{"path":"https://robindenz1.github.io/simDAG/articles/v_covid_example.html","id":"how-to-get-started","dir":"Articles","previous_headings":"","what":"How to get started","title":"Simulating Covid-19 Vaccine Data using a Discrete-Time Simulation","text":"Simulating data reasonably close complex real system trivial task, even using package. Dividing big task obtaining valid data generation model multiple sub-tasks great first step right direction. suggest following 7 steps :","code":""},{"path":"https://robindenz1.github.io/simDAG/articles/v_covid_example.html","id":"formulate-the-goal-of-your-research-project-in-a-detailed-fashion-","dir":"Articles","previous_headings":"How to get started","what":"1.) Formulate the goal of your research project in a detailed fashion.","title":"Simulating Covid-19 Vaccine Data using a Discrete-Time Simulation","text":"haven’t done yet, now time. Try make goal explicit possible. help deciding aspects system important can safely ignored.","code":""},{"path":"https://robindenz1.github.io/simDAG/articles/v_covid_example.html","id":"build-a-theoretical-model-of-the-system-you-want-to-simulate-","dir":"Articles","previous_headings":"How to get started","what":"2.) Build a theoretical model of the system you want to simulate.","title":"Simulating Covid-19 Vaccine Data using a Discrete-Time Simulation","text":"entails reading relevant literature writing assumptions may already system. Perhaps (usually likely) researchers tried build simulation model system (similar system). great way encode causal assumptions system time-dependent DAG, discussed vignettes.","code":""},{"path":"https://robindenz1.github.io/simDAG/articles/v_covid_example.html","id":"identify-the-parts-of-the-system-that-you-are-most-interested-in-","dir":"Articles","previous_headings":"How to get started","what":"3.) Identify the parts of the system that you are most interested in.","title":"Simulating Covid-19 Vaccine Data using a Discrete-Time Simulation","text":"Real systems incredibly complex. simulation make simplifying assumptions. building moderately detailed version theoretical model, decide aspects interest research project aren’t.","code":""},{"path":"https://robindenz1.github.io/simDAG/articles/v_covid_example.html","id":"obtain-and-analyze-real-data-","dir":"Articles","previous_headings":"How to get started","what":"4.) Obtain and analyze real data.","title":"Simulating Covid-19 Vaccine Data using a Discrete-Time Simulation","text":"simulated data correspond real data, crucial base input model actual empirical data. Using empirical data, may able derive appropriate distributions root nodes appropriate functional forms relationship considered variables.","code":""},{"path":"https://robindenz1.github.io/simDAG/articles/v_covid_example.html","id":"simulate-data-for-t-0-if-needed-","dir":"Articles","previous_headings":"How to get started","what":"5.) Simulate data for t=0t = 0 (if needed).","title":"Simulating Covid-19 Vaccine Data using a Discrete-Time Simulation","text":"specified suitable distributions relationships, generate initial data used simulation process. important check data thoroughly, used basis subsequent steps simulation. sim_from_dag() function might helpful step.","code":""},{"path":"https://robindenz1.github.io/simDAG/articles/v_covid_example.html","id":"write-functions-for-each-time-varying-node-one-at-a-time-","dir":"Articles","previous_headings":"How to get started","what":"6.) Write functions for each time-varying node, one at a time.","title":"Simulating Covid-19 Vaccine Data using a Discrete-Time Simulation","text":"time-varying node requires user written function transforms data tt data t+1t + 1. might helpful add one time-varying node time proceeding step 7.) adding variables, possible.","code":""},{"path":"https://robindenz1.github.io/simDAG/articles/v_covid_example.html","id":"inspect-the-resulting-data-for-inconsistencies-","dir":"Articles","previous_headings":"How to get started","what":"7.) Inspect the resulting data for inconsistencies.","title":"Simulating Covid-19 Vaccine Data using a Discrete-Time Simulation","text":"Validating simulation code important ensure mistakes slipped . may done fitting models relying modeling assumptions generated data checking whether models produce expected results.","code":""},{"path":"https://robindenz1.github.io/simDAG/articles/v_covid_example.html","id":"our-research-goal-and-the-theoretical-model","dir":"Articles","previous_headings":"","what":"Our research goal and the theoretical model","title":"Simulating Covid-19 Vaccine Data using a Discrete-Time Simulation","text":"Since vignette mostly concerned practical implementation discrete-time simulation approach using R-package, spend much time first 4 steps process mentioned previous section. briefly present important points.","code":""},{"path":"https://robindenz1.github.io/simDAG/articles/v_covid_example.html","id":"research-goal","dir":"Articles","previous_headings":"Our research goal and the theoretical model","what":"Research goal","title":"Simulating Covid-19 Vaccine Data using a Discrete-Time Simulation","text":"actual research goal identify suitable data analysis strategy assessment Covid-19 vaccine side-effects particular real-life data set. decided simulate data close real data possible. Using data try different analysis strategies see one performed adequately. goal vignette use parts model showcase capabilities simDAG package. information actual simulation can found first related publication (Denz et al. 2023).","code":""},{"path":"https://robindenz1.github.io/simDAG/articles/v_covid_example.html","id":"theoretical-model","dir":"Articles","previous_headings":"Our research goal and the theoretical model","what":"Theoretical model","title":"Simulating Covid-19 Vaccine Data using a Discrete-Time Simulation","text":"seemingly endless amount literature describing models Covid-19 pandemic associated Covid-19 vaccines. Trying include relevant aspects unfeasible task. deliberating literature decided include key variables. make vignette readable limited variables include essential: vaccination: time person received first vaccine. covid: Whether Covid-19 infection occurred. sickness: Whether person developed sickness interest. assume three variables vary time cause .","code":""},{"path":"https://robindenz1.github.io/simDAG/articles/v_covid_example.html","id":"implementing-the-model","dir":"Articles","previous_headings":"","what":"Implementing the model","title":"Simulating Covid-19 Vaccine Data using a Discrete-Time Simulation","text":"Instead diving deep start trying include relevant variables relevant relationships , often better build simplified version first start adding stuff continue.","code":""},{"path":"https://robindenz1.github.io/simDAG/articles/v_covid_example.html","id":"part-1-adding-vaccination-covid-and-sickness","dir":"Articles","previous_headings":"Implementing the model","what":"Part 1: Adding vaccination, covid and sickness","title":"Simulating Covid-19 Vaccine Data using a Discrete-Time Simulation","text":"important variables us vaccination, covid-19 infection sickness. variables certain probability occurrence point time. occur, last duration (e.g. someone sick two weeks something similar). event , usually duration person “immune” receiving event . perfect case using time-dependent node type \"time_to_event\". start modeling every one variables completely independent using following DAG: DAG , supplied constant value prob_fun arguments, indicating regardless time variables, event constant probability occurring day. set event_duration vaccination 21, want model time vaccination risk adverse side-effect (e.g. sickness) higher usual later . setting immunity_duration vaccination Inf, currently allowing person get one vaccination entire time. sickness allowed occur directly .","code":"library(data.table) library(ggplot2) library(simDAG)  dag <- empty_dag() +   node_td(\"vaccination\", type=\"time_to_event\", prob_fun=0.001,           event_duration=21, immunity_duration=Inf) +   node_td(\"covid\", type=\"time_to_event\", prob_fun=0.001, event_duration=30,           immunity_duration=80) +   node_td(\"sickness\", type=\"time_to_event\", prob_fun=0.0001,           event_duration=2, immunity_duration=2)"},{"path":"https://robindenz1.github.io/simDAG/articles/v_covid_example.html","id":"part-2-adding-adverse-effects-of-vaccination-and-covid","dir":"Articles","previous_headings":"Implementing the model","what":"Part 2: Adding adverse effects of vaccination and covid","title":"Simulating Covid-19 Vaccine Data using a Discrete-Time Simulation","text":"can make data-generation process little interesting making vaccination covid effect probability developing sickness. simply raising probability occurrence sickness constant factor whenever either covid vaccination event currently happening. can done formulating appropriate prob_fun sickness node: works number exponent 1 , number exponent 0 one. vaccination_event covid_event columns always either TRUE (event currently happening) FALSE (event currently happening), interpreted 1 0 R. Let’s update DAG: Instead passing constant value prob_fun argument, now passing previously defined function. function base_p, rr_covid rr_vacc arguments without defaults, specify node_td call well. keep original base_p, set relative risks 3.5 3.24 respectively. Additionally, set vaccination_event covid_event columns parents now, used prob_sickness function.","code":"prob_sickness <- function(data, rr_covid, rr_vacc, base_p) {    # multiply base probability by relevant RRs   p <- base_p * rr_vacc^(data$vaccination_event) * rr_covid^(data$covid_event)    return(p) } dag <- empty_dag() +   node_td(\"vaccination\", type=\"time_to_event\", prob_fun=0.001,           event_duration=21, immunity_duration=Inf) +   node_td(\"covid\", type=\"time_to_event\", prob_fun=0.001, event_duration=30,           immunity_duration=80) +   node_td(\"sickness\", type=\"time_to_event\", prob_fun=prob_sickness,           parents=c(\"vaccination_event\", \"covid_event\"),           base_p=0.0001, rr_covid=3.5, rr_vacc=3.24,           event_duration=2, immunity_duration=2)"},{"path":"https://robindenz1.github.io/simDAG/articles/v_covid_example.html","id":"part-3-making-the-vaccine-useful","dir":"Articles","previous_headings":"Implementing the model","what":"Part 3: Making the vaccine useful","title":"Simulating Covid-19 Vaccine Data using a Discrete-Time Simulation","text":"far assumed covid infection probability unaffected whether person received vaccine . now change implementing time-window receiving vaccine person develop covid infection. , can done defining appropriate prob_fun function, time covid node: function use column vaccination_time_since_last, column can optionally created time--event nodes setting time_since_last TRUE. let’s update DAG accordingly: Instead just updating parents prob_fun arguments covid node, now also set time_since_last argument vaccination node TRUE well get required additional column. data-generation algorithm getting better now. still lot can .","code":"prob_covid <- function(data, base_p, vacc_duration) {      p <- fifelse(data$vaccination_time_since_last < vacc_duration,                0, base_p, na=base_p)   return(p) } dag <- empty_dag() +   node_td(\"vaccination\", type=\"time_to_event\", prob_fun=0.001,           event_duration=21, immunity_duration=Inf,           time_since_last=TRUE) +   node_td(\"covid\", type=\"time_to_event\", prob_fun=prob_covid,           parents=c(\"vaccination_time_since_last\"),           base_p=0.001, vacc_duration=80, event_duration=30,           immunity_duration=80) +   node_td(\"sickness\", type=\"time_to_event\", prob_fun=prob_sickness,           parents=c(\"vaccination_event\", \"covid_event\"),           base_p=0.0001, rr_covid=3.5, rr_vacc=3.24,           event_duration=2, immunity_duration=2)"},{"path":"https://robindenz1.github.io/simDAG/articles/v_covid_example.html","id":"part-4-sick-people-dont-get-vaccinated","dir":"Articles","previous_headings":"Implementing the model","what":"Part 4: Sick people don’t get vaccinated","title":"Simulating Covid-19 Vaccine Data using a Discrete-Time Simulation","text":"reality, little people currently experiencing Covid-19 infection went got vaccine. fact, absolutely discouraged doctors world-wide. add circumstance model, simply update probability receiving vaccination, defining appropriate prob_fun: Using function, probability getting vaccinated individual currently experiencing covid infection 0. Let’s update DAG one time include changes: simply changed prob_fun argument added correct parents appropriate node. final “DAG” looks like :  Note plot doesn’t look like classic DAG anymore, bi-directional arrow covid vaccination due time-dependent nature relationship.","code":"prob_vaccination <- function(data, base_p) {      p <- fifelse(data$covid_event, 0, base_p)      return(p) } dag <- empty_dag() +   node_td(\"vaccination\", type=\"time_to_event\",           prob_fun=prob_vaccination,           parents=c(\"covid_event\"), base_p=0.001,           event_duration=21, immunity_duration=Inf,           time_since_last=TRUE) +   node_td(\"covid\", type=\"time_to_event\", prob_fun=prob_covid,           parents=c(\"vaccination_time_since_last\"),           base_p=0.001, vacc_duration=80, event_duration=30,           immunity_duration=80) +   node_td(\"sickness\", type=\"time_to_event\", prob_fun=prob_sickness,           parents=c(\"vaccination_event\", \"covid_event\"),           base_p=0.0001, rr_covid=3.5, rr_vacc=3.24,           event_duration=2, immunity_duration=2) plot(dag, mark_td_nodes=FALSE)"},{"path":"https://robindenz1.github.io/simDAG/articles/v_covid_example.html","id":"generating-data-using-the-final-model","dir":"Articles","previous_headings":"Implementing the model","what":"Generating Data using the final model","title":"Simulating Covid-19 Vaccine Data using a Discrete-Time Simulation","text":"Suppose now pleased complexity data-generation algorithm want simulate data . can simply calling sim_discrete_time() function specified DAG: exemplary purposes, kind arbitrarily used 1000 individuals let simulation run 800 days. calling plot() method, get concise overview process simulated:  useful output resulting data can obtained using sim2data() function. example, transform output start-stop format: can seen, managed implement fairly complex data-generation mechanism using small function definitions lines code, allowing us generate complex dataset three interdependent time-varying variables minimal effort.","code":"set.seed(42) sim <- sim_discrete_time(dag, n_sim=1000, max_t=800) summary(sim) #> A simDT object with: #>   -  1000  observations #>   -  800  distinct points in time #>   -  3  time-varying variables in total #>   -  3  time_to_event nodes #>   -  0  competing_events nodes #> Only the last state of the simulation was saved. plot(sim, box_text_size=4) sim2data(sim, to=\"start_stop\") #>         .id start  stop vaccination  covid sickness #>       <int> <int> <num>      <lgcl> <lgcl>   <lgcl> #>    1:     1     1   178       FALSE  FALSE    FALSE #>    2:     1   179   199        TRUE  FALSE    FALSE #>    3:     1   200   800       FALSE  FALSE    FALSE #>    4:     2     1   501       FALSE  FALSE    FALSE #>    5:     2   502   531       FALSE   TRUE    FALSE #>   ---                                               #> 3466:  1000     1    47       FALSE  FALSE    FALSE #> 3467:  1000    48    49       FALSE  FALSE     TRUE #> 3468:  1000    50   131       FALSE  FALSE    FALSE #> 3469:  1000   132   152        TRUE  FALSE    FALSE #> 3470:  1000   153   800       FALSE  FALSE    FALSE"},{"path":"https://robindenz1.github.io/simDAG/articles/v_covid_example.html","id":"going-even-further","dir":"Articles","previous_headings":"Implementing the model","what":"Going even further","title":"Simulating Covid-19 Vaccine Data using a Discrete-Time Simulation","text":"need stop . make simulation model even complex implementing following things: Adding time-dependent base-probabilities vaccination, covid sickness Adding different kinds vaccinations, perhaps different effects covid /sickness Adding time-fixed variables sex effect variables Allowing multiple vaccinations Changing constant raising probabilities form relative risk realistic non-linear time-dependent relative risk Modelling spread covid imposing network() structure individuals relax assumption individuals independent course many possible extensions, can implemented augmenting respective prob_fun arguments updating dag accordingly. fact, real Monte-Carlo simulation conducted, exactly . used empirical data model time-dependent base-probabilities . much complexity really need completely . hope simDAG package can help whatever need.","code":""},{"path":"https://robindenz1.github.io/simDAG/articles/v_covid_example.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Simulating Covid-19 Vaccine Data using a Discrete-Time Simulation","text":"Banks, Jerry, John S. Carson II, Barry L. Nelson, David M. Nicol (2014). Discrete-Event System Simulation. Vol. 5. Edinburgh Gate: Pearson Education Limited. Denz, Robin, Katharina Meiszl, Peter Ihle, Doris F. Oberle, Ursula Drechsel-Bäuerle, Katrin Scholz, Ingo Meyer Nina Timmesfeld (2023). “Impact Record-Linkage Errors Covid-19 Vaccine-Safety Analyses using German Health-Care Data: Simulation Study”. : arXiv:2310.15016","code":""},{"path":"https://robindenz1.github.io/simDAG/articles/v_custom_nodes.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Specifying Custom Node Types in a DAG","text":"small vignette, give detailed explanation define custom functions can used type argument node() node_td() calls. Although simDAG includes large number different node types can used argument directly, also allows user pass function argument, long function meets limited criteria (described ). advanced feature users probably don’t need standard simulation studies. strongly recommend reading documentation vignettes first, vignette assumes reader already familiar simDAG syntax general features. support custom functions type allows users create root nodes, child nodes time-dependent nodes directly implemented package. , users may create data functional dependence can think . requirements node type listed . simple examples node type given section. think custom node type might useful others, please contact maintainer package via supplied e-mail address github might add package.","code":"library(simDAG)  set.seed(1234)"},{"path":[]},{"path":"https://robindenz1.github.io/simDAG/articles/v_custom_nodes.html","id":"requirements","dir":"Articles","previous_headings":"Root Nodes","what":"Requirements","title":"Specifying Custom Node Types in a DAG","text":"function generates vector size n n==nrow(data), data.frame() many rows current data can used child node. requirement : 1.) function argument called n controls many samples generate. examples already implemented R outside package stats::rnorm(), stats::rgamma() stats::rbeta(). function may take amount arguments, passed three-dot (...) syntax. Note whenever supplied function produces data.frame() (similar object), user ensure included columns named properly.","code":""},{"path":"https://robindenz1.github.io/simDAG/articles/v_custom_nodes.html","id":"examples","dir":"Articles","previous_headings":"Root Nodes","what":"Examples","title":"Specifying Custom Node Types in a DAG","text":"Using external functions fulfill requirements already defined package can done way: course users may also define appropriate root node function . code defines function takes sum normally distributed random number uniformly distributed random number simulated individual:","code":"dag <- empty_dag() +   node(\"A\", type=\"rgamma\", shape=0.1, rate=2) +   node(\"B\", type=\"rbeta\", shape1=2, shape2=0.3) custom_root <- function(n, min=0, max=1, mean=0, sd=1) {   out <- runif(n, min=min, max=max) + rnorm(n, mean=mean, sd=sd)   return(out) }  # the function may be supplied as a string dag <- empty_dag() +   node(\"A\", type=\"custom_root\", min=0, max=10, mean=5, sd=2)  # equivalently, the function can also be supplied directly # This is the recommended way! dag <- empty_dag() +   node(\"A\", type=custom_root, min=0, max=10, mean=5, sd=2)  data <- sim_from_dag(dag=dag, n_sim=100) head(data) #>            A #>        <num> #> 1:  2.524972 #> 2: 10.058842 #> 3:  8.874968 #> 4:  9.203870 #> 5: 13.284535 #> 6: 12.529218"},{"path":[]},{"path":"https://robindenz1.github.io/simDAG/articles/v_custom_nodes.html","id":"requirements-1","dir":"Articles","previous_headings":"Child Nodes","what":"Requirements","title":"Specifying Custom Node Types in a DAG","text":", almost function may used generate child node. four things required work properly: 1.) ’ name start node_ (want use string define type). 2.) contain argument called data (contains already generated data). 3.) contain argument called parents (contains vector child nodes parents). 4.) return either vector length n_sim data.frame() (similar object) number columns n_sim rows. function may include amount additional arguments specified user.","code":""},{"path":"https://robindenz1.github.io/simDAG/articles/v_custom_nodes.html","id":"examples-1","dir":"Articles","previous_headings":"Child Nodes","what":"Examples","title":"Specifying Custom Node Types in a DAG","text":"define custom child node type basically just gaussian node (badly done) truncation, limiting range resulting variable left right. Please note terrible form truncation cases, artificially distorts resulting normal distribution left right values. meant illustration. another example custom child node function, simply returns sum parents: can use functions DAG like :","code":"node_gaussian_trunc <- function(data, parents, betas, intercept, error,                                 left, right) {   out <- node_gaussian(data=data, parents=parents, betas=betas,                        intercept=intercept, error=error)   out <- ifelse(out <= left, left,                 ifelse(out >= right, right, out))   return(out) } parents_sum <- function(data, parents, betas=NULL) {   out <- rowSums(data[, parents, with=FALSE])   return(out) } dag <- empty_dag() +   node(\"age\", type=\"rnorm\", mean=50, sd=4) +   node(\"sex\", type=\"rbernoulli\", p=0.5) +   node(\"custom_1\", type=\"gaussian_trunc\", parents=c(\"sex\", \"age\"),        betas=c(1.1, 0.4), intercept=-2, error=2, left=10, right=25) +   node(\"custom_2\", type=parents_sum, parents=c(\"age\", \"custom_1\"))  data <- sim_from_dag(dag=dag, n_sim=100) head(data) #>         age    sex custom_1 custom_2 #>       <num> <lgcl>    <num>    <num> #> 1: 48.49105   TRUE 17.33651 65.82756 #> 2: 50.39048   TRUE 17.34963 67.74011 #> 3: 56.55498   TRUE 21.36313 77.91811 #> 4: 46.49763  FALSE 18.61867 65.11630 #> 5: 50.48704   TRUE 19.34207 69.82911 #> 6: 55.44852   TRUE 19.98135 75.42988"},{"path":[]},{"path":"https://robindenz1.github.io/simDAG/articles/v_custom_nodes.html","id":"requirements-2","dir":"Articles","previous_headings":"Time-Dependent Nodes","what":"Requirements","title":"Specifying Custom Node Types in a DAG","text":"time-dependent nodes mean nodes created using node_td() function. general, works essentially way simple root nodes child nodes. requirements : 1.) ’ name start node_ (want use string define type). 2.) child node, contain argument called data (contains already generated data). 3.) child node, contain argument called parents (contains vector child nodes parents). necessary nodes independently generated. 4.) return either vector length n_sim data.frame() (similar object) number columns n_sim rows. , number additional arguments allowed passed three-dot syntax. Additionally, multiple build-arguments users may specify custom time-dependent nodes, used internally. First, users may add argument function called sim_time. included function definition, current time simulation passed function every call made . Secondly, argument past_states may added. done , list containing previous states simulation (saved using save_states argument sim_discrete_time() function) passed internally, giving user access data generated previous points time. Similarly, arguments n (corresponding n_sim) dag (corresponding supplied DAG) may used.","code":""},{"path":[]},{"path":"https://robindenz1.github.io/simDAG/articles/v_custom_nodes.html","id":"time-dependent-root-nodes","dir":"Articles","previous_headings":"Time-Dependent Nodes > Examples","what":"Time-Dependent Root Nodes","title":"Specifying Custom Node Types in a DAG","text":"example custom time-dependent root node given : function simply draws new value normal distribution point time simulation. DAG using node type look like : Equivalently, simply, use (n passed automatically):","code":"node_custom_root_td <- function(data, n, mean=0, sd=1) {   return(rnorm(n=n, mean=mean, sd=sd)) } n_sim <- 100  dag <- empty_dag() +   node_td(name=\"Something\", type=node_custom_root_td, n=n_sim, mean=10, sd=5) #> Warning: Values for the arguments 'sim_time', 'past_states', 'dag' and 'n' are #> passed internally whenever present in a node function ('type' argument of the #> node_td() call). Any value specified in the node_td() call will be overwritten #> during the simulation. dag <- empty_dag() +   node_td(name=\"Something\", type=rnorm, mean=10, sd=5)"},{"path":"https://robindenz1.github.io/simDAG/articles/v_custom_nodes.html","id":"time-dependent-child-nodes","dir":"Articles","previous_headings":"Time-Dependent Nodes > Examples","what":"Time-Dependent Child Nodes","title":"Specifying Custom Node Types in a DAG","text":"example function can used define custom time-dependent child node: function takes random draw normal distribution different specifications based whether previously updated time-dependent node called currently TRUE FALSE.","code":"node_custom_child <- function(data, parents) {   out <- numeric(nrow(data))   out[data$other_event] <- rnorm(n=sum(data$other_event), mean=10, sd=3)   out[!data$other_event] <- rnorm(n=sum(!data$other_event), mean=5, sd=10)   return(out) }  dag <- empty_dag() +   node_td(\"other\", type=\"time_to_event\", prob_fun=0.1) +   node_td(\"whatever\", type=\"custom_child\", parents=\"other_event\")"},{"path":"https://robindenz1.github.io/simDAG/articles/v_custom_nodes.html","id":"using-the-sim_time-argument","dir":"Articles","previous_headings":"Time-Dependent Nodes > Examples","what":"Using the sim_time Argument","title":"Specifying Custom Node Types in a DAG","text":"give example sim_time argument may used. following function simply returns square current simulation time output: Note (!) actually define sim_time argument node_td() definition node, passed internally, just like data . long sim_time named argument function user passing, handled automatically. real simulation studies feature may used create time-scale dependent risks effects time-dependent events interest.","code":"node_square_sim_time <- function(data, sim_time, n_sim) {   return(rep(sim_time^2, n=n_sim)) }  dag <- empty_dag() +   node_td(\"unclear\", type=node_square_sim_time, n_sim=100)"},{"path":"https://robindenz1.github.io/simDAG/articles/v_custom_nodes.html","id":"using-the-past_states-argument","dir":"Articles","previous_headings":"Time-Dependent Nodes > Examples","what":"Using the past_states Argument","title":"Specifying Custom Node Types in a DAG","text":"stated earlier, another special kind argument past_states argument, allows users direct access past states simulation. example might used: function simply returns value used two simulation time steps ago plus normally distributed random value. make happen, actually use sim_time argument past_states argument. Note , , (!) define arguments node_td() definition node. simply used internally. crucial thing make previous code work actual simulation save_states argument sim_discrete_time() function. argument controls states saved internally. users want use previous states, need saved, argument almost cases set save_states=\"\", shown :","code":"node_prev_state <- function(data, past_states, sim_time) {   if (sim_time < 3) {     return(rnorm(n=nrow(data)))   } else {     return(past_states[[sim_time-2]]$A + rnorm(n=nrow(data)))   } }  dag <- empty_dag() +   node_td(\"A\", type=node_prev_state, parents=\"A\") sim <- sim_discrete_time(dag, n_sim=100, max_t=10, save_states=\"all\")"},{"path":"https://robindenz1.github.io/simDAG/articles/v_custom_nodes.html","id":"using-the-formula-interface","dir":"Articles","previous_headings":"","what":"Using the Formula Interface","title":"Specifying Custom Node Types in a DAG","text":"Users may also use enhanced formula interface directly custom child nodes custom time-dependent nodes. described detail vignette specifying formulas (see vignette(topic=\"v_using_formulas\", package=\"simDAG\")).","code":""},{"path":"https://robindenz1.github.io/simDAG/articles/v_custom_nodes.html","id":"some-general-comments","dir":"Articles","previous_headings":"","what":"Some General Comments","title":"Specifying Custom Node Types in a DAG","text":"Using custom functions node types advanced technique obtain specialized simulated data. sadly impossible cover user cases , like give general recommendations nonetheless: using custom nodes, pass function type directly, use string. might avoid weird scoping issues, depending environment simulation performed . Keep simple, u can. Particularly time-dependent simulations, computational complexity node function matters lot. Consider node_identity() might used instead. many cases, lot easier just use node type identity instead defining new function. structural equations printed custom nodes may uninformative. Keep mind inspecting output summary.DAG(). special cases, custom node function may require information supplied dag well. case, just add named argument called dag function supplied dag passed automatically whenever sim_from_dag() sim_discrete_time() used.","code":""},{"path":"https://robindenz1.github.io/simDAG/articles/v_sim_discrete_time.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Simulating Data using a Discrete-Time Approach","text":"small vignette, introduce sim_discrete_time() function, can used generate arbitrarily complex longitudinal data discrete points time. Just sim_from_dag() function contained package, allows mixture continuous, binary, categorical, count, time--event data. main advantage sim_discrete_time() function naturally generates longitudinal data without need define node variable point time. also makes generation complex time--event data lot easier. Features time-dependent effects, time-dependent covariates, form censoring, recurrent-events competing events may included straightforward fashion (Denz Timmesfeld 2025).","code":""},{"path":"https://robindenz1.github.io/simDAG/articles/v_sim_discrete_time.html","id":"what-is-discrete-time-simulation-and-why-use-it","dir":"Articles","previous_headings":"","what":"What is Discrete-Time Simulation and Why Use it?","title":"Simulating Data using a Discrete-Time Approach","text":"discrete-time simulation (DTS) consists two steps. First, bunch entities (usually necessarily people) created. Afterwards, change states entities time simulated increasing simulation time iteratively discrete steps, updating states step (Tang et al. 2020). example, suppose entities people interested states age death. Every time simulation time increases, age person increases , raising probability death. every step check person still alive. die, state death changes 0 1. everyone dead, stop simulation. schematic flow DTS shown figure . generalized flow-chart discrete-time simulation approach sim_discrete_time() directly implements workflow. data set t=0t = 0 either simulated using sim_from_dag() function supplied directly user (using t0_data argument). data set updated according time-dependent nodes added dag using node_td() calls. give short example works practice. realistic (therefore complex) example can found different vignette. DTS can seen special case simulation modeling. closely related dynamic microsimulation (Spooner et al. 2021), discrete-event simulation (Banks 2014) agent-based modeling (Ugur & Saka 2006). , requires lot input users. general, sim_discrete_time() function “--shelves” function can used “-” simulate data. cases, user needs write functions actually use function effectively. price one pay nearly unlimited flexibility simulation methodology. Nevertheless, may valid simulation strategy user interested highly complex longitudinal time--event data.","code":""},{"path":"https://robindenz1.github.io/simDAG/articles/v_sim_discrete_time.html","id":"defining-the-dag","dir":"Articles","previous_headings":"","what":"Defining the DAG","title":"Simulating Data using a Discrete-Time Approach","text":"Similar sim_from_dag() function, user needs specify nodes underlying causal DAG use function. variables DTS can categorized three categories: t0_root nodes, t0_child_nodes tx_nodes. t0_root_nodes: Variables completely independent variables generated called t0_root_nodes. something like sex geographic entities. generally simply sampled previously defined distribution, also sampled directly existing data. prefix t0_ indicates variables created beginning. t0_child_nodes: Much like t0_root_nodes, t0_child_nodes also variables generated beginning discrete-time simulation. difference , variables simply sampled defined distribution. Instead causally depend way variables. variables can root nodes child nodes, long underlying causal structure can described directed acyclic graph. tx_nodes: type node complex reason use DTS. Variables category updated step time simulation process. updates can fairly easy, increasing age person one time unit step, can complex. example, want model occurrence kind time-dependent-event, can generate probability occurrence step depending variables simulation model past states variable . t0_root_nodes t0_child_nodes arguments specified using DAG object calls node() function usual using sim_from_dag() function. fact, simply passed hood. role data generation process obtain initial data set need t=0t = 0. equivalent call sim_from_dag() function manually pass output t0_data argument. therefore won’t go detail . information correctly specify DAG can found documentation sim_from_dag() node() functions associated vignette.","code":""},{"path":"https://robindenz1.github.io/simDAG/articles/v_sim_discrete_time.html","id":"a-simple-example---one-terminal-event","dir":"Articles","previous_headings":"","what":"A Simple Example - One Terminal Event","title":"Simulating Data using a Discrete-Time Approach","text":"Let us consider simple example first. Suppose want generate data according following causal DAG: small DAG time-varying age , AA, stands sex, time-invariant variable, whereas BB (age) DD (death) . Suppose tick simulation corresponds duration one year. , naturally, people age one year every simulation tick. assume sex age direct causal effect probability death, regardless time. people dead, stay dead (reincarnation allowed). want use structure sim_discrete_time() function, first generate initial dataset state population t=0t = 0 described . first specifying t0_root_nodes follows: assume age normally distributed equal numbers sex. information enough specify data set t=0t = 0. Now need add additional time-dependent nodes using node_td() function ready. First, define function increases age individuals 1 step: Next, need define function return probability death every individual time tt, given current age sex. use logistic regression model, make explicit exemplary reasons: Now can add nodes DAG follows: simply pass node_advance_age() function type argument age node. death time--event node, ’s event generated probability step time. probability, defined , determined prob_death function defined earlier. set event_duration Inf make permanent event (dead, going back). visualize resulting DAG, can use associated plot() method:  finally generate desired data, simply call sim_discrete_time() function: setting max_t=50, letting simulation run 50 (simulated) years. results look like : easy see people died course 50 years looking death_event column. death_time column records time person died. want graphically display flow diagram data-generation mechanism, may use plot() method associated output sim_discrete_time() function like :  subtlety may arise interested terminal event times sim_discrete_time() function runs max_t steps. example , 50 steps (years example) enough observe death time 10 individuals. One possibility set max_t absurdly large value (lets say 1000000) define break_if argument. argument allows us define condition met simulation stopped early. example may use: , specify simulation run million years, stopped early individuals dead. time simulation stopped can accessed using sim_dat$break_t 36 case. Note strategy may lead unexpectedly long computation times, event unlikely individuals. remove_if argument may also helpful speed things (see documentation). particular example simulated much easier fashion, without relying discrete-time approach, age increases linearly model death exactly regardless time. DTS useful truly complex data structures required. extend simple example little bit, still keep relatively simple.","code":"library(data.table) library(ggplot2) library(simDAG)  dag <- empty_dag() +   node(\"age\", type=\"rnorm\", mean=30, sd=5) +   node(\"sex\", type=\"rbernoulli\", p=0.5) node_advance_age <- function(data) {   return(data$age + 1) } prob_death <- function(data) {   score <- -10 + 0.15 * data$age + 0.25 * data$sex   prob <- 1/(1 + exp(-score))   return(prob) } dag <- dag +   node_td(\"age\", type=\"advance_age\", parents=\"age\") +   node_td(\"death\", type=\"time_to_event\", parents=c(\"age\", \"sex\"),           prob_fun=prob_death, event_duration=Inf, save_past_events=TRUE,           check_inputs=FALSE) plot(dag) set.seed(43) sim_dat <- sim_discrete_time(n_sim=10, dag=dag, max_t=50, check_inputs=FALSE) head(sim_dat$data) #>         age    sex death_event death_time   .id #>       <num> <lgcl>      <lgcl>      <int> <int> #> 1: 79.81243   TRUE        TRUE         27     1 #> 2: 72.12698   TRUE        TRUE         13     2 #> 3: 77.57016  FALSE        TRUE         31     3 #> 4: 82.32593  FALSE        TRUE         16     4 #> 5: 75.47951  FALSE        TRUE         17     5 #> 6: 78.61284  FALSE        TRUE          9     6 plot(sim_dat) set.seed(44) sim_dat <- sim_discrete_time(n_sim=10, dag=dag, max_t=1000000,                              break_if=all(data$death_event==TRUE),                              check_inputs=FALSE)"},{"path":"https://robindenz1.github.io/simDAG/articles/v_sim_discrete_time.html","id":"extending-the-simple-example---recurrent-events","dir":"Articles","previous_headings":"","what":"Extending the Simple Example - Recurrent Events","title":"Simulating Data using a Discrete-Time Approach","text":"Suppose event interest wasn’t death, cardiovascular event (cve). case simplicity assume causal structure causal coefficients still apply, event now longer terminal may re-occur arbitrary number times. First, let’s redefine nodes get new name right: also redefine function generates required event probabilities: Now, case change arguments node_time_to_event() function: Apart changing node name, also changed event_duration parameter 1, meaning cardiovascular event lasts 1 year. also set save_past_events TRUE order store possible recurrent events. Now call sim_discrete_time() function : case, data little complex. time t=50t = 50, one person currently experiencing cardiovascular event, cve_event column FALSE almost rows cve_time column NA almost rows. need transform output data different formats using sim2data() function gain information. example, can transform start-stop format: format, can clearly see events occurred. type format usually used fit statistical models time--event data (although fitting , might want take look target_event, overlap keep_only_first arguments sim2data()). Another possibility transform long-format: may also useful fit discrete-time survival models. simulation done assumes time number previous events effect events patient. assumption may relaxed explicitly formulating prob_cve function way uses cve_time column change probability events. -depth example includes considerations like can found third vignette package.","code":"dag <- empty_dag() +   node(\"age\", type=\"rnorm\", mean=30, sd=5) +   node(\"sex\", type=\"rbernoulli\", p=0.5) prob_cve <- function(data) {   score <- -15 + 0.15 * data$age + 0.25 * data$sex   prob <- 1/(1 + exp(-score))   return(prob) } dag <- dag +   node_td(\"age\", type=\"advance_age\", parents=c(\"age\")) +   node_td(\"cve\", type=\"time_to_event\", parents=c(\"age\", \"sex\"),           prob_fun=prob_cve, event_duration=1, save_past_events=TRUE) sim_dat <- sim_discrete_time(n_sim=10, dag=dag, max_t=50) head(sim_dat$data) #>         age    sex cve_event cve_time   .id #>       <num> <lgcl>    <lgcl>    <int> <int> #> 1: 81.23076  FALSE     FALSE       NA     1 #> 2: 74.05308   TRUE     FALSE       NA     2 #> 3: 83.03159  FALSE     FALSE       NA     3 #> 4: 75.38063   TRUE     FALSE       NA     4 #> 5: 88.27912   TRUE     FALSE       NA     5 #> 6: 81.15802   TRUE     FALSE       NA     6 d_start_stop <- sim2data(sim_dat, to=\"start_stop\") head(d_start_stop) #>      .id start  stop    cve      age    sex #>    <int> <int> <num> <lgcl>    <num> <lgcl> #> 1:     1     1    50  FALSE 81.23076  FALSE #> 2:     2     1    50  FALSE 74.05308   TRUE #> 3:     3     1    48  FALSE 83.03159  FALSE #> 4:     3    49    49   TRUE 83.03159  FALSE #> 5:     3    50    50  FALSE 83.03159  FALSE #> 6:     4     1    50  FALSE 75.38063   TRUE d_long <- sim2data(sim_dat, to=\"long\") head(d_long) #> Key: <.id, .time> #>      .id .time    cve      age    sex #>    <int> <int> <lgcl>    <num> <lgcl> #> 1:     1     1  FALSE 81.23076  FALSE #> 2:     1     2  FALSE 81.23076  FALSE #> 3:     1     3  FALSE 81.23076  FALSE #> 4:     1     4  FALSE 81.23076  FALSE #> 5:     1     5  FALSE 81.23076  FALSE #> 6:     1     6  FALSE 81.23076  FALSE"},{"path":"https://robindenz1.github.io/simDAG/articles/v_sim_discrete_time.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Simulating Data using a Discrete-Time Approach","text":"Denz, Robin Nina Timmesfeld (2025). Simulating Complex Crossectional Longitudinal Data using simDAG R Package. arXiv preprint, doi: 10.48550/arXiv.2506.01498. Banks, Jerry, John S. Carson II, Barry L. Nelson, David M. Nicol (2014). Discrete-Event System Simulation. Vol. 5. Edinburgh Gate: Pearson Education Limited. Bilge, Ugur Osman Saka (2006). “Agent Based Simulations Healthcare”. : Ubiquity: Technologies Better Health Aging Societies - Proceedings MIE2006. Ed. Arie Hassman, Reinhold Haux, Johan van der Lei, Etienne De Clercq, Francis H. Roger France. IOS Press. Spooner, Fiona, Jesse F. Abrams, Karyn Morrissey, Gavin Shaddick, Michael Batty, Richard Milton, Adam Dennett, Nik Lomax, Nick Malleson, Natalie Nelissen, Alex Coleman, Jamil Nur, Ying Jin, Rory Greig, Charlie Shenton, Mark Birkin (2021). “Dynamic Microsimulation Model Epidemics”. : Social Science & Medicine 291.114461. Tang, Jiangjun, George Leu, und Hussein . Abbass. 2020. Simulation Computational Red Teaming Problem Solving. Hoboken: IEEE Press.","code":""},{"path":"https://robindenz1.github.io/simDAG/articles/v_sim_from_dag.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Simulating Data from a known DAG","text":"small vignette, introduce sim_from_dag() function, can used simulate complex data arbitrary causal directed acyclic graphs (DAGs). simulated data may include continuous, binary, categorical, count time--event variables (Denz Timmesfeld 2025). function useful DAG static, meaning time-varying variables. theoretically possible use function simulate data DAGs time structure well, difficulties associated discussed later.","code":""},{"path":"https://robindenz1.github.io/simDAG/articles/v_sim_from_dag.html","id":"what-are-causal-dags-and-why-use-them","dir":"Articles","previous_headings":"","what":"What are causal DAGs and why use them?","title":"Simulating Data from a known DAG","text":"causal DAG DAG nodes correspond variables directed edges correspond direct causal relationships variables. direct edge node AA node BB implies direct causal effect AA BB. hand, edge node AA node BB, direct causal relationship variables. Using DAG way makes easy encode causal structure given system, useful causal inference. general idea centerpiece structural approach causality developed Pearl (2002) Spirtes et al. (1993). strongly encourage reader make familiar literature moving . simple generate data defined causal DAG. see first need introduce concept root nodes child nodes. root node node DAG edges pointing (incoming arrows). child node hand node least one incoming edge. words, root nodes direct causes child nodes . Every node pointing another node considered parent child node. example, consider DAG figure 1. small DAG four nodes Nodes AA BB root nodes directed edges pointing . Nodes CC DD hand child nodes. parents node CC AA BB nodes directed edge towards CC. Note node BB parent node DD edge BB DD. name implies, DAGs cycles. Therefore every DAG least one root node. Generating data nodes first step simulate data whole DAG. Since root nodes parents, can simply generate random data using appropriate distribution. data root nodes, can generate directly connected child nodes next function root nodes (perhaps additional random error). direct child nodes used input next child nodes line . continues every node generated. Since every DAG can topologically sorted (Chickering 1995), always work. need specify DAG functional relationship node parents.","code":""},{"path":"https://robindenz1.github.io/simDAG/articles/v_sim_from_dag.html","id":"defining-the-dag","dir":"Articles","previous_headings":"","what":"Defining the DAG","title":"Simulating Data from a known DAG","text":"sim_from_dag() function uses method described , requires information causal structure exact form relationship child nodes parents. information included dag argument, DAG object created using empty_dag() function grown using node() calls described . can done completely manually (usual strategy conducting simulation studies) (partially) using existing data (may useful interest getting toy data set resembling real data closely possible). Regardless strategy want use, first initialize empty DAG object like : Afterwards can add unlimited amount root nodes child nodes . Multiple different types implemented.","code":"library(data.table) library(ggplot2) library(simDAG)  dag <- empty_dag()"},{"path":"https://robindenz1.github.io/simDAG/articles/v_sim_from_dag.html","id":"root-node-types","dir":"Articles","previous_headings":"Defining the DAG","what":"Root node types","title":"Simulating Data from a known DAG","text":"values root_nodes simply sampled defined distributions. Therefore, function generates random draws distribution may used . Popular alternatives continuous data normal-, beta-, gamma-distributions implemented base R inside rnorm(), rbeta() rgamma() functions. binary categorical data use custom functions rbernoulli() rcategorical() instead.","code":""},{"path":"https://robindenz1.github.io/simDAG/articles/v_sim_from_dag.html","id":"child-node-types","dir":"Articles","previous_headings":"Defining the DAG","what":"Child node types","title":"Simulating Data from a known DAG","text":"simDAG package implements following types child_nodes directly: nodes documentation page containing detailed description data generated . Although collection nodes covers lot data types, still somewhat limited collection. , example, wanted add child node normally distributed also truncated specific values, using just offered node functions. reason, sim_from_dag() function also allows user use custom functions nodes, makes possible model kind data kind relationship.","code":""},{"path":"https://robindenz1.github.io/simDAG/articles/v_sim_from_dag.html","id":"defining-nodes-manually","dir":"Articles","previous_headings":"Defining the DAG","what":"Defining nodes manually","title":"Simulating Data from a known DAG","text":"Suppose node AA figure stands age, BB stands sex, CC stands Body-Mass-Index (BMI) DD stands death. start defining root nodes look like. use following code define age sex: nodes defined calling node() function adding output dag object using simple +. syntax heavily inspired simcausal R-package (Sofrygin et al. 2017). , assume age continuous normally distributed variable mean 50 standard deviation 4 (real simulation study probably use truncated normal distribution ensure age negative). can done setting dist parameter \"rnorm\", standard R function generating random values normal distribution. arguments listed params parameter passed function. Similarly, define sex Bernoulli distributed variable (taking values 0/1). assume even gender distribution setting p = 0.5. Next, define relationship child nodes parents look like. may use following code: Since bmi node dependent sex age, list nodes parents bmi. specify bmi continuous variable modeled using linear regression setting type=\"gaussian\". concrete regression equation defined use intercept, betas error arguments. specification bmi node corresponds following equation: bmi=12+sex⋅1.1+age⋅0.4+N(0,2), bmi = 12 + sex \\cdot 1.1 + age \\cdot 0.4 + N(0, 2), N(0,2)N(0, 2) indicates error term modelled normally distributed variable mean 0 standard deviation 2. Since death two states (alive vs. dead), use logistic regression model instead. can easily setting type=\"binomial\". rest syntax essentially stays . regression equation death described code : logit(death)=−15+age⋅0.1+bmi⋅0.3. logit(death) = -15 + age \\cdot 0.1 + bmi \\cdot 0.3. check whether got causal relationships right, can call plot() function DAG object. output look similar hand-drawn DAG .  can also directly print underlying structural equations using summary() function: correct. can now use DAG object generate random data using sim_from_dag() function: Setting seed random number generator necessary obtain replicable results. data generated using code looks like : Binary variables sex death default treated logical variables, memory efficient way store . can now check distributions relationships dataset confirm indeed corresponds specified causal DAG. Starting root nodes:  seems correct. Note finite dataset, means results never exactly match theoretical distributions. ’s definitely close enough . check child nodes modeled correctly, simply fit corresponding models using glm() function: Evidently, coefficients match causal coefficients specified earlier.","code":"dag <- dag +    node(\"age\", type=\"rnorm\", mean=50, sd=4) +   node(\"sex\", type=\"rbernoulli\", p=0.5) dag <- dag +   node(\"bmi\", type=\"gaussian\", parents=c(\"sex\", \"age\"), betas=c(1.1, 0.4),        intercept=12, error=2) +   node(\"death\", type=\"binomial\", parents=c(\"age\", \"bmi\"), betas=c(0.1, 0.3),        intercept=-15) plot(dag) summary(dag) #> A DAG object using the following structural equations: #>  #>   age ~ N(50, 4) #>   sex ~ Bernoulli(0.5) #>   bmi ~ N(12 + 1.1*sex + 0.4*age, 2) #> death ~ Bernoulli(logit(-15 + 0.1*age + 0.3*bmi)) set.seed(42) sim_dat <- sim_from_dag(dag=dag, n_sim=10000) head(sim_dat, 5) #>         age    sex      bmi  death #>       <num> <lgcl>    <num> <lgcl> #> 1: 55.48383   TRUE 33.25311  FALSE #> 2: 47.74121  FALSE 29.58815  FALSE #> 3: 51.45251  FALSE 30.12967  FALSE #> 4: 52.53145   TRUE 32.07877  FALSE #> 5: 51.61707  FALSE 36.09082   TRUE hist(sim_dat$age) table(sim_dat$sex) #>  #> FALSE  TRUE  #>  5051  4949 mod_bmi <- glm(bmi ~ age + sex, data=sim_dat, family=\"gaussian\") summary(mod_bmi) #>  #> Call: #> glm(formula = bmi ~ age + sex, family = \"gaussian\", data = sim_dat) #>  #> Coefficients: #>              Estimate Std. Error t value Pr(>|t|)     #> (Intercept) 12.184254   0.253188   48.12   <2e-16 *** #> age          0.396020   0.005039   78.58   <2e-16 *** #> sexTRUE      1.177159   0.040563   29.02   <2e-16 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>  #> (Dispersion parameter for gaussian family taken to be 4.112615) #>  #>     Null deviance: 70134  on 9999  degrees of freedom #> Residual deviance: 41114  on 9997  degrees of freedom #> AIC: 42524 #>  #> Number of Fisher Scoring iterations: 2 mod_death <- glm(death ~ age + bmi, data=sim_dat, family=\"binomial\") summary(mod_death) #>  #> Call: #> glm(formula = death ~ age + bmi, family = \"binomial\", data = sim_dat) #>  #> Coefficients: #>               Estimate Std. Error z value Pr(>|z|)     #> (Intercept) -14.319144   0.371511  -38.54   <2e-16 *** #> age           0.093229   0.007057   13.21   <2e-16 *** #> bmi           0.289714   0.011331   25.57   <2e-16 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>  #> (Dispersion parameter for binomial family taken to be 1) #>  #>     Null deviance: 13773  on 9999  degrees of freedom #> Residual deviance: 11805  on 9997  degrees of freedom #> AIC: 11811 #>  #> Number of Fisher Scoring iterations: 3"},{"path":"https://robindenz1.github.io/simDAG/articles/v_sim_from_dag.html","id":"defining-nodes-using-existing-data","dir":"Articles","previous_headings":"Defining the DAG","what":"Defining nodes using existing data","title":"Simulating Data from a known DAG","text":"data resemble specific real data set, makes sense base values causal coefficients specific data set. can done fitting single model child node, extracting estimated coefficients fitted models putting appropriate DAG object. assumed DAG big, can time-extensive task. dag_from_data() function automates process. function takes node list containing minimal information causal structure node type outputs fully specified DAG object. example, lets assume data just generated (sim_dat) data set interest. Let us also assume know true underlying causal diagram rough idea nature relationship nodes (e.g. know can reasonably guess node type). Now create partially specified DAG accordance assumptions first: looks lot like code used , except explicitly defining actual beta coefficients. define causal structure node types. Now can call dag_from_data() function: returns object includes fully specified DAG, can used directly sim_from_dag() function: dag_from_data() function essentially just fits corresponding models one one node extracts relevant data models fill gaps empty nodes. set return_models TRUE dag_from_data() function call , can actually see used exact models fit earlier check simulation valid.","code":"dag <- empty_dag() +   node(\"age\", type=\"rnorm\") +   node(\"sex\", type=\"rbernoulli\") +   node(\"bmi\", type=\"gaussian\", parents=c(\"sex\", \"age\")) +   node(\"death\", type=\"binomial\", parents=c(\"age\", \"bmi\")) est_dag <- dag_from_data(dag=dag, data=sim_dat) sim_dat2 <- sim_from_dag(dag=est_dag$dag, n_sim=10000)"},{"path":"https://robindenz1.github.io/simDAG/articles/v_sim_from_dag.html","id":"time-varying-covariates","dir":"Articles","previous_headings":"","what":"Time-varying covariates","title":"Simulating Data from a known DAG","text":"real data sets include time-varying covariates, e.g. variables measured multiple points time subject changes. possible generate type data using sim_from_dag() function well. need define appropriate DAG directly specifies variables change time. example, can extend simple DAG include dimension time: small DAG four nodes , nodes AA BB time-constant variables causal effect initial state CC DD, nodes CC DD change time interdependently, subscript identifies discrete point time. want simulate data DAG looks like using sim_from_dag() function, add node every point time want consider. quickly go example, considering 2 points time. define nodes following way: example, C_1 function B, C_2 function previous value C, e.g. C_1. D node determined initial time-varying C. Note instead specifying parents, betas intercept arguments directly, used formula argument, allows us specify values elegant fashion. general, surely comprehensive example. meant show sim_from_dag() function may used incorporate time-dependent covariates. many points time considered complex time-dependent structures may easily described using DAG like one , sim_discrete_time() function also included package may used instead.","code":"dag <- empty_dag() +   node(\"A\", type=\"rnorm\", mean=50, sd=4) +   node(\"B\", type=\"rbernoulli\", p=0.5) +   node(\"C_1\", type=\"gaussian\", formula= ~ 12 + B*1.1 + A*0.4, error=2) +   node(\"D_1\", type=\"binomial\", formula= ~ -15 + A*0.1 + B*0.3 + C_1*0.1) +   node(\"C_2\", type=\"gaussian\", formula= ~ 0 + C_1*1.1 + D_1*1, error=2) +   node(\"D_2\", type=\"binomial\", formula= ~ -15 + D_1*10 + C_2*0.1)  sim_dat <- sim_from_dag(dag=dag, n_sim=10000)"},{"path":"https://robindenz1.github.io/simDAG/articles/v_sim_from_dag.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Simulating Data from a known DAG","text":"Denz, Robin Nina Timmesfeld (2025). Simulating Complex Crossectional Longitudinal Data using simDAG R Package. arXiv preprint, doi: 10.48550/arXiv.2506.01498. Judea Pearl (2009). Causality: Models, Reasoning Inference. 2nd ed. Cambridge: Cambridge University Press Peter Spirtes, Clark Glymour, Richard Scheines (2000) Causation, Prediction, Search. 2nd ed. MIT Press, Cambridge Chickering, D.M. (1995). transformational characterization equivalent Bayesian network structures. Proceedings 11th Conference Uncertainty Artificial Intelligence, Montreal, Canada, 87-98. Oleg Sofrygin, Mark J. van der Laan, Romain Neugebauer (2017). simcausal R Package: Conducting Transparent Reproducible Simulation Studies Causal Effect Estimation Complex Longitudinal Data. : Journal Statistical Software. 81.2, pp. 1-47","code":""},{"path":"https://robindenz1.github.io/simDAG/articles/v_sim_networks.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Simulating Data from a DAG with Network Dependencies","text":"algorithms used generate artificial data based DAGs using classic assumption individual observations independently identically distributed (classic ..d. assumption). done multiple reasons. First, makes specification data generation process (DGP) lot easier: distributions structural equations can defined entire DGP used generate arbitrarily large amounts data. Secondly, artificial DAG based data often used simulation studies contexts statistical models applied . Since models require ..d. assumption, makes sense generate data way. , however, case applications. example, spread infectious disease dependent “connected” population risk (Danon et al. 2011). individual many contacts usually higher probability coming contact infected person thus higher chance getting infected well. fact direct opposition ..d. assumption, infection status one individual influences infection status individuals. individuals said “interfere” (VanderWeele 2013). Networks-based simulations one way model dependencies. following vignette introduces methodology implemented simDAG R package (Denz Timmesfeld 2025). advanced topic. assume reader already familiar general simDAG syntax DAG based simulations. Please consult associated paper numerous vignettes first, case.","code":"library(data.table) library(igraph) library(simDAG)"},{"path":"https://robindenz1.github.io/simDAG/articles/v_sim_networks.html","id":"what-are-networks-based-simulations","dir":"Articles","previous_headings":"","what":"What are networks-based simulations?","title":"Simulating Data from a DAG with Network Dependencies","text":"networks-based simulation, individual embedded one multiple networks. networks may arbitrary amount connections individuals, signifying connected . Data may simulated using essentially approach used classic DAG-based simulations, added possibility using network structures define individual dependencies. example, variable defined function variables, also function neighbors individual ii (variable values), neighbors defined individual jj share connection ii given network (although directed networks, multiple options define neighbors possible). rigorous explanation, along explanation implementation methodology simcausal package, given Sofrygin, Neugebauer, van der Laan (2017). network science, points networks often called nodes vertices, connections usually called edges , directed networks, arrows. talking networks stick terms vertices edges , avoid confusion terms nodes arrows also used talking DAGs. Note DAG course also special type network, serves different purpose . simulations described , DAG defines causal relationships variables, network describes connections individuals.","code":""},{"path":[]},{"path":"https://robindenz1.github.io/simDAG/articles/v_sim_networks.html","id":"a-single-network","dir":"Articles","previous_headings":"Networks in regular simulations","what":"A single network","title":"Simulating Data from a DAG with Network Dependencies","text":"start simple example, using single un-directed, un-weighted, static network never changes variables also constant time. Consider following simple network:  network, individual 11 three neighbors: 2,32, 3 44, individual 55 two neighbors: 33 44. first simulate age sex values individuals, irrespective position network, using standard simDAG syntax generate data DAG: , age sex root nodes, age normally distributed variable mean 50 standard deviation 10 sex Bernoulli distributed equal probabilities either male (sex = 0) female (sex = 1). Now every person assigned values. generated data right now, without nodes, look like : rownames data.table show person value belongs. words, row 1 mapped vertex 1 network, row 2 mapped vertex 2 network . impose network structure onto DAG, can simply add already generated igraph object using network() function: network() call, provide name network (called network1) network , used igraph object. Note , graph pre-generated 5 individuals , DAG can now generate data 5 individuals well actually using network. allow flexible changes n_sim calling sim_from_dag() sim_discrete_time() later , users need supply function instead, show later. now stay 5 individuals. Now network added, able use net() syntax formula argument nodes. example, define new variable called infected, contain indicator whether someone infected infectious disease , function persons age sex function neighbors age sex using following syntax: node, infection probability increase persons age, higher males, decreases higher mean ages persons neighbors decreases higher proportions females among persons neighbors. run simulation updated DGP, results looks like : Note intermediate variables (mean age neighbors, proportion female neighbors) included output. Users may use nodes type \"identity\" actually save inspect output net() calls instead. example, calculating number infected neighbors per person now done using: may useful inspect aggregation worked save computation time net() call used multiple subsequent nodes. example, individuals 4 5 infected, means individuals 1, 2 4 5 one infected neighbor, individual 3 2 infected neighbors connection individuals 4 5.","code":"set.seed(1234)  data <- data.frame(from=c(1, 1, 2, 3, 4, 5, 5),                    to=c(2, 3, 4, 4, 1, 3, 4))  g <- graph_from_data_frame(data, directed=FALSE) plot(g) dag <- empty_dag() +   node(\"age\", type=\"rnorm\", mean=50, sd=10) +   node(\"sex\", type=\"rbernoulli\", p=0.5, output=\"numeric\") set.seed(5245) data <- sim_from_dag(dag, n_sim=5) print(data, row.names=TRUE) #>         age   sex #>       <num> <num> #> 1: 35.08209     1 #> 2: 47.01248     1 #> 3: 35.42111     0 #> 4: 57.29242     0 #> 5: 43.33519     0 dag <- dag + network(\"network1\", net=g) dag <- dag + node(\"infected\", type=\"binomial\",                   formula= ~ 5 + age*0.1 + sex*-0.5 +                     net(mean(age))*-0.2 + net(mean(sex))*-0.4) set.seed(5245) data <- sim_from_dag(dag, n_sim=5) print(data, row.names=TRUE) #>         age   sex infected #>       <num> <num>   <lgcl> #> 1: 35.08209     1    FALSE #> 2: 47.01248     1    FALSE #> 3: 35.42111     0    FALSE #> 4: 57.29242     0     TRUE #> 5: 43.33519     0     TRUE dag <- dag + node(\"n_inf_neighbors\", type=\"identity\",                   formula= ~ net(sum(infected)), kind=\"data\")  set.seed(5245) data <- sim_from_dag(dag, n_sim=5) print(data, row.names=TRUE) #>         age   sex infected n_inf_neighbors #>       <num> <num>   <lgcl>           <num> #> 1: 35.08209     1    FALSE               1 #> 2: 47.01248     1    FALSE               1 #> 3: 35.42111     0    FALSE               2 #> 4: 57.29242     0     TRUE               1 #> 5: 43.33519     0     TRUE               1"},{"path":"https://robindenz1.github.io/simDAG/articles/v_sim_networks.html","id":"multiple-networks","dir":"Articles","previous_headings":"Networks in regular simulations","what":"Multiple networks","title":"Simulating Data from a DAG with Network Dependencies","text":"reality, individuals usually embedded one network time. People part friendship networks, contact networks, professional networks . also directly supported simDAG package. add multiple networks DAG. first generate two random networks size (20 individuals) using igraph package: Suppose first network “friendship network”, showing friends second “professional network”, showing works . look like :  colored vertices differently highlight two distinct networks. now first repeat large parts DAG earlier, add networks time: can now add new node DAG, utilizes network dependencies time: exactly node definition previous example, difference mean age friends network used proportion females used work network. results look like : Interestingly, individual 4 value NA infected node. reason individual 4 friends (don’t worry, real can’t sad ) thus mean(age) call defined person. replace NA values values, na argument net() may used.","code":"set.seed(56356) g1 <- igraph::sample_gnm(n=20, m=30) g2 <- igraph::sample_gnm(n=20, m=30)  V(g1)$color <- \"salmon\" V(g2)$color <- \"lightblue\" par(mfrow=c(1, 2), mar=c(0, 0, 0, 0) + 1)  plot(g1, main=\"Friends\", margin=0, vertex.label.cex=0.8) plot(g2, main=\"Work\", margin=0, vertex.label.cex=0.8) dag <- empty_dag() +   node(\"age\", type=\"rnorm\", mean=50, sd=10) +   node(\"sex\", type=\"rbernoulli\", p=0.5, output=\"numeric\") +   network(\"friends\", net=g1) +   network(\"work\", net=g2) dag <- dag + node(\"infected\", type=\"binomial\",                   formula= ~ 3 + age*0.1 + sex*-0.5 +                     net(mean(age), net=\"friends\")*-0.2 +                      net(mean(sex), net=\"work\")*-0.4) data <- sim_from_dag(dag, n_sim=20) head(data, row.names=TRUE) #>         age   sex infected #>       <num> <num>   <lgcl> #> 1: 53.86490     0    FALSE #> 2: 46.69516     0    FALSE #> 3: 33.77426     0     TRUE #> 4: 49.78544     1       NA #> 5: 58.56361     0    FALSE #> 6: 66.37300     0    FALSE"},{"path":"https://robindenz1.github.io/simDAG/articles/v_sim_networks.html","id":"weighted-networks","dir":"Articles","previous_headings":"Networks in regular simulations","what":"Weighted networks","title":"Simulating Data from a DAG with Network Dependencies","text":"many applications network science, edges networks said weights, specify connections stronger others. friendship network earlier, weights example indicate one friendship closer another one. Using weights also directly supported simulation purposes package. Let us first add random weights friendships network shown . Re-plotting network one can see edges now different weights:  Regular net() calls ignore weights, specifically told . Users use internal ..weight.. variable use weights. example, want re-use DAG definition earlier, something like : essentially code , difference use weighted.mean() instead mean() summarize neighbors’ values use edge weights within function call, giving stronger connections weight. Users course free use ..weight.. variable way well.","code":"E(g1)$weight <- runif(n=length(E(g1)), min=1, max=5) plot(g1, edge.width=E(g1)$weight) dag <- empty_dag() +   network(\"friends\", net=g1) +   node(\"age\", type=\"rnorm\", mean=50, sd=10) +   node(\"sex\", type=\"rbernoulli\", p=0.5, output=\"numeric\") +   node(\"infected\", type=\"binomial\",        formula= ~ 3 + age*0.1 + sex*-0.5 +                   net(weighted.mean(x=age, w=..weight..))*-0.2 +                    net(weighted.mean(x=sex, w=..weight..))*-0.4) data <- sim_from_dag(dag, n_sim=20) head(data) #>         age   sex infected #>       <num> <num>   <lgcl> #> 1: 45.69134     1    FALSE #> 2: 37.05165     0    FALSE #> 3: 66.75057     1    FALSE #> 4: 36.75051     1       NA #> 5: 61.50802     0     TRUE #> 6: 63.68616     0     TRUE"},{"path":"https://robindenz1.github.io/simDAG/articles/v_sim_networks.html","id":"directed-networks","dir":"Articles","previous_headings":"Networks in regular simulations","what":"Directed Networks","title":"Simulating Data from a DAG with Network Dependencies","text":"far always assumed connections graph un-directed, e.g. edge vertices 11 22, reciprocal relationship . real networks often case relationships vertices reciprocal, directed. example, professional network might interested showing giving orders. done using directed network. kinds networks also directly supported simulation purposes package. Let us create random directed network first:  example, individual 3 can give orders individual 11, 13 14, given orders individuals. Now lets suppose want use values subordinates (e.g. vertices connected outgoing edges) define neighborhoods. can achieved using mode argument net() function. replicate DAG earlier, changing slightly: Conversely, want model infected probability function “bosses” node (e.g. incoming edges), set mode=\"\" net() calls. want disregard edge directions, simply keep mode argument default value \"\". Since way edges treated defined using net() calls, course also possible use mixtures strategies node definition, using multiple net() calls different modes. also combined weights (described previous section).","code":"set.seed(123)  g <- sample_gnm(n=20, m=18, directed=TRUE, loops=FALSE) plot(g, edge.arrow.size=0.4) dag <- empty_dag() +   network(\"work\", net=g) +   node(\"age\", type=\"rnorm\", mean=50, sd=10) +   node(\"sex\", type=\"rbernoulli\", p=0.5, output=\"numeric\") +   node(\"infected\", type=\"binomial\",        formula= ~ 3 + age*0.1 + sex*-0.5 +                   net(mean(age), mode=\"out\", na=0)*-0.2 +                    net(mean(sex), mode=\"out\", na=0)*-0.4) data <- sim_from_dag(dag, n_sim=20) head(data) #>         age   sex infected #>       <num> <num>   <lgcl> #> 1: 53.22599     1     TRUE #> 2: 52.17259     1    FALSE #> 3: 54.58468     0    FALSE #> 4: 46.99742     0     TRUE #> 5: 33.19981     0     TRUE #> 6: 33.78001     1     TRUE"},{"path":"https://robindenz1.github.io/simDAG/articles/v_sim_networks.html","id":"neighborhood-order","dir":"Articles","previous_headings":"Networks in regular simulations","what":"Neighborhood order","title":"Simulating Data from a DAG with Network Dependencies","text":"previous examples, used immediate neighbors node net() calls. using order argument net() function, also possible use larger neighborhoods, meaning instead considering directly connected individuals neighbors, may also include individuals connected . show another random network neighbors node 11 (colored green) colored salmon two different values order:  directed network, neighborhood course also dependent direction edges, described previous section. simple example one use functionality: , largely replicated DAG earlier, use different order neighborhoods effect age sex. , order defined individual net() calls, users may use different values order node definition without issues. Note using order > 1 edge weights ignored, clear edge weight considering indirect connections. also go additional step consider direct connections neighbors neighbors, without using direct connections . can done using mindist argument net(). another graph illustrating difference using mindist=1 mindist=2 order=2 given earlier network:  might useful model extended network effects direct effects DAG. Repeating DAG earlier (slight changes) use something like:","code":"set.seed(2134) g <- sample_gnm(n=20, m=15)  dag <- empty_dag() +   network(\"net1\", net=g) +   node(\"age\", type=\"rnorm\", mean=50, sd=10) +   node(\"sex\", type=\"rbernoulli\", p=0.5, output=\"numeric\") +   node(\"infected\", type=\"binomial\",        formula= ~ 3 + age*0.1 + sex*-0.5 +                   net(mean(age), order=1, na=0)*-0.2 +                    net(mean(sex), order=2, na=0)*-0.4) data <- sim_from_dag(dag, n_sim=20) head(data) #>         age   sex infected #>       <num> <num>   <lgcl> #> 1: 57.71886     1     TRUE #> 2: 53.62951     0     TRUE #> 3: 61.21526     1     TRUE #> 4: 57.20119     1    FALSE #> 5: 30.44710     0    FALSE #> 6: 45.28895     0    FALSE set.seed(2134) g <- sample_gnm(n=20, m=15)  dag <- empty_dag() +   network(\"net1\", net=g) +   node(\"age\", type=\"rnorm\", mean=50, sd=10) +   node(\"sex\", type=\"rbernoulli\", p=0.5, output=\"numeric\") +   node(\"infected\", type=\"binomial\",        formula= ~ 3 + age*0.1 + sex*-0.5 +                   net(mean(age), order=2, mindist=2, na=0)*-0.4) data <- sim_from_dag(dag, n_sim=20) head(data) #>         age   sex infected #>       <num> <num>   <lgcl> #> 1: 57.71886     1     TRUE #> 2: 53.62951     0    FALSE #> 3: 61.21526     1     TRUE #> 4: 57.20119     1    FALSE #> 5: 30.44710     0    FALSE #> 6: 45.28895     0    FALSE"},{"path":"https://robindenz1.github.io/simDAG/articles/v_sim_networks.html","id":"networks-as-a-function-of-other-variables","dir":"Articles","previous_headings":"Networks in regular simulations","what":"Networks as a function of other variables","title":"Simulating Data from a DAG with Network Dependencies","text":"point always created networks completely independently variables, reality considered unrealistic. Luckily, networks may also defined function already generated variables well. Similar regular node() function calls, possible use parents argument specify network based values parents. data parents automatically passed data argument function used create network, allowing kinds dependencies implemented user. Suppose goal generate data males females. reason essentially separate networks males females. might example arise considering networks sports separated sex. simulate example, first define functions: id_different_sex() function simply takes edge graph checks whether vertices type. gen_network() function first generates random graph adds sex contained supplied data type node. deletes edges type (e.g. sex) vertices . can incorporate DAG using: can now simulate DAG: Note set return_networks=TRUE, can also inspect generated network. Whenever done, sim_from_dag() function actually returns list containing generated data networks. generated networks, different vertex colors sex:  fairly artificial example, meant illustrate functionality simple way. Users course use much interesting ways. net argument allows function, limits set network structure dependent data hand.","code":"is_different_sex <- function(g, x) {   V(g)[ends(g, x)[1]]$type != V(g)[ends(g, x)[2]]$type }  gen_network <- function(n_sim, data) {   g <- sample_gnm(n=n_sim, m=50)   V(g)$type <- data$sex   g <- delete_edges(g, which(vapply(E(g), is_different_sex,                                     FUN.VALUE=logical(1), g=g)))   return(g) } dag <- empty_dag() +   node(\"age\", type=\"rnorm\", mean=25, sd=5) +   node(\"sex\", type=\"rbernoulli\", p=0.5) +   network(\"network1\", net=gen_network, parents=\"sex\") +   node(\"infected\", type=\"binomial\", formula= ~ 1 + net(mean(age))*0.5) set.seed(1324) data <- sim_from_dag(dag, n_sim=20, return_networks=TRUE) head(data$data) #>         age    sex infected #>       <num> <lgcl>   <lgcl> #> 1: 17.74261   TRUE     TRUE #> 2: 33.84116  FALSE     TRUE #> 3: 17.13370   TRUE     TRUE #> 4: 13.14236   TRUE     TRUE #> 5: 33.44052   TRUE     TRUE #> 6: 21.95168   TRUE       NA g <- data$networks$network1$net V(g)$color <- ifelse(V(g)$type, \"salmon\", \"lightblue\") plot(g)"},{"path":"https://robindenz1.github.io/simDAG/articles/v_sim_networks.html","id":"networks-in-discrete-time-simulation","dir":"Articles","previous_headings":"","what":"Networks in discrete-time simulation","title":"Simulating Data from a DAG with Network Dependencies","text":"course also possible use outlined networks-simulation-based approach discrete-time simulations conducted using sim_discrete_time() function. illustrate using static dynamically changing networks.","code":""},{"path":"https://robindenz1.github.io/simDAG/articles/v_sim_networks.html","id":"static-networks","dir":"Articles","previous_headings":"Networks in discrete-time simulation","what":"Static networks","title":"Simulating Data from a DAG with Network Dependencies","text":"simple example, consider spread infectious disease (un-directed un-weighted) network 18 individuals 6 distinct points time. simulation, one variable interest: infection status person, denoted infected (0 = infected, 1 = infected). First, generate random graph 18 individuals 30 connections using igraph package:  assume probability infection rises simple fashion number infected neighbors network. t=1t = 1 individuals 5% chance becoming infected unknown external event. , individuals infected neighbors can infected. particular, general probability infection tt defined : P(t)={0.05ift=10.4ift>1 k∈(1,2)0.9ift>1 k>30otherwise,     P(t) =     \\begin{cases}       0.05 & \\text{} \\quad t = 1 \\\\         0.4 & \\text{} \\quad t > 1 \\text{ } k \\(1,2) \\\\         0.9 & \\text{} \\quad t > 1 \\text{ } k > 3 \\\\         0 & \\text{otherwise}     \\end{cases}, kk number infected neighbors individual. Additionally, infected, person stays infected. can simulate kind date using following code: , first define prob_infected() function, implements conditional probability distribution defined . function later used \"time_to_event\" node. define DAG required simulation. First, add single call network() empty DAG allow usage network dependencies. add time-dependent node using node_td(), simply calculates number infected neighbors node . define final node, infected, using prob_infected() function defined earlier. Now can run simulation transform output long-format easier processing: Using simple loop plot.igraph() function (cosmetic changes), can also visualize spread infection network. resulting 6 figures, show network point time simulation, infected individuals colored salmon -infected individuals colored lightblue:  infection started individual 14 infected (index case). spread immediately individuals 2 8 continued , actual infection might . course also possible make probability generating function realistic, add variables vaccinations.","code":"set.seed(244368) g2 <- igraph::sample_gnm(n=18, m=30)  plot(g2) prob_infection <- function(data, sim_time) {   if (sim_time==1) {     p <- rep(0.05, nrow(data))   } else {     p <- fifelse(data$n_infected_neighbors==0, 0,                  fifelse(data$n_infected_neighbors > 3, 0.9, 0.4))   }   return(p) }  dag <- empty_dag() +   network(\"net1\", net=g2) +   node_td(\"n_infected_neighbors\", type=\"identity\",           formula= ~ net(sum(infected_event), na=0), kind=\"data\") +   node_td(\"infected\", type=\"time_to_event\", event_duration=Inf,           immunity_duration=Inf, parents=(\"n_infected_neighbors\"),           prob_fun=prob_infection) sim <- sim_discrete_time(dag, n_sim=18, max_t=6, save_states=\"all\") data <- sim2data(sim, to=\"long\") head(data) #> Key: <.id, .time> #>      .id .time n_infected_neighbors infected #>    <int> <int>                <num>   <lgcl> #> 1:     1     1                    0    FALSE #> 2:     1     2                    0    FALSE #> 3:     1     3                    1    FALSE #> 4:     1     4                    2    FALSE #> 5:     1     5                    2     TRUE #> 6:     1     6                    3     TRUE E(g2)$color <- \"lightgray\"  par(mfrow=c(3, 2), mar=c(0, 0, 0, 0) + 2)  for (i in seq_len(6)) {      data_i <- subset(data, .time==i)      V(g2)$color <- ifelse(data_i$infected, \"salmon\", \"lightblue\")      set.seed(124)   plot(g2,        vertex.label.cex=0.8,        vertex.label.color=\"black\",        size=1,        main=paste0(\"t = \", i),        layout=layout_nicely(g2),        margin=0) }"},{"path":"https://robindenz1.github.io/simDAG/articles/v_sim_networks.html","id":"dynamic-networks","dir":"Articles","previous_headings":"Networks in discrete-time simulation","what":"Dynamic networks","title":"Simulating Data from a DAG with Network Dependencies","text":"previous examples, network structure never changed, used single network() call defining static network. extend approach case dynamic networks, may change time (possibly function fixed time-varying variables).","code":""},{"path":"https://robindenz1.github.io/simDAG/articles/v_sim_networks.html","id":"random-new-networks-at-each-point-in-time","dir":"Articles","previous_headings":"Networks in discrete-time simulation > Dynamic networks","what":"Random new networks at each point in time","title":"Simulating Data from a DAG with Network Dependencies","text":"Let us start easiest type dynamic network can imagine: network structure changes entirely every single point time without correlation previously looked like happened individuals . can using almost code used earlier. main difference situation dynamic networks used need define function generates network us. one possibility: requirement function single named argument called n_sim, controls size network (number vertices ). function , argument simply passed sample_gnm() function igraph package already used earlier. can now use almost code generate data using function: difference previous code used network_td() instead network(), passing function net argument. Everything else . code visualize spread disease also similar, one change now one network per slide (saved sim object set save_networks=TRUE):  , simulation starts individuals 8 infected, connected individuals 3, 7, 11, 15 16 t=1t = 1. individual spread infection individuals 3 15, can seen t=2t = 2. However, network changed completely point. Now individuals connected others, spreading infection even connected now. repeats almost everyone (except individuals 4 12) infected. Note makes significant difference order node_td() network_td() calls added, usual simulations using sim_discrete_time().","code":"gen_network <- function(n_sim) {   igraph::sample_gnm(n=n_sim, m=30) } dag <- empty_dag() +   node_td(\"n_infected_neighbors\", type=\"identity\",           formula= ~ net(sum(infected_event), na=0), kind=\"data\") +   node_td(\"infected\", type=\"time_to_event\", event_duration=Inf,           immunity_duration=Inf, parents=(\"n_infected_neighbors\"),           prob_fun=prob_infection) +   network_td(\"net1\", net=gen_network)  set.seed(1335)  sim <- sim_discrete_time(dag, n_sim=18, max_t=6, save_states=\"all\",                          save_networks=TRUE) data <- sim2data(sim, to=\"long\") head(data) #> Key: <.id, .time> #>      .id .time n_infected_neighbors infected #>    <int> <int>                <num>   <lgcl> #> 1:     1     1                    0    FALSE #> 2:     1     2                    0    FALSE #> 3:     1     3                    1    FALSE #> 4:     1     4                    1     TRUE #> 5:     1     5                    3     TRUE #> 6:     1     6                    5     TRUE par(mfrow=c(3, 2), mar=c(0, 0, 0, 0) + 2)  for (i in seq_len(6)) {      data_i <- subset(data, .time==i)   g_i <- sim$past_networks[[i]]$net1$net      E(g_i)$color <- \"lightgray\"   V(g_i)$color <- ifelse(data_i$infected, \"salmon\", \"lightblue\")      set.seed(124)   plot(g_i, vertex.label.cex=0.8,        vertex.label.color=\"black\",        size=1,        main=paste0(\"t = \", i),        layout=layout_nicely(g_i),        margin=0) }"},{"path":"https://robindenz1.github.io/simDAG/articles/v_sim_networks.html","id":"adjusting-a-network-over-time","dir":"Articles","previous_headings":"Networks in discrete-time simulation > Dynamic networks","what":"Adjusting a network over time","title":"Simulating Data from a DAG with Network Dependencies","text":"Lets move useful example, network initiated beginning changed slightly time instead re-drawing every time. example, extend earlier infectious disease example. new example, government trying contain epidemic isolating infected individuals. act isolation context means, infected individual put quarantine allowed contact individuals, translates removing connections infected individual network. assume government able perfectly enforce isolation, little slow . one full day sick government realize individual infected. First, adjust gen_network() function. use following code: lines obscure code , generally function really simple. t=0t = 0 simply generates random graph using sample_gnm(). t=1t = 1 simply checks whether person infected isolates , deleting connections returning adjusted network. adding time-dependent networks time-dependent nodes DAG, ensure updated nodes day generated. time_since_last counter infected node starts 0 using data$infected_time_since_last > 0 ensures individual one full day spread infection. Note arguments sim_time, network data automatically passed internally. sim_time current simulation time, network current state network data current state data. can now re-use almost DAG definition earlier: difference actively set create_at_t0=TRUE network gets created time-dependent processing starts (network adjust t=1t = 1) set time_since_last=TRUE infected node track time since original infection, need information network generating function. Lets run simulation : first rows data can already see number infected individuals finally lets plot resulting infection spread :  can seen, due timely delay isolation, infection still able spread, reach individuals. Near end simulation, practically connections removed, making impossible infection spread . means realistic example, showcases changing networks might utilized package. simulation easily extended make isolation non-permanent, re-adding removed connections pre-defined duration, even extended adding vaccinations variables. Additionally, although shown vignette, course also possible use features shown regular simulations (weighted directed networks, multiple networks, etc.) discrete-time simulation well.","code":"gen_network <- function(n_sim, sim_time, network, data) {      if (sim_time==0) {     return(igraph::sample_gnm(n=n_sim, m=23))   }      rm_edges <- data$.id[data$infected_event==TRUE &                        data$infected_time_since_last > 0]      if (length(rm_edges) > 0) {     rm_edges <- do.call(c, incident_edges(network, rm_edges))     g_new <- delete_edges(network, rm_edges)   } else {     g_new <- network   }   return(g_new) } dag <- empty_dag() +   node_td(\"n_infected_neighbors\", type=\"identity\",           formula= ~ net(sum(infected_event), na=0), kind=\"data\") +   node_td(\"infected\", type=\"time_to_event\", event_duration=Inf,           immunity_duration=Inf, parents=(\"n_infected_neighbors\"),           prob_fun=prob_infection, time_since_last=TRUE) +   network_td(\"net1\", net=gen_network, create_at_t0=TRUE) set.seed(13354)  sim <- sim_discrete_time(dag, n_sim=18, max_t=6, save_states=\"all\",                          save_networks=TRUE) data <- sim2data(sim, to=\"long\") head(data) #> Key: <.id, .time> #>      .id .time n_infected_neighbors infected infected_time_since_last #>    <int> <int>                <num>   <lgcl>                    <num> #> 1:     1     1                    0    FALSE                       NA #> 2:     1     2                    1    FALSE                       NA #> 3:     1     3                    1     TRUE                        0 #> 4:     1     4                    0     TRUE                        1 #> 5:     1     5                    0     TRUE                        2 #> 6:     1     6                    0     TRUE                        3 par(mfrow=c(3, 2), mar=c(0, 0, 0, 0) + 2)  layout_g <- layout_nicely(sim$past_networks[[1]]$net1$net)  for (i in seq_len(6)) {      data_i <- subset(data, .time==i)   g_i <- sim$past_networks[[i]]$net1$net      E(g_i)$color <- \"lightgray\"   V(g_i)$color <- ifelse(data_i$infected, \"salmon\", \"lightblue\")      set.seed(124)   plot(g_i, vertex.label.cex=0.8,        vertex.label.color=\"black\",        size=1,        main=paste0(\"t = \", i),        layout=layout_g,        margin=0) }"},{"path":"https://robindenz1.github.io/simDAG/articles/v_sim_networks.html","id":"discussion","dir":"Articles","previous_headings":"","what":"Discussion","title":"Simulating Data from a DAG with Network Dependencies","text":"Networks-based simulations offer additional amount flexibility specifying data generation processes (DGP) usually included general-purpose simulation software. making cross-individual dependencies possible one multiple networks allowing also influenced individual-level variables, almost kind data can generated. simDAG package offers simple consistent syntax perform simulations. Network dependencies fully integrated enhanced formula syntax net() function, hopefully makes barrier use methodology lot less daunting potential users. Despite great flexibility offered approach, used quite infrequently practice. preprint published Sofrygin, Neugebauer, van der Laan (2017) gather lot attention, even though also offered clean powerful implementation method simcausal (Sofrygin, van der Laan, Neugebauer 2017) package (heavily inspired presented simDAG implementation). suspect main reason statistical models designed actually analyze data complex DGPs. Despite recent advancements, combination network science causal inference still infancy, pointed others (Ogburn et al. 2024; VanderWeele 2013; , Beauvile, Rosche 2022). hope implementation make future investigations subject easier least convenient methodological researchers.","code":""},{"path":[]},{"path":"https://robindenz1.github.io/simDAG/articles/v_using_formulas.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Specifying Formulas in a DAG","text":"small vignette, give detailed examples best use formula argument node() node_td() functions. argument allows users directly specify full structural equation used generate respective node clear easy way, directly rely parents, betas associated arguments. Note formula argument may used certain node types, mentioned documentation.","code":""},{"path":"https://robindenz1.github.io/simDAG/articles/v_using_formulas.html","id":"a-simple-example","dir":"Articles","previous_headings":"","what":"A simple example","title":"Specifying Formulas in a DAG","text":"start simple example. Suppose want generate data simple DAG time-varying variables. Consider following DAG: DAG contains three root nodes different types. AA normally distributed, BB Bernoulli distributed CC simple categorical variable levels “low”, “medium” “high”. generate data DAG alone, look like : Suppose now want generate additional child node called DD based linear regression model form: D∼−8+⋅0.4+B⋅−2+N(0,1.5).D \\sim -8 + \\cdot 0.4 + B \\cdot -2 + N(0, 1.5). using node() function, supplying appropriate values parents, betas, intercept error arguments. following code used: work just fine, may little cumbersome specify DAG way. Since want use linear regression model, instead use formula argument like : Given random number generator seed, output produced DAGs, shown : Formulas always start ~ sign nothing else left hand side. parts formula connected + signs, never - signs. name respective variable always connected associated coefficient * sign. matter whether name term coefficient go first, consistent formula. example, ~ 1 + *2 + B*3 works, ~ 1 + 2*+ 3*B also works, ~ 1 + 2*+ B*2 produce error. formula may also supplied string produce output. Apart easier read, also allows user lot options. use formulas possible specify nodes categorical parents. also possible include order interaction effects cubic terms using formulas, shown .","code":"library(simDAG)  dag <- empty_dag() +   node(\"A\", type=\"rnorm\", mean=0, sd=1) +   node(\"B\", type=\"rbernoulli\", p=0.5, output=\"numeric\") +   node(\"C\", type=\"rcategorical\", probs=c(0.3, 0.2, 0.5),        output=\"factor\", labels=c(\"low\", \"medium\", \"high\")) set.seed(23143)  dat <- sim_from_dag(dag, n_sim=10) head(dat) #>             A     B      C #>         <num> <num> <fctr> #> 1: -0.8041685     0    low #> 2:  1.3390885     0 medium #> 3:  0.9455804     0   high #> 4: -2.3437852     1    low #> 5: -0.9045554     1 medium #> 6:  0.8532361     1 medium dag_without_formula <- dag +   node(\"D\", type=\"gaussian\", parents=c(\"A\", \"B\"), betas=c(0.4, -2),        intercept=-8, error=1.5) dag_with_formula <- dag +   node(\"D\", type=\"gaussian\", formula= ~ -8 + A*0.4 + B*-2, error=1.5) set.seed(34) dat1 <- sim_from_dag(dag_without_formula, n_sim=100)  set.seed(34) dat2 <- sim_from_dag(dag_with_formula, n_sim=100)  all.equal(dat1, dat2) #> [1] TRUE"},{"path":"https://robindenz1.github.io/simDAG/articles/v_using_formulas.html","id":"using-a-categorical-parent-variable","dir":"Articles","previous_headings":"","what":"Using a Categorical Parent Variable","title":"Specifying Formulas in a DAG","text":"Suppose DD additionally depend CC, categorical variable. example, suppose regression model want generate data : D∼−8+⋅0.4+B⋅−2+Cmedium⋅−1+Chigh⋅−3+N(0,1.5).D \\sim -8 + \\cdot 0.4 + B \\cdot -2 + Cmedium \\cdot -1 + Chigh \\cdot -3 + N(0, 1.5). model, “low” category used reference category. want , using simple parents, betas, intercept approach longer works. use formula. Fortunately, really simple using following code: Essentially, use name categorical variable immediately followed category name. Note different reference category used, user needs re-define factor levels categorical variable accordingly first. Note also defined parents argument case. strictly necessary generate data case, recommended whenever categorical variables used formula two reasons: 1.) parents specified, sim_from_dag() function know CC parent DD. sort_dag=TRUE /nodes specified correctly topologically sorted order, may lead errors trying generate data. 2.) parents specified, functions take DAG objects input (plot.DAG() function) may produce incorrect output, won’t know CC parent DD.","code":"dag2 <- dag +   node(\"D\", type=\"gaussian\", error=1.5,        formula=~ -8 + A*0.4 + B*-2 + Cmedium*-1 + Chigh*-3,        parents=c(\"A\", \"B\", \"C\"))"},{"path":"https://robindenz1.github.io/simDAG/articles/v_using_formulas.html","id":"using-interaction-effects","dir":"Articles","previous_headings":"","what":"Using Interaction Effects","title":"Specifying Formulas in a DAG","text":"Interactions sort may also added DAG. Suppose want generate data following regression model: D∼−8+⋅0.4+B⋅−2+*B⋅−5+N(0,1.5),D \\sim -8 + \\cdot 0.4 + B \\cdot -2 + *B \\cdot -5 + N(0, 1.5), *BA*B indicates interaction AA BB. can specified formula argument using : sign: Since AA BB coded numeric variables , works fine. instead want include interaction includes categorical variable, use name respective category appended . example, following DAG includes interaction AA CC: Higher order interactions may specified exactly way, just using : symbols. may always obvious order variables interaction need specified. “wrong” order used, sim_from_dag() function return helpful error message explaining ones used instead. example, used “Cmedium:” instead “:Cmedium”, work internally latter recognized valid column. Note CC categorical, also specified parents argument just safe.","code":"dag3 <- dag +   node(\"D\", type=\"gaussian\", formula= ~ -8 + A*0.4 + B*-2 + A:B*-5, error=1.5) dag4 <- dag +   node(\"D\", type=\"gaussian\", error=1.5,        formula=~ -8 + A*0.4 + B*-2 + Cmedium*-1 + Chigh*-3 + A:Cmedium*0.3 +           A:Chigh*10,        parents=c(\"A\", \"B\", \"C\"))"},{"path":"https://robindenz1.github.io/simDAG/articles/v_using_formulas.html","id":"using-cubic-terms","dir":"Articles","previous_headings":"","what":"Using Cubic Terms","title":"Specifying Formulas in a DAG","text":"Sometimes also want include non-linear relationships continuous variable outcome data generation process. can done including cubic terms variable formula. Suppose regression model want use following form: D∼−8+⋅0.4+A2⋅0.02+B⋅−2+N(0,1.5).D \\sim -8 + \\cdot 0.4 + ^2 \\cdot 0.02 + B \\cdot -2 + N(0, 1.5). following code may used define node: Users may course use many cubic terms like.","code":"dag_with_formula <- dag +   node(\"D\", type=\"gaussian\", formula= ~ -8 + A*0.4 + I(A^2)*0.02 + B*-2,        error=1.5)"},{"path":"https://robindenz1.github.io/simDAG/articles/v_using_formulas.html","id":"using-functions-in-formula","dir":"Articles","previous_headings":"","what":"Using Functions in formula","title":"Specifying Formulas in a DAG","text":"also direct support including functions formula well. example, allowed call function beta coefficients, useful specify betas different scale (example using Odds-Ratios instead betas). example: valid syntax. function can used place log(), long single function called beta-coefficient. also possible use functions variables . However, required wrap () call. example, using something like ~ -3 + log()*0.5 + B*0.2 work, ~ -3 + (log())*0.5 + B*0.2 valid syntax. Although supported cases, strongly advise using function names special characters. might lead weird errors random effects random slopes also contained formula.","code":"dag_with_fun <- dag +   node(\"D\", type=\"binomial\", formula= ~ -3 + A*log(0.5) + B*0.2)"},{"path":"https://robindenz1.github.io/simDAG/articles/v_using_formulas.html","id":"using-special-characters-in-formula","dir":"Articles","previous_headings":"","what":"Using Special Characters in formula","title":"Specifying Formulas in a DAG","text":"Although recommended, possible use variable names containing special characters formula, escaping using usual R syntax. example, user wanted use -var variable name use variable parent node formula, done using following code: , however, six special characters may used formula: spaces, +, *, (, ) |. Errors may produced using characters variable names, used internally figure variables belong together (latter three mostly mixed model syntax). best avoid special characters though, just safe.","code":"dag_with_fun <- dag +   node(\"this-var\", type=\"binomial\", formula= ~ -3 + A*log(0.5) + B*0.2) +   node(\"D\", type=\"binomial\", formula= ~ 5 + `this-var`*0.3)"},{"path":"https://robindenz1.github.io/simDAG/articles/v_using_formulas.html","id":"using-random-effects-and-random-slopes","dir":"Articles","previous_headings":"","what":"Using Random Effects and Random Slopes","title":"Specifying Formulas in a DAG","text":"Currently, three node types (\"gaussian\", \"binomial\" \"poisson\") directly allow user specify random effects random slopes formula. specified exactly regular call lmer() function. example, consider following DAG: , School variable students different Ages nested. simulate Grade student, want use random intercept per School, simply add classic (1|School) term formula. Whenever done, var_corr argument also specified, allows users control standard deviation random effects. Internally, makeLmer() doSim() functions form simr package used simulate types nodes. Please consult documentation package details specify complex mixed model structures, example using multiple correlated random effects. principle, arbitrary amounts random effects can added. Random slopes can similarly defined using standard syntax. following DAG, use random slope Age per School addition random effect School: Note example, defined correlation random effect slopes using arbitrarily picked numbers using var_corr argument. much complex DGP computational overhead required re-structure data internally, simulations including mixed model syntax usually much slower simulations without . small samples issue, large values n_sim using specifications discrete-time simulations large max_t may difficult cases.","code":"dag_mixed <- empty_dag() +   node(\"School\", type=\"rcategorical\", probs=rep(0.1, 10),        labels=LETTERS[1:10]) +   node(\"Age\", type=\"rnorm\", mean=12, sd=2) +   node(\"Grade\", type=\"gaussian\", formula= ~ -2 + Age*1.2 + (1|School),        error=1, var_corr=0.3) var_corr <- matrix(c(0.5, 0.05, 0.05, 0.1), 2)  dag_mixed <- empty_dag() +   node(\"School\", type=\"rcategorical\", probs=rep(0.1, 10),        labels=LETTERS[1:10]) +   node(\"Age\", type=\"rnorm\", mean=12, sd=2) +   node(\"Grade\", type=\"gaussian\", formula= ~ -2 + Age*1.2 + (Age|School),        error=1, var_corr=var_corr)"},{"path":"https://robindenz1.github.io/simDAG/articles/v_using_formulas.html","id":"using-external-coefficients-advanced-usage","dir":"Articles","previous_headings":"","what":"Using External Coefficients (Advanced Usage)","title":"Specifying Formulas in a DAG","text":"Sometimes may useful define causal coefficients external variables, example writing function creates DAG objects set coefficients. supported use eval() function well. example: valid syntax. Note works variable wrapped eval() function call defined environment DAG object created. case, weird error messages may produced, depending code used. Another option put formula together string passing node() like : Since formula may always also passed single string, perfectly valid syntax might allow users even flexibility creating formulas inside functions.","code":"beta_coef <- log(0.5)  dag_with_external <- dag +   node(\"D\", type=\"binomial\", formula= ~ -3 + A*eval(beta_coef) + B*0.2) beta_coef <- log(0.5)  form_D <- paste(\"~ -3 + A*\", beta_coef, \"+ B*0.2\")  dag_with_external <- dag +   node(\"D\", type=\"binomial\", formula=form_D)"},{"path":"https://robindenz1.github.io/simDAG/articles/v_using_formulas.html","id":"using-formulas-in-custom-node-types-advanced-usage","dir":"Articles","previous_headings":"","what":"Using Formulas in Custom Node Types (Advanced Usage)","title":"Specifying Formulas in a DAG","text":"One great things package users can supply function type argument node() node_td(), long fulfills minimal requirements (described ?node_custom). Whenever function supplied, users may still use enhanced formula interface! Internally, whenever enhanced formula supplied node() node_td(), formula parsed extract variable names beta-coefficients. cubic terms, interactions levels categorical parent nodes included formula, data re-structured way includes single column term formula. Consider following example: , defined custom function node called custom_fun, really returns 1, regardless input. However, also prints first lines input data, parents, betas intercept passed, can see whats going hood. Next, defined arbitrary DAG containing two numerical root nodes binary root node. happens use custom_fun formula input: can see simply took data required printed . Note node() definition, need specify parents, betas intercept arguments custom node, pass enhanced formula happily extracted information passed custom_fun directly. requirement work custom_fun arguments. Now lets see happens special terms formula: Now can see slightly different picture. Instead simply returning relevant parts data, function re-structured way similar model.matrix() function, allowing us directly apply betas . Note betas always right order, meaning first entry betas corresponds first term named parents. following code example one re-build linear regression using interface: , simply calculate linear predictor using sum rows multiplying value corresponding betas coefficient add normally distributed error term standard deviation 1 afterwards. course users can use type strategy much complex node types. Note intercept required . omitting supplied function, automatically longer required formula (ignored still specified): Note passed custom_linreg function node() call instead, receive error message missing intercept. course also works time-dependent nodes specified using node_td() calls.","code":"set.seed(123)  custom_fun <- function(data, parents, betas, intercept) {   print(head(data))   print(parents)   print(betas)   print(intercept)   return(rep(1, nrow(data))) }  dag_custom <- empty_dag() +   node(c(\"A\", \"B\"), type=\"rnorm\", mean=0, sd=1) +   node(\"C\", type=\"rcategorical\", probs=c(0.5, 0.5), labels=c(\"lev1\", \"lev2\")) dag_custom2 <- dag_custom +   node(\"Y\", type=custom_fun, formula= ~ -5 + A*2 + B*-0.4)  data <- sim_from_dag(dag_custom2, n_sim=10) #>              A          B #>          <num>      <num> #> 1: -0.56047565  1.2240818 #> 2: -0.23017749  0.3598138 #> 3:  1.55870831  0.4007715 #> 4:  0.07050839  0.1106827 #> 5:  0.12928774 -0.5558411 #> 6:  1.71506499  1.7869131 #> [1] \"A\" \"B\" #> [1]  2.0 -0.4 #> [1] -5 dag_custom2 <- dag_custom +   node(\"Y\", type=custom_fun, formula= ~ -5 + A*2 + B*-0.4 + A:B*0.1 +           I(A^2)*-0.1 + Clev2*0.2)  data <- sim_from_dag(dag_custom2, n_sim=10) #>             A          B         A:B     I(A^2) Clev2 #>         <num>      <num>       <num>      <num> <num> #> 1:  0.4264642 -0.6947070 -0.29626767 0.18187173     0 #> 2: -0.2950715 -0.2079173  0.06135046 0.08706718     1 #> 3:  0.8951257 -1.2653964 -1.13268875 0.80124995     1 #> 4:  0.8781335  2.1689560  1.90463287 0.77111842     0 #> 5:  0.8215811  1.2079620  0.99243873 0.67499547     0 #> 6:  0.6886403 -1.1231086 -0.77341778 0.47422540     1 #> [1] \"A\"      \"B\"      \"A:B\"    \"I(A^2)\" \"Clev2\"  #> [1]  2.0 -0.4  0.1 -0.1  0.2 #> [1] -5 custom_linreg <- function(data, parents, betas, intercept) {   intercept + rowSums(mapply(\"*\", data, betas)) +     rnorm(n=nrow(data), mean=0, sd=1) }  dag_custom3 <- dag_custom +   node(\"Y\", type=custom_linreg, formula= ~ -5 + A*2 + B*-0.4 + A:B*0.1 +           I(A^2)*-0.1 + Clev2*0.2)  data <- sim_from_dag(dag_custom3, n_sim=100) head(data) #>             A          B      C         Y #>         <num>      <num> <char>     <num> #> 1:  0.3796395  1.0527115   lev1 -4.841552 #> 2: -0.5023235 -1.0491770   lev1 -4.906313 #> 3: -0.3332074 -1.2601552   lev1 -4.857700 #> 4: -1.0185754  3.2410399   lev2 -7.542767 #> 5: -1.0717912 -0.4168576   lev2 -6.029375 #> 6:  0.3035286  0.2982276   lev2 -4.522188 # same as before, but without an intercept (same as setting intercept=0) custom_linreg2 <- function(data, parents, betas) {   rowSums(mapply(\"*\", data, betas)) +     rnorm(n=nrow(data), mean=0, sd=1) }  dag_custom4 <- dag_custom +   node(\"Y\", type=custom_linreg2, formula= ~ A*2 + B*-0.4 + A:B*0.1 +           I(A^2)*-0.1 + Clev2*0.2)  data <- sim_from_dag(dag_custom4, n_sim=100) head(data) #>             A          B      C          Y #>         <num>      <num> <char>      <num> #> 1:  0.8719650 -0.8338436   lev1  2.4685174 #> 2: -0.3484724  0.5787224   lev1 -0.3442883 #> 3:  0.5185038 -1.0875807   lev2  2.2053315 #> 4: -0.3906850  1.4840309   lev1 -3.1403262 #> 5: -1.0927872 -1.1862066   lev2 -1.1321410 #> 6:  1.2100105  0.1010792   lev2  3.4132667"},{"path":"https://robindenz1.github.io/simDAG/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Robin Denz. Author, maintainer. Katharina Meiszl. Author.","code":""},{"path":"https://robindenz1.github.io/simDAG/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Robin Denz Nina Timmesfeld (2025): Simulating Complex Crossectional Longitudinal Data using simDAG R Package, arXiv preprint, doi: 10.48550/arXiv.2506.01498","code":"@Misc{,   title = {Simulating Complex Crossectional and Longitudinal Data using the simDAG R Package},   author = {Robin Denz and Nina Timmesfeld},   year = {2025},   doi = {10.48550/arXiv.2506.01498}, }"},{"path":"https://robindenz1.github.io/simDAG/index.html","id":"simdag-","dir":"","previous_headings":"","what":"Simulate Data from a DAG and Associated Node Information","title":"Simulate Data from a DAG and Associated Node Information","text":"Author: Robin Denz","code":""},{"path":"https://robindenz1.github.io/simDAG/index.html","id":"description","dir":"","previous_headings":"","what":"Description","title":"Simulate Data from a DAG and Associated Node Information","text":"simDAG R-Package can used generate data known directed acyclic graph (DAG) associated information distributions causal coefficients. root nodes sampled first subsequent child node generated according regression model (linear, logistic, multinomial, cox, …) function. result dataset causal structure specified DAG expectation distributions coefficients initially specified. also implements comprehensive framework conducting discrete-time simulations similar fashion.","code":""},{"path":"https://robindenz1.github.io/simDAG/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Simulate Data from a DAG and Associated Node Information","text":"stable version package can installed CRAN: developmental version may installed github using remotes R-Package:","code":"install.packages(\"simDAG\") library(remotes)  remotes::install_github(\"RobinDenz1/simDAG\")"},{"path":"https://robindenz1.github.io/simDAG/index.html","id":"bug-reports-and-feature-requests","dir":"","previous_headings":"","what":"Bug Reports and Feature Requests","title":"Simulate Data from a DAG and Associated Node Information","text":"encounter bugs specific feature requests, please file Issue.","code":""},{"path":"https://robindenz1.github.io/simDAG/index.html","id":"examples","dir":"","previous_headings":"","what":"Examples","title":"Simulate Data from a DAG and Associated Node Information","text":"Suppose want generate data following causal structure:  age normally distributed mean 50 standard deviation 4 sex bernoulli distributed p = 0.5 (equal number men women). “root nodes” (meaning parents - arrows pointing ) direct causal effect bmi. causal coefficients 1.1 0.4 respectively, intercept 12 sigma standard deviation 2. death modeled bernoulli variable, caused age bmi causal coefficients 0.1 0.3 respectively. intercept use -15. following code can used generate 10000 samples specifications: fitting appropriate regression models, can check data really approximately conform specifications. First, lets look bmi: seems right. Now look death: estimated coefficients also close ones specified. examples can found documentation multiple vignettes.","code":"library(simDAG)  dag <- empty_dag() +   node(\"age\", type=\"rnorm\", mean=50, sd=4) +   node(\"sex\", type=\"rbernoulli\", p=0.5) +   node(\"bmi\", type=\"gaussian\", formula= ~ 12 + age*1.1 + sex*0.4, error=2) +   node(\"death\", type=\"binomial\", formula= ~ -15 + age*0.1 + bmi*0.3)  set.seed(42)  sim_dat <- sim_from_dag(dag, n_sim=100000) mod_bmi <- glm(bmi ~ age + sex, data=sim_dat, family=\"gaussian\") summary(mod_bmi) #>  #> Call: #> glm(formula = bmi ~ age + sex, family = \"gaussian\", data = sim_dat) #>  #> Coefficients: #>             Estimate Std. Error t value Pr(>|t|)     #> (Intercept) 11.89194    0.07954  149.51   <2e-16 *** #> age          1.10220    0.00158  697.41   <2e-16 *** #> sexTRUE      0.40447    0.01268   31.89   <2e-16 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>  #> (Dispersion parameter for gaussian family taken to be 4.022026) #>  #>     Null deviance: 2361465  on 99999  degrees of freedom #> Residual deviance:  402190  on 99997  degrees of freedom #> AIC: 422971 #>  #> Number of Fisher Scoring iterations: 2 mod_death <- glm(death ~ age + bmi, data=sim_dat, family=\"binomial\") summary(mod_death) #>  #> Call: #> glm(formula = death ~ age + bmi, family = \"binomial\", data = sim_dat) #>  #> Coefficients: #>             Estimate Std. Error z value Pr(>|z|)     #> (Intercept) -14.6833     3.5538  -4.132  3.6e-05 *** #> age           0.2607     0.1698   1.535    0.125     #> bmi           0.1842     0.1402   1.314    0.189     #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>  #> (Dispersion parameter for binomial family taken to be 1) #>  #>     Null deviance: 258.65  on 99999  degrees of freedom #> Residual deviance: 214.03  on 99997  degrees of freedom #> AIC: 220.03 #>  #> Number of Fisher Scoring iterations: 13"},{"path":"https://robindenz1.github.io/simDAG/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Simulate Data from a DAG and Associated Node Information","text":"use package, please cite associated article: Denz, Robin Nina Timmesfeld (2025). Simulating Complex Crossectional Longitudinal Data using simDAG R Package. arXiv preprint, doi: 10.48550/arXiv.2506.01498.","code":""},{"path":"https://robindenz1.github.io/simDAG/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"Simulate Data from a DAG and Associated Node Information","text":"© 2024 Robin Denz contents repository distributed GNU General Public License. can find full text License github repository. Alternatively, see http://www.gnu.org/licenses/.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/add_node.html","id":null,"dir":"Reference","previous_headings":"","what":"Add a DAG.node or a DAG.network object to a DAG object — add_node","title":"Add a DAG.node or a DAG.network object to a DAG object — add_node","text":"function allows users add DAG.node objects created using node node_td function DAG.network objects created using network network_td function DAG objects created using empty_dag function, makes easy fully specify DAG use sim_from_dag function sim_discrete_time.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/add_node.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add a DAG.node or a DAG.network object to a DAG object — add_node","text":"","code":"add_node(dag, node)  # S3 method for class 'DAG' object_1 + object_2"},{"path":"https://robindenz1.github.io/simDAG/reference/add_node.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add a DAG.node or a DAG.network object to a DAG object — add_node","text":"dag DAG object created using empty_dag function. node Either DAG.node object created using node function node_td function, DAG.network object created using network function network_td function. object_1 Either DAG object, DAG.node object DAG.network object. order objects change result. object_2 See argument object_1.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/add_node.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add a DAG.node or a DAG.network object to a DAG object — add_node","text":"two ways adding node network DAG object : dag <- add_node(dag, node(...)) dag <- dag + node(...), give identical results (note ... replaced actual arguments initial dag created call empty_dag). See node information specify DAG use sim_from_dag node_td functions.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/add_node.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add a DAG.node or a DAG.network object to a DAG object — add_node","text":"Returns DAG object DAG.node object DAG.network object added .","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/add_node.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Add a DAG.node or a DAG.network object to a DAG object — add_node","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/add_node.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add a DAG.node or a DAG.network object to a DAG object — add_node","text":"","code":"library(simDAG)  ## add nodes to DAG using + dag <- empty_dag() +   node(\"age\", type=\"rnorm\", mean=50, sd=5) +   node(\"sex\", type=\"rbernoulli\", p=0.5) +   node(\"income\", type=\"gaussian\", parents=c(\"age\", \"sex\"), betas=c(1.1, 0.2),        intercept=-5, error=4)  ## add nodes to DAG using add_node() dag <- empty_dag() dag <- add_node(dag, node(\"age\", type=\"rnorm\", mean=50, sd=5))"},{"path":"https://robindenz1.github.io/simDAG/reference/as.dagitty.DAG.html","id":null,"dir":"Reference","previous_headings":"","what":"Transform a DAG object into a dagitty object — as.dagitty.DAG","title":"Transform a DAG object into a dagitty object — as.dagitty.DAG","text":"function extends .dagitty function dagitty package allow input DAG object. result dagitty object includes structure DAG, without specifications. May useful perform identifiability checks etc. DAG.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/as.dagitty.DAG.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transform a DAG object into a dagitty object — as.dagitty.DAG","text":"","code":"# S3 method for class 'DAG' as.dagitty(x, include_root_nodes=TRUE,            include_td_nodes=TRUE, include_networks=FALSE,            layout=FALSE, ...)"},{"path":"https://robindenz1.github.io/simDAG/reference/as.dagitty.DAG.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transform a DAG object into a dagitty object — as.dagitty.DAG","text":"x DAG object created using empty_dag function nodes added using + syntax. See ?empty_dag ?node details. Supports DAGs time-dependent nodes added using node_td function. However, including DAGs may result cyclic causal structures, time represented output matrix. include_root_nodes Whether include root nodes output matrix. usually kept TRUE (default). include_td_nodes Whether include time-dependent nodes added dag using node_td function . including types nodes, possible adjacency matrix contain cycles, e.g. classic DAG anymore, due matrix representing passage time. include_networks Whether include time-fixed networks added dag using network function . Usually make sense include , classical nodes. layout Corresponds argument name dagitty function. ... Currently used.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/as.dagitty.DAG.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Transform a DAG object into a dagitty object — as.dagitty.DAG","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/as.dagitty.DAG.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Transform a DAG object into a dagitty object — as.dagitty.DAG","text":"Returns dagitty object.","code":""},{"path":[]},{"path":"https://robindenz1.github.io/simDAG/reference/as.dagitty.DAG.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Transform a DAG object into a dagitty object — as.dagitty.DAG","text":"","code":"library(simDAG)  # some example DAG dag <- empty_dag() +   node(\"death\", type=\"binomial\", parents=c(\"age\", \"sex\"), betas=c(1, 2),        intercept=-10) +   node(\"age\", type=\"rnorm\", mean=10, sd=2) +   node(\"sex\", parents=\"\", type=\"rbernoulli\", p=0.5) +   node(\"smoking\", parents=c(\"sex\", \"age\"), type=\"binomial\",        betas=c(0.6, 0.2), intercept=-2)  if (requireNamespace(\"dagitty\")) {   g <- dagitty::as.dagitty(dag) }"},{"path":"https://robindenz1.github.io/simDAG/reference/as.igraph.DAG.html","id":null,"dir":"Reference","previous_headings":"","what":"Transform a DAG object into an igraph object — as.igraph.DAG","title":"Transform a DAG object into an igraph object — as.igraph.DAG","text":"function extends .igraph function igraph package allow input DAG object. result igraph object includes structure DAG, without specifications. May useful plotting purposes.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/as.igraph.DAG.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transform a DAG object into an igraph object — as.igraph.DAG","text":"","code":"# S3 method for class 'DAG' as.igraph(x, include_root_nodes=TRUE,           include_td_nodes=TRUE, include_networks=FALSE, ...)"},{"path":"https://robindenz1.github.io/simDAG/reference/as.igraph.DAG.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transform a DAG object into an igraph object — as.igraph.DAG","text":"x DAG object created using empty_dag function nodes added using + syntax. See ?empty_dag ?node details. Supports DAGs time-dependent nodes added using node_td function. However, including DAGs may result cyclic causal structures, time represented output matrix. include_root_nodes Whether include root nodes output matrix. usually kept TRUE (default). include_td_nodes Whether include time-dependent nodes added dag using node_td function . including types nodes, possible adjacency matrix contain cycles, e.g. classic DAG anymore, due matrix representing passage time. include_networks Whether include time-fixed networks added dag using network function . Usually make sense include , classical nodes. ... Currently used.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/as.igraph.DAG.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Transform a DAG object into an igraph object — as.igraph.DAG","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/as.igraph.DAG.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Transform a DAG object into an igraph object — as.igraph.DAG","text":"Returns igraph object.","code":""},{"path":[]},{"path":"https://robindenz1.github.io/simDAG/reference/as.igraph.DAG.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Transform a DAG object into an igraph object — as.igraph.DAG","text":"","code":"library(simDAG)  # some example DAG dag <- empty_dag() +   node(\"death\", type=\"binomial\", parents=c(\"age\", \"sex\"), betas=c(1, 2),        intercept=-10) +   node(\"age\", type=\"rnorm\", mean=10, sd=2) +   node(\"sex\", parents=\"\", type=\"rbernoulli\", p=0.5) +   node(\"smoking\", parents=c(\"sex\", \"age\"), type=\"binomial\",        betas=c(0.6, 0.2), intercept=-2)  if (requireNamespace(\"igraph\")) {   g <- igraph::as.igraph(dag)   plot(g) }"},{"path":"https://robindenz1.github.io/simDAG/reference/dag2matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Obtain a Adjacency Matrix from a DAG object — dag2matrix","title":"Obtain a Adjacency Matrix from a DAG object — dag2matrix","text":"sim_from_dag function requires user specify causal relationships inside DAG object containing node information. function takes object input outputs underlying adjacency matrix. can useful plot theoretical DAG check nodes specified correctly.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/dag2matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Obtain a Adjacency Matrix from a DAG object — dag2matrix","text":"","code":"dag2matrix(dag, include_root_nodes=TRUE, include_td_nodes=FALSE,            include_networks=FALSE)"},{"path":"https://robindenz1.github.io/simDAG/reference/dag2matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Obtain a Adjacency Matrix from a DAG object — dag2matrix","text":"dag DAG object created using empty_dag function nodes added using + syntax. See ?empty_dag ?node details. Supports DAGs time-dependent nodes added using node_td function. However, including DAGs may result cyclic causal structures, time represented output matrix. include_root_nodes Whether include root nodes output matrix. usually kept TRUE (default). include_td_nodes Whether include time-dependent nodes added dag using node_td function . including types nodes, possible adjacency matrix contain cycles, e.g. classic DAG anymore, due matrix representing passage time. include_networks Whether include time-fixed networks added dag using network function . Usually make sense include , classical nodes. mostly used internally ensure generation nodes networks processed right order.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/dag2matrix.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Obtain a Adjacency Matrix from a DAG object — dag2matrix","text":"adjacency matrix simply square matrix node one column one row associated . example, node causal effect node B, matrix contain 1 spot matrix[\"\", \"B\"]. time-varying node also defined time-fixed node, parents parts pooled creating output matrix.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/dag2matrix.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Obtain a Adjacency Matrix from a DAG object — dag2matrix","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/dag2matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Obtain a Adjacency Matrix from a DAG object — dag2matrix","text":"Returns numeric square matrix one row one column per used node dag.","code":""},{"path":[]},{"path":"https://robindenz1.github.io/simDAG/reference/dag2matrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Obtain a Adjacency Matrix from a DAG object — dag2matrix","text":"","code":"library(simDAG)  # some example DAG dag <- empty_dag() +   node(\"death\", type=\"binomial\", parents=c(\"age\", \"sex\"), betas=c(1, 2),        intercept=-10) +   node(\"age\", type=\"rnorm\", mean=10, sd=2) +   node(\"sex\", parents=\"\", type=\"rbernoulli\", p=0.5) +   node(\"smoking\", parents=c(\"sex\", \"age\"), type=\"binomial\",        betas=c(0.6, 0.2), intercept=-2)  # get adjacency matrix dag2matrix(dag) #>         age sex death smoking #> age       0   0     1       1 #> sex       0   0     1       1 #> death     0   0     0       0 #> smoking   0   0     0       0  # get adjacency matrix using only the child nodes dag2matrix(dag, include_root_nodes=FALSE) #>         death smoking #> death       0       0 #> smoking     0       0  ## adding time-varying nodes dag <- dag +   node_td(\"disease\", type=\"time_to_event\", parents=c(\"age\", \"smoking\"),           prob_fun=0.01) +   node_td(\"cve\", type=\"time_to_event\", parents=c(\"age\", \"sex\", \"smoking\",                                                  \"disease\"),           prob_fun=0.001, event_duration=Inf)  # get adjacency matrix including all nodes dag2matrix(dag, include_td_nodes=TRUE) #>         age sex death smoking disease cve #> age       0   0     1       1       1   1 #> sex       0   0     1       1       0   1 #> death     0   0     0       0       0   0 #> smoking   0   0     0       0       1   1 #> disease   0   0     0       0       0   1 #> cve       0   0     0       0       0   0  # get adjacency matrix including only time-constant nodes dag2matrix(dag, include_td_nodes=FALSE) #>         age sex death smoking #> age       0   0     1       1 #> sex       0   0     1       1 #> death     0   0     0       0 #> smoking   0   0     0       0  # get adjacency matrix using only the child nodes dag2matrix(dag, include_root_nodes=FALSE) #>         death smoking #> death       0       0 #> smoking     0       0"},{"path":"https://robindenz1.github.io/simDAG/reference/dag_from_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Fills a partially specified DAG object with parameters estimated from reference data — dag_from_data","title":"Fills a partially specified DAG object with parameters estimated from reference data — dag_from_data","text":"Given partially specified DAG object, name, type parents specified plus data.frame containing realizations nodes, return fully specified DAG (beta-coefficients, intercepts, errors, ...). returned DAG can used directly simulate data sim_from_dag function.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/dag_from_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fills a partially specified DAG object with parameters estimated from reference data — dag_from_data","text":"","code":"dag_from_data(dag, data, return_models=FALSE, na.rm=FALSE)"},{"path":"https://robindenz1.github.io/simDAG/reference/dag_from_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fills a partially specified DAG object with parameters estimated from reference data — dag_from_data","text":"dag partially specified DAG object created using empty_dag node functions. See ?node detailed description . nodes need contain information name, type parents. attributes added (overwritten already ) using function. Currently support DAGs time-dependent nodes added node_td function. data data.frame data.table used obtain parameters needed DAG object. needs contain column every node specified dag argument. return_models Whether return list models fit estimate information child nodes (elements dag parents argument NULL). na.rm Whether remove missing values .","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/dag_from_data.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fills a partially specified DAG object with parameters estimated from reference data — dag_from_data","text":"works: can cumbersome specify node information needed simulation, especially lot nodes consider. Additionally, data available, natural fit appropriate models data get empirical estimate node information simulation. function automates process. user reasonable DAG knows node types, fast way generate synthetic data corresponds well empirical data. user create minimal DAG object including information parents, name node type. root nodes, required distribution parameters extracted data. child nodes, regression models corresponding specified type fit data using parents independent covariates name dependent variable. required information extracted models added respective node. output contains fully specified DAG object can used directly sim_from_dag function. may also include list containing fitted models inspection, return_models=TRUE. Supported root node types: Currently, following root node types supported: \"rnorm\": Estimates parameters normal distribution. \"rbernoulli\": Estimates p parameter Bernoulli distribution. \"rcategorical\": Estimates class probabilities categorical distribution. types need implemented user. Supported child node types: Currently, following child node types supported: \"gaussian\": Estimates parameters node type \"gaussian\". \"binomial\": Estimates parameters node type \"binomial\". \"poisson\": Estimates parameters node type \"poisson\". \"negative_binomial\": Estimates parameters node type \"negative_binomial\". \"conditional_prob\": Estimates parameters node type \"conditional_prob\". types need implemented user. Support custom nodes: sim_from_dag function supports custom node functions, described associated vignette. impossible us directly support custom types function directly. However, user can extend function easily accommodate /custom types. Similar defining custom node type, user simply write function returns correctly specified node.DAG object, given named arguments name, parents, type, data return_model. first three arguments simply added directly output. data used inside function fit model obtain required parameters way. return_model argument control whether model added output (named argument called model). function name paste0(\"gen_node_\", YOURTYPE). examples given . Interactions & cubic terms: function currently support usage interaction effects non-linear terms (using ~ B + (B^2) formula). Instead, assumed values parents linear effect respective node. example, using parents=c(\"\", \"B\") node named \"C\" use formula C ~ + B. behavior desired, users need integrate custom function described .","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/dag_from_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fills a partially specified DAG object with parameters estimated from reference data — dag_from_data","text":"list length two containing new fully specified DAG object named dag list fitted models (return_models=TRUE) object named models.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/dag_from_data.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Fills a partially specified DAG object with parameters estimated from reference data — dag_from_data","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/dag_from_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fills a partially specified DAG object with parameters estimated from reference data — dag_from_data","text":"","code":"library(simDAG)  set.seed(457456)  # get some example data from a known DAG dag <- empty_dag() +   node(\"death\", type=\"binomial\", parents=c(\"age\", \"sex\"), betas=c(1, 2),        intercept=-10) +   node(\"age\", type=\"rnorm\", mean=10, sd=2) +   node(\"sex\", parents=\"\", type=\"rbernoulli\", p=0.5) +   node(\"smoking\", parents=c(\"sex\", \"age\"), type=\"binomial\",        betas=c(0.6, 0.2), intercept=-2)  data <- sim_from_dag(dag=dag, n_sim=1000)  # suppose we only know the causal structure and the node type: dag <- empty_dag() +   node(\"death\", type=\"binomial\", parents=c(\"age\", \"sex\")) +   node(\"age\", type=\"rnorm\") +   node(\"sex\", type=\"rbernoulli\") +   node(\"smoking\", type=\"binomial\", parents=c(\"sex\", \"age\"))  # get parameter estimates from data dag_full <- dag_from_data(dag=dag, data=data)  # can now be used to simulate data data2 <- sim_from_dag(dag=dag_full$dag, n_sim=100)"},{"path":"https://robindenz1.github.io/simDAG/reference/do.html","id":null,"dir":"Reference","previous_headings":"","what":"Pearls do-operator for DAG objects — do","title":"Pearls do-operator for DAG objects — do","text":"function can used set one nodes given DAG object specific value, corresponds intervention DAG defined -operator introduced Judea Pearl.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/do.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pearls do-operator for DAG objects — do","text":"","code":"do(dag, names, values)"},{"path":"https://robindenz1.github.io/simDAG/reference/do.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pearls do-operator for DAG objects — do","text":"dag DAG object created using empty_dag node functions. See ?node information specify DAG. names character string specifying names nodes dag object. value nodes set corresponding value specified values argument. node already defined dag, new one added without warning. values vector list values. nodes defined names argument set values.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/do.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Pearls do-operator for DAG objects — do","text":"Internally function simply removes old node definition nodes names replaces new node definition defines node constant value, irrespective original definition. effect can created directly specifying DAG way start (see examples). function alter original DAG place. Instead, returns modified version DAG. words, using (dag, names=\"\", values=3) change dag object.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/do.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pearls do-operator for DAG objects — do","text":"Returns DAG object updated node definitions.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/do.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Pearls do-operator for DAG objects — do","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/do.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Pearls do-operator for DAG objects — do","text":"Judea Pearl (2009). Causality: Models, Reasoning Inference. 2nd ed. Cambridge: Cambridge University Press","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/do.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Pearls do-operator for DAG objects — do","text":"","code":"library(simDAG)  # define some initial DAG dag <- empty_dag() +   node(\"death\", \"binomial\", c(\"age\", \"sex\"), betas=c(1, 2), intercept=-10) +   node(\"age\", type=\"rnorm\", mean=10, sd=2) +   node(\"sex\", parents=\"\", type=\"rbernoulli\", p=0.5) +   node(\"smoking\", parents=c(\"sex\", \"age\"), type=\"binomial\",        betas=c(0.6, 0.2), intercept=-2)  # return new DAG with do(smoking = TRUE) dag2 <- do(dag, names=\"smoking\", values=TRUE)  # which is equivalent to dag2 <- empty_dag() +   node(\"death\", \"binomial\", c(\"age\", \"sex\"), betas=c(1, 2), intercept=-10) +   node(\"age\", type=\"rnorm\", mean=10, sd=2) +   node(\"sex\", parents=\"\", type=\"rbernoulli\", p=0.5) +   node(\"smoking\", type=\"rconstant\", constant=TRUE)  # use do() on multiple variables: do(smoking = TRUE, sex = FALSE) dag2 <- do(dag, names=c(\"smoking\", \"sex\"), values=list(TRUE, FALSE))"},{"path":"https://robindenz1.github.io/simDAG/reference/empty_dag.html","id":null,"dir":"Reference","previous_headings":"","what":"Initialize an empty DAG object — empty_dag","title":"Initialize an empty DAG object — empty_dag","text":"function used conjunction multiple calls node node_td create DAG object, can used simulate data using sim_from_dag sim_discrete_time functions.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/empty_dag.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Initialize an empty DAG object — empty_dag","text":"","code":"empty_dag()"},{"path":"https://robindenz1.github.io/simDAG/reference/empty_dag.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Initialize an empty DAG object — empty_dag","text":"Note function used initialize empty DAG object. Actual information respective nodes added using node function node_td function. documentation page function contains information correctly .","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/empty_dag.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Initialize an empty DAG object — empty_dag","text":"Returns empty DAG object.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/empty_dag.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Initialize an empty DAG object — empty_dag","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/empty_dag.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Initialize an empty DAG object — empty_dag","text":"","code":"library(simDAG)  # just an empty DAG empty_dag() #> An empty DAG object without any nodes.  # adding a node to it empty_dag() + node(\"age\", type=\"rnorm\", mean=20, sd=5) #> A DAG object with: #>   -  1  nodes in total #>   -  1  of which are root nodes #>   -  0  of which are child nodes #>   -  0  of which are time-varying nodes #>   -  0  imposed network structure(s)"},{"path":"https://robindenz1.github.io/simDAG/reference/long2start_stop.html","id":null,"dir":"Reference","previous_headings":"","what":"Transform a data.table in the long-format to a data.table in the start-stop format — long2start_stop","title":"Transform a data.table in the long-format to a data.table in the start-stop format — long2start_stop","text":"function transforms data.table long-format (one row per person per time point) data.table start-stop format (one row per person-specific period variables changed).","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/long2start_stop.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transform a data.table in the long-format to a data.table in the start-stop format — long2start_stop","text":"","code":"long2start_stop(data, id, time, varying, overlap=FALSE,                 check_inputs=TRUE)"},{"path":"https://robindenz1.github.io/simDAG/reference/long2start_stop.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transform a data.table in the long-format to a data.table in the start-stop format — long2start_stop","text":"data data.table object can coerced data.table (data.frame) including data long-format. id single character string specifying unique person identifier included data. time single character string specifying time variable included data coded integers starting 1. varying character vector specifying names variables included data may change time. overlap Specifies whether intervals overlap . TRUE, \"stop\" column simply increased one, compared output overlap=FALSE. means changes given \\(t\\) recorded start next interval, previous interval ends day. check_inputs Whether check user input correct . Can turned setting FALSE save computation time.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/long2start_stop.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Transform a data.table in the long-format to a data.table in the start-stop format — long2start_stop","text":"function relies data.table syntax make data transformation RAM efficient fast possible.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/long2start_stop.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Transform a data.table in the long-format to a data.table in the start-stop format — long2start_stop","text":"Returns data.table containing columns .id (unique person identifier), .time (integer variable encoding time) variables included input data long format.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/long2start_stop.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Transform a data.table in the long-format to a data.table in the start-stop format — long2start_stop","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/long2start_stop.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Transform a data.table in the long-format to a data.table in the start-stop format — long2start_stop","text":"","code":"library(simDAG) library(data.table)  # generate example data in long format long <- data.table(.id=rep(seq_len(10), each=5),                    .time=rep(seq_len(5), 10),                    A=c(rep(FALSE, 43), TRUE, TRUE, rep(FALSE, 3), TRUE,                            TRUE),                    B=FALSE) setkey(long, .id, .time)  # transform to start-stop format long2start_stop(data=long, id=\".id\", time=\".time\", varying=c(\"A\", \"B\")) #>       .id start  stop      A      B #>     <int> <int> <int> <lgcl> <lgcl> #>  1:     1     1     5  FALSE  FALSE #>  2:     2     1     5  FALSE  FALSE #>  3:     3     1     5  FALSE  FALSE #>  4:     4     1     5  FALSE  FALSE #>  5:     5     1     5  FALSE  FALSE #>  6:     6     1     5  FALSE  FALSE #>  7:     7     1     5  FALSE  FALSE #>  8:     8     1     5  FALSE  FALSE #>  9:     9     1     3  FALSE  FALSE #> 10:     9     4     5   TRUE  FALSE #> 11:    10     1     3  FALSE  FALSE #> 12:    10     4     5   TRUE  FALSE"},{"path":"https://robindenz1.github.io/simDAG/reference/matrix2dag.html","id":null,"dir":"Reference","previous_headings":"","what":"Obtain a DAG object from a Adjacency Matrix and a List of Node Types — matrix2dag","title":"Obtain a DAG object from a Adjacency Matrix and a List of Node Types — matrix2dag","text":"sim_from_dag function requires user specify causal relationships inside DAG object containing node information. function creates object using adjacency matrix list node types. resulting DAG partially specified, may useful dag_from_data function.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/matrix2dag.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Obtain a DAG object from a Adjacency Matrix and a List of Node Types — matrix2dag","text":"","code":"matrix2dag(mat, type)"},{"path":"https://robindenz1.github.io/simDAG/reference/matrix2dag.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Obtain a DAG object from a Adjacency Matrix and a List of Node Types — matrix2dag","text":"mat p x p adjacency matrix p number variables. matrix filled zeros. places variable specified row direct causal effect variable specified column 1. columns rows named corresponding variable names. type named list one entry variable mat, specifying type corresponding node. See node available node types.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/matrix2dag.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Obtain a DAG object from a Adjacency Matrix and a List of Node Types — matrix2dag","text":"adjacency matrix simply square matrix node one column one row associated . example, node causal effect node B, matrix contain 1 spot matrix[\"\", \"B\"]. function uses kind matrix additional information node type create DAG object. resulting DAG used sim_from_dag function directly, contain necessary parameters beta-coefficients intercepts etc. may, however, passed directly dag_from_data function. pretty much valid use-case. goal specify full DAG manually, user use empty_dag function conjunction node calls instead, described respective documentation pages vignettes. output never contain time-dependent nodes. necessary, user needs manually define DAG.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/matrix2dag.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Obtain a DAG object from a Adjacency Matrix and a List of Node Types — matrix2dag","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/matrix2dag.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Obtain a DAG object from a Adjacency Matrix and a List of Node Types — matrix2dag","text":"Returns partially specified DAG object.","code":""},{"path":[]},{"path":"https://robindenz1.github.io/simDAG/reference/matrix2dag.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Obtain a DAG object from a Adjacency Matrix and a List of Node Types — matrix2dag","text":"","code":"library(simDAG)  # simple example adjacency matrix mat <- matrix(c(0, 0, 1, 0, 0, 1, 0, 0, 0), ncol=3, byrow=TRUE) colnames(mat) <- c(\"age\", \"sex\", \"death\") rownames(mat) <- c(\"age\", \"sex\", \"death\")  type <- list(age=\"rnorm\", sex=\"rbernoulli\", death=\"binomial\")  matrix2dag(mat=mat, type=type) #> A DAG object with: #>   -  3  nodes in total #>   -  2  of which are root nodes #>   -  1  of which are child nodes #>   -  0  of which are time-varying nodes #>   -  0  imposed network structure(s)"},{"path":"https://robindenz1.github.io/simDAG/reference/net.html","id":null,"dir":"Reference","previous_headings":"","what":"Specify Network Dependencies in a DAG — net","title":"Specify Network Dependencies in a DAG — net","text":"function may used formula nodes value observation one individual dependent ' neighbors defined static network dynamic network_td. Given network previously generated variable, net() aggregates data neighbors according arbitrary function hood. resulting variable can used directly formula.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/net.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Specify Network Dependencies in a DAG — net","text":"","code":"net(expr, net=NULL, mode=\"all\", order=1,     mindist=0, na=NA)"},{"path":"https://robindenz1.github.io/simDAG/reference/net.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Specify Network Dependencies in a DAG — net","text":"expr R expression, usually containing one previously generated variables, returns one numeric value given vector, sum(variable) mean(variable). net single character string specifying name network used define neighbors observation. one network present DAG, argument can omitted. single added network used default. multiple networks present argument defined, error produced. mode single character, specifying use direction edges directed network supplied (ignored otherwise). \"\", direction edges ignored incoming outgoing edges used define neighbors individual. \"\", individuals \\(\\) (observation row) pointing used neighbors \"\" individuals point \\(\\) used neighbors. order single integer giving order neighborhood. order=1 (default), vertices directly connected vertex \\(\\) considered neighbors. order=2, vertices connected neighbors also considered neighbors vertex \\(\\) . mindist single integer >= 0, specifying minimum distance neighbors needs observation considered neighbors. makes sense order > 1. na single value assigned variable expr computed. can happen due nature expression (e.g. NA returned directly evaluating expression reason), observation neighbors network.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/net.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Specify Network Dependencies in a DAG — net","text":"works: Internally following procedure used whenever net() function call included formula node (regardless whether time-fixed time-dependent). First, associated network (defined using net argument) used identify neighbors observation. Every vertex directly connected observation considered ' neighbor. parent variable(s) specified net() call aggregated neighbors using given expr. simple example: consider observation 1 four neighbors named 2, 5, 8 10. formula contains following net() call: net(sum(infected)). value infected variable 0, 0, 1, 1 persons 2, 5, 8 10 respectively. values summed result value 2 person 1. done every person simulated data. resulting variable used -simulation. Supported inputs: function returns single (usually numeric) value, given neighbors' values can used. therefore also possible make simulation dependent specific neighbors . example, using infected[1] instead sum(infected) return value 0 observation 1 example, person 2 first neighbor value 0. Note internally used variable named ..neighbor.. includes ids neighbors. entire expr evaluated data.table call form: data[, .(variable = eval(expr)), =id], making also possible use data.table syntax .N (return number neighbors person ). Specifying parents: Whenever net() call used formula, recommend specifying parents argument node well. reason recommendation , sometimes difficult identify variables used net() calls, depending expr. may cause issues DAG specified topologically sorted manner users rely sort_dag argument sim_from_dag re-order variables. Specifying parents ensures issue occur. small warning: Note never really makes sense use function outside formula argument: look source code realize actually anything, except returning input. piece syntax formula interface. Please consult network documentation page associated vignette information.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/net.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Specify Network Dependencies in a DAG — net","text":"\"Returns\" vector length n_sim used properly sim_from_dag sim_discrete_time call. Returns list input used outside formula.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/net.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Specify Network Dependencies in a DAG — net","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/net.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Specify Network Dependencies in a DAG — net","text":"","code":"library(igraph) #>  #> Attaching package: ‘igraph’ #> The following objects are masked from ‘package:stats’: #>  #>     decompose, spectrum #> The following object is masked from ‘package:base’: #>  #>     union library(data.table) library(simDAG)  # define a random network for illustration, with 10 vertices set.seed(234) g <- igraph::sample_smallworld(1, 10, 2, 0.5)  # a simple dag containing only two time-constant variables and the network dag <- empty_dag() +   node(\"A\", type=\"rnorm\", mean=0, sd=1) +   node(\"B\", type=\"rbernoulli\", p=0.5) +   network(\"Net1\", net=g)  # using the mean of A of each observations neighbor in a linear model dag2 <- dag +   node(\"Y\", type=\"gaussian\", formula= ~ -2 + net(mean(A))*4, error=1)  # using an indicator of whether any of an observations neighbors has # a 1 in B in a linear model dag3 <- dag +   node(\"Y\", type=\"gaussian\", formula= ~ 1.5 + net(as.numeric(any(B==1)))*3,        error=1.2)"},{"path":"https://robindenz1.github.io/simDAG/reference/network.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a network object for a DAG — network","title":"Create a network object for a DAG — network","text":"functions (conjunction empty_dag node functions) allow users create DAG objects one , possibly time-varying, network structures linking individual observations . makes possible simulate data complex network-based dependencies among observations using sim_from_dag function sim_discrete_time function.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/network.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a network object for a DAG — network","text":"","code":"network(name, net, parents=NULL, ...)  network_td(name, net, parents=NULL, create_at_t0=TRUE, ...)"},{"path":"https://robindenz1.github.io/simDAG/reference/network.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a network object for a DAG — network","text":"name single character string, specifying name network. Contrary node function, multiple values allowed, defining network multiple times make sense. net network(), two kinds inputs allowed. first igraph object containing one vertex per observation (e.g. n_sim vertices) generated later calling sim_from_dag sim_discrete_time. second function generates object, given named argument called n_sim number named arguments. network_td(), latter kind input allowed. vertices network defined variable named. Instead, vertex index 1 represents row 1 generated data, vertex index 2 represents second row . information given details section. parents character vector names, specifying parents network NULL (default). Similar general nodes, specifying parents allows users generate network function values parents, whenever net function. NULL, assumed network generated independently data (already passed igraph object). convenience, also allowed set parents=\"\" indicate node parents. create_at_t0 Either TRUE FALSE, specifying whether network generated time 0 discrete-time simulations (e.g. time-independent nodes networks generated) creation data time 0. Defaults TRUE. ... Optional named arguments passed net function.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/network.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a network object for a DAG — network","text":"mean add network DAG? using node node_td define DAG, observations usually generated independently (explicitly done otherwise using custom node function). reflects classic ..d. assumption frequently used everywhere. data generation processes, however, assumption insufficient. spread infectious disease classic example. network() function allows users relax assumption, making possible define one networks can added DAG objects using + syntax. networks contain single vertex observation generated, placing row dataset one place network. use net function possible define new nodes function neighbors observation, neighbors vertex defined vertex directly connected node. example, one use capability use mean age observations neighbors regression model, use number infected neighbors model probability infection. combining network-simulation approach already extensive simulation capabilities DAG based simulations, almost DGP can modelled. approach described rigorously excellent paper given Sofrygin et al. (2017). Supported network types: Users may add number networks DAG object, making possible embed individuals multiple distinct networks time. networks can used simultaneously define single multiple (possibly time-varying) nodes, using multiple net function calls respective formula arguments. also possible define time-varying dynamic networks change time, possibly function generated data, simulation time previous states network. Examples given associated vignette. package directly supports un-directed directed, un-weighted weighted networks. also supports different definitions neighbors observation . Note, however, networks include exactly one vertex per observation supported. Weighted Networks: possible supply weighted networks network(). weights also stored available user using net function internal ..weight.. variable. example, weighted network supplied, following valid syntax: net(weighted.mean(, ..weight..)) (assuming previously defined variable). Note ..weight.. must used explicitly, otherwise weights ignored. Directed Networks: Supplying directed networks also possible. done, users usually need specify mode argument net function defining formula arguments. argument allows users define different kinds neighborhoods observation, based direction edges. Order Generation: Generally, networks created order added DAG, unless sort_dag tx_nodes_order changed sim_from_dag sim_discrete_time respectively. exception networks created using network() function created root nodes already generated. Computational considerations: Including net() terms node might significantly increase amount RAM used required computation time, especially large networks / large values n_sim / max_t (latter relevant discrete-time simulations using sim_discrete_time). reason time node generated updated time, mapping individuals neighbors' values plus subsequent aggregation performed, required merge() calls etc. Usually problem, might large discrete-time simulations. net call used multiple nodes can beneficial put extra node call safe avoid re-calculating thing (see examples). information: theoretical treatment, please consult paper Sofrygin et al. (2017), also describe slightly different implementation method simcausal package. information specify network-based dependencies DAG (using simDAG) adding network, please consult net documentation page associated vignette.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/network.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a network object for a DAG — network","text":"Returns DAG.network object can added DAG object directly.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/network.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Create a network object for a DAG — network","text":"Sofrygin, Oleg, Romain Neugebauer Mark J. van der Laan (2017). Conducting Simulations Causal Inference Networks-Based Structural Equation Models. arXiv preprint, doi: 10.48550/arXiv.1705.10376","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/network.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create a network object for a DAG — network","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/network.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a network object for a DAG — network","text":"","code":"library(igraph) library(data.table) library(simDAG)  set.seed(2368)  # generate random undirected / unweighted networks as examples g1 <- igraph::sample_gnm(n=20, m=30) g2 <- igraph::sample_gnm(n=20, m=30)  # adding a single network to a DAG, with Y being dependent on # the mean value of A of its neighbors dag <- empty_dag() +   network(\"Net1\", net=g1) +   node(\"A\", type=\"rnorm\") +   node(\"Y\", type=\"gaussian\", formula= ~ -2 + net(mean(A))*1.3, error=1.5)  # NOTE: because we supplied the network of size 20 directly, we can only #       use n_sim=20 here data <- sim_from_dag(dag, n_sim=20)  # using multiple networks, with Y being differently dependent on # the mean value of A of its neighbors in both networks dag <- empty_dag() +   network(\"Net1\", net=g1) +   network(\"Net2\", net=g2) +   node(\"A\", type=\"rnorm\") +   node(\"Y\", type=\"gaussian\", formula= ~ -2 + net(mean(A), net=\"Net1\")*1.3 +         net(mean(A), net=\"Net2\")*-2, error=1.5)  # using a function to add networks, to allow any value of 'n_sim' later  # exemplary function that returns a random network of size 'n_sim' gen_network <- function(n_sim) {   igraph::sample_gnm(n=n_sim, m=30) }  # same as first example, but using the function as input dag <- empty_dag() +   network(\"Net1\", net=gen_network) +   node(\"A\", type=\"rnorm\") +   node(\"Y\", type=\"gaussian\", formula= ~ -2 + net(mean(A))*1.3, error=1.5) data <- sim_from_dag(dag, n_sim=25)"},{"path":"https://robindenz1.github.io/simDAG/reference/node.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a node object for a DAG — node","title":"Create a node object for a DAG — node","text":"functions used conjunction empty_dag function create DAG objects, can used simulate data using sim_from_dag function sim_discrete_time function.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a node object for a DAG — node","text":"","code":"node(name, type, parents=NULL, formula=NULL, ...)  node_td(name, type, parents=NULL, formula=NULL, ...)"},{"path":"https://robindenz1.github.io/simDAG/reference/node.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a node object for a DAG — node","text":"name character vector least one entry specifying name node. character vector containing multiple different names supplied, one separate node created name. nodes completely independent, exact node definition supplied user. single character string provided, one node generated. type single character string specifying type node. Depending whether node root node, child node time-dependent node different node types allowed. See details. Alternatively, suitable function may passed directly argument. parents character vector names, specifying parents node NULL (default). NULL, node treated root node. convenience also allowed set parents=\"\" indicate node root node. formula optional formula object describe node generated NULL (default). supplied start ~, nothing else left hand side. right hand side define entire structural equation, including betas intercepts. may contain valid formula syntax, ~ -2 + *3 + B*4 ~ -2 + *3 + B*4 + (^2)*0.3 + :B*1.1, allowing arbitrary non-linear effects, arbitrary interactions multiple coefficients categorical variables. Additionally, node types, random effects random slopes supported. argument defined, need define betas intercept argument. parents argument still specified whenever categorical variable used formula. argument supported build-nodes type \"binomial\", \"gaussian\", \"poisson\", \"negative_binomial\", \"cox\", \"aftreg\", \"ahreg\", \"ehreg\", \"poreg\" \"ypreg\" custom node defined user. also supported nodes type \"identity\", slightly different input expected case. See examples associated vignette -depth explanation. ... named arguments needed specify node. can parameters distribution functions p argument rbernoulli function root nodes arbitrary named arguments betas argument node_gaussian function.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a node object for a DAG — node","text":"generate data using sim_from_dag function sim_discrete_time function, required create DAG object first. object needs contain information causal structure data (e.g. variable causes variable) specific structural equations variable (information causal coefficients, type distribution etc.). package, node /node_td function used conjunction empty_dag function create object. works first initializing empty DAG using empty_dag function adding multiple calls node /node_td functions using simple +, call node /node_td adds information single node generated. Multiple examples given . call node node_td user needs indicate node called (name), function used generate node (type), whether node parents (parents) additional arguments needed actually call data-generating function node later passed three-dot syntax (...). node vs. node_td: calling node indicating node time-fixed variable generated . using node_td indicating time-dependent node, updated step time using discrete-time simulation. node_td used planning perform discrete-time simulation sim_discrete_time function. DAG objects including time-dependent nodes may used sim_from_dag function. Implemented Root Node Types: function can used generate root nodes. requirement function least one named argument called n controls length resulting vector. example, user specify node type \"rnorm\" create normally distributed node parents. argument n set internally, additional arguments can specified using ... syntax. type=\"rnorm\" example, user set mean standard deviation using node(name=\"example\", type=\"rnorm\", mean=10, sd=5). convenience, package additionally includes four custom root-node functions: \"rbernoulli\": Draws randomly bernoulli distribution. \"rcategorical\": Draws randomly discrete probability density function. \"rsample\": Draws random samples given vector. \"rconstant\": Used set variable constant value. Implemented Child Node Types: Currently, following node types implemented directly convenience: \"gaussian\": node based (mixed) linear regression. \"binomial\": node based (mixed) binomial regression. \"conditional_prob\": node based conditional probabilities. \"conditional_distr\": node based conditional draws different distributions. \"multinomial\": node based multinomial regression. \"poisson\": node based (mixed) poisson regression. \"negative_binomial\": node based negative binomial regression. \"zeroinfl\": node based zero-inflated poisson negative binomial regression. \"identity\": node just R expression nodes. \"mixture\": node mixture different node definitions. \"cox\": node based cox-regression. \"aftreg\": node based accelerated failure time model. \"ahreg\": node based accelerated hazard model. \"ehreg\": node based extended hazard model. \"poreg\": node based proportional odds model. \"ypreg\": node based Young Prentice model. custom child node types, see consult vignette custom node definitions. Implemented Time-Dependent Node Types: Currently, following node types implemented directly convenience use node_td calls: \"time_to_event\": node based repeatedly checking whether event occurs point time. \"competing_events\": node based repeatedly checking whether one multiple mutually exclusive events occurs point time. However, user may also use child node types node_td call directly. custom time-dependent node types, please consult associated vignette. Custom Node Types simple write new custom node_function used instead, allowing user use type data-generation mechanism type node (root / child / time-dependent). required function , named arguments data (sample generated far) , child node, parents (character vector specifying parents) outputs either vector containing n_sim entries, data.frame n_sim rows arbitrary amount columns. information can found associated vignette: vignette(topic=\"v_custom_nodes\", package=\"simDAG\"). Using child nodes parents nodes: data generated child node categorical (using node_multinomial) can still used parents nodes standard node types without issues. user use formula argument supply enhanced formula, instead defining parents betas argument directly. works well node types directly support formula input custom nodes specified user. See associated vignette: vignette(topic=\"v_using_formulas\", package=\"simDAG\") information correctly use formulas. Cyclic causal structures: name DAG (directed acyclic graph) implies cycles allowed. means start node follow arrows direction pointing, way get back original node. necessary theoretically practical reasons dealing static DAGs created using node function. user attempts generate data static cyclic graph using sim_from_dag function, error produced. However, realm discrete-time simulations, cyclic causal structures perfectly reasonable. variable \\(\\) \\(t = 1\\) may influence variable \\(B\\) \\(t = 2\\), turn may influence variable \\(\\) \\(t = 3\\) . Therefore, using node_td function simulate time-dependent data using sim_discrete_time function, cyclic structures allowed present error produced.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Create a node object for a DAG — node","text":"Contrary R standard, function support partial matching argument names. means supplying nam=\"age\" recognized name=\"age\" instead added additional node argument used respective data-generating function call using sim_from_dag.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a node object for a DAG — node","text":"Returns DAG.node object can added DAG object directly.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create a node object for a DAG — node","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a node object for a DAG — node","text":"","code":"library(simDAG)  # creating a DAG with a single root node dag <- empty_dag() +   node(\"age\", type=\"rnorm\", mean=30, sd=4)  # creating a DAG with multiple root nodes # (passing the functions directly to 'type' works too) dag <- empty_dag() +   node(\"sex\", type=rbernoulli, p=0.5) +   node(\"income\", type=rnorm, mean=2700, sd=500)  # creating a DAG with multiple root nodes + multiple names in one node dag <- empty_dag() +   node(\"sex\", type=\"rbernoulli\", p=0.5) +   node(c(\"income_1\", \"income_2\"), type=\"rnorm\", mean=2700, sd=500)  # also using child nodes dag <- empty_dag() +   node(\"sex\", type=\"rbernoulli\", p=0.5) +   node(\"income\", type=\"rnorm\", mean=2700, sd=500) +   node(\"sickness\", type=\"binomial\", parents=c(\"sex\", \"income\"),        betas=c(1.2, -0.3), intercept=-15) +   node(\"death\", type=\"binomial\", parents=c(\"sex\", \"income\", \"sickness\"),        betas=c(0.1, -0.4, 0.8), intercept=-20)  # creating the same DAG as above, but using the enhanced formula interface dag <- empty_dag() +   node(\"sex\", type=\"rbernoulli\", p=0.5) +   node(\"income\", type=\"rnorm\", mean=2700, sd=500) +   node(\"sickness\", type=\"binomial\",        formula= ~ -15 + sexTRUE*1.2 + income*-0.3) +   node(\"death\", type=\"binomial\",        formula= ~ -20 + sexTRUE*0.1 + income*-0.4 + sickness*0.8)  # using time-dependent nodes # NOTE: to simulate data from this DAG, the sim_discrete_time() function needs #       to be used due to \"sickness\" being a time-dependent node dag <- empty_dag() +   node(\"sex\", type=\"rbernoulli\", p=0.5) +   node(\"income\", type=\"rnorm\", mean=2700, sd=500) +   node_td(\"sickness\", type=\"binomial\", parents=c(\"sex\", \"income\"),           betas=c(0.1, -0.4), intercept=-50)  # we could also use a DAG with only time-varying variables dag <- empty_dag() +   node_td(\"vaccine\", type=\"time_to_event\", prob_fun=0.001, event_duration=21) +   node_td(\"covid\", type=\"time_to_event\", prob_fun=0.01, event_duration=15,           immunity_duration=100)"},{"path":"https://robindenz1.github.io/simDAG/reference/node_binomial.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Data from a (Mixed) Binomial Regression Model — node_binomial","title":"Generate Data from a (Mixed) Binomial Regression Model — node_binomial","text":"Data parents used generate node using binomial regression (usually logistic regression) predicting covariate specific probability sampling Bernoulli distribution accordingly. Allows inclusion arbitrary random effects slopes logistic models.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_binomial.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Data from a (Mixed) Binomial Regression Model — node_binomial","text":"","code":"node_binomial(data, parents, formula=NULL, betas, intercept,               return_prob=FALSE, output=\"logical\", labels=NULL,               var_corr=NULL, link=\"logit\")"},{"path":"https://robindenz1.github.io/simDAG/reference/node_binomial.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Data from a (Mixed) Binomial Regression Model — node_binomial","text":"data data.table (something can coerced data.table) containing columns specified parents. parents character vector specifying names parents particular child node . non-linear combinations interaction effects included, user may specify formula argument instead. formula optional formula object describe node generated NULL (default). supplied start ~, nothing else left hand side. right hand side may contain valid formula syntax, + B + B + (^2), allowing non-linear effects. argument defined, need define parents argument. example, using parents=c(\"\", \"B\") equal using formula= ~ + B. May contain random effects random slopes, case simr package used generate data. See details. betas numeric vector length equal parents, specifying causal beta coefficients used generate node. intercept single number specifying intercept used generating node. return_prob Either TRUE FALSE (default). TRUE, calculated probability returned instead results bernoulli trials. argument ignored random effects random slopes specified formula input. output single character string, must either \"logical\" (default), \"numeric\", \"character\" \"factor\". output=\"character\" output=\"factor\", labels (levels case factor) can set using labels argument. labels character vector length 2 NULL (default). NULL, resulting vector returned . character vector supplied output=\"character\" output=\"factor\" used, TRUE values replaced first entry vector FALSE values replaced second argument vector. output character variable factor variable, depending output argument. argument ignored output set \"numeric\" \"logical\". var_corr Variances covariances random effects. used formula contains mixed model syntax. multiple random effects, parameters supplied named list. complex structures also supported. argument directly passed makeLmer function simr package. Please consult documentation package information mixed models specified. guidance can also found \"Issues\" section official simr github page. link link function used transform linear predictor probability scale. standard logistic regression model, set \"logit\" (default). allowed values \"identity\", \"probit\", \"log\", \"cloglog\" \"cauchit\", defined way classic glm function.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_binomial.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Data from a (Mixed) Binomial Regression Model — node_binomial","text":"Using normal form logistic regression model, observation specific event probability generated every observation dataset. Using rbernoulli function, probability used take one bernoulli sample observation dataset. probability returned return_prob set TRUE. Formal Description: Formally, data generation (using link=\"logit\") can described : $$Y \\sim Bernoulli(logit(\\texttt{intercept} + \\texttt{parents}_1 \\cdot \\texttt{betas}_1 + ... + \\texttt{parents}_n \\cdot \\texttt{betas}_n)),$$ \\(Bernoulli(p)\\) denotes one Bernoulli trial success probability \\(p\\), \\(n\\) number parents (length(parents)) \\(logit(x)\\) function defined : $$logit(x) = ln(\\frac{x}{1-x}).$$ example, given intercept=-15, parents=c(\"\", \"B\") betas=c(0.2, 1.3) data generation process defined : $$Y \\sim Bernoulli(logit(-15 + \\cdot 0.2 + B \\cdot 1.3)).$$ works way link functions, difference \\(logit()\\) replaced. Output Format: default function returns logical vector containing TRUE FALSE entries, TRUE corresponds event FALSE event. may changed using output labels arguments. last three arguments function ignored return_prob set TRUE. Random Effects Random Slopes: function also allows users include arbitrary amounts random slopes random effects using formula argument. done, formula, data arguments passed variables name makeGlmer function simr package. fixef argument function passed numeric vector c(intercept, betas) VarCorr argument receives var_corr argument input. used node type DAG, taken care behind scenes. Users can simply use regular enhanced formula interface node function define formula terms, shown detail formula vignette (vignette(topic=\"v_using_formulas\", package=\"simDAG\")). Please consult vignette examples. Also, please note inclusion random effects random slopes usually results significantly longer computation times.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_binomial.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generate Data from a (Mixed) Binomial Regression Model — node_binomial","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_binomial.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Data from a (Mixed) Binomial Regression Model — node_binomial","text":"Returns logical vector (numeric vector return_prob=TRUE) length nrow(data).","code":""},{"path":[]},{"path":"https://robindenz1.github.io/simDAG/reference/node_binomial.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Data from a (Mixed) Binomial Regression Model — node_binomial","text":"","code":"library(simDAG)  set.seed(5425)  # define needed DAG dag <- empty_dag() +   node(\"age\", type=\"rnorm\", mean=50, sd=4) +   node(\"sex\", type=\"rbernoulli\", p=0.5) +   node(\"smoking\", type=\"binomial\", parents=c(\"age\", \"sex\"),        betas=c(1.1, 0.4), intercept=-2)  # define the same DAG, but using a pretty formula dag <- empty_dag() +   node(\"age\", type=\"rnorm\", mean=50, sd=4) +   node(\"sex\", type=\"rbernoulli\", p=0.5) +   node(\"smoking\", type=\"binomial\",        formula= ~ -2 + age*1.1 + sexTRUE*0.4)  # simulate data from it sim_dat <- sim_from_dag(dag=dag, n_sim=100)  # returning only the estimated probability instead dag <- empty_dag() +   node(\"age\", type=\"rnorm\", mean=50, sd=4) +   node(\"sex\", type=\"rbernoulli\", p=0.5) +   node(\"smoking\", type=\"binomial\", parents=c(\"age\", \"sex\"),        betas=c(1.1, 0.4), intercept=-2, return_prob=TRUE)  sim_dat <- sim_from_dag(dag=dag, n_sim=100)  ## an example using a random effect if (requireNamespace(\"simr\")) {  library(simr)  dag_mixed <- empty_dag() +   node(\"School\", type=\"rcategorical\", probs=rep(0.1, 10),        labels=LETTERS[1:10]) +   node(\"Age\", type=\"rnorm\", mean=12, sd=2) +   node(\"Grade\", type=\"binomial\", formula= ~ -10 + Age*1.2 + (1|School),        var_corr=0.3)  sim_dat <- sim_from_dag(dag=dag_mixed, n_sim=100) } #> Loading required namespace: simr #> Loading required package: lme4 #> Loading required package: Matrix #>  #> Attaching package: ‘simr’ #> The following object is masked from ‘package:lme4’: #>  #>     getData #> The following object is masked from ‘package:igraph’: #>  #>     compare"},{"path":"https://robindenz1.github.io/simDAG/reference/node_competing_events.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Data with Multiple Mutually Exclusive Events in Discrete-Time Simulation — node_competing_events","title":"Generate Data with Multiple Mutually Exclusive Events in Discrete-Time Simulation — node_competing_events","text":"node essentially models categorical time-dependent variable time type event important later usage. adds two columns data: name_event (type event person currently experiencing) name_time (time current event started). Can used inside sim_discrete_time function, outside . Past events kind stored two lists. See details.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_competing_events.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Data with Multiple Mutually Exclusive Events in Discrete-Time Simulation — node_competing_events","text":"","code":"node_competing_events(data, parents, sim_time, name,                       prob_fun, ..., event_duration=c(1, 1),                       immunity_duration=max(event_duration),                       save_past_events=TRUE, check_inputs=TRUE,                       envir)"},{"path":"https://robindenz1.github.io/simDAG/reference/node_competing_events.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Data with Multiple Mutually Exclusive Events in Discrete-Time Simulation — node_competing_events","text":"data data.table containing columns specified parents. Similar objects data.frames supported. parents character vector specifying names parents particular child node . sim_time current time simulation. name name node. used prefix _event, _time, _past_event_times _past_event_kind columns. prob_fun function returns numeric matrix nrow(data) rows one column storing probabilities occurrence possible event type plus column events. example, two possible events recurrence death, matrix need contain three columns. first storing probability -event two columns storing probabilities recurrence death per person. Since numbers probabilities, matrix contain numbers 0 1 sum 1 row. numbers specify person-specific probability experiencing events modeled node particular point time simulation. corresponding event generated internally using rcategorical function. ... arbitrary number additional named arguments passed prob_fun. Ignore want pass arguments. event_duration numeric vector containing one positive integer type event interest, specifying long event last. example, interested modelling time cardiovascular event death competing event, argument need 2 entries. One specify duration cardiovascular event Inf (death terminal event). immunity_duration single number >= max(event_duration) specifying long person immune events experiencing one. count internally starts event starts, order use immunity duration 10 time units event max(event_duration) + 10 used. save_past_events event modeled using node recurrent (immunity_duration < Inf & (event_duration < Inf)), person may experience multiple events course simulation. generally stored ce_past_events list ce_past_causes list included output sim_discrete_time function. extends runtime increases RAM usage, interested timing previous events using save_states=\"\" functionality can turned setting argument FALSE check_inputs Whether perform plausibility checks user input . set TRUE default, can set FALSE order speed things using function simulation study something similar. envir used internally efficiently store past event times. used user.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_competing_events.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Data with Multiple Mutually Exclusive Events in Discrete-Time Simulation — node_competing_events","text":"performing discrete-time simulation using sim_discrete_time function, standard node functions implemented package usually sufficient capture time-dependent nature interesting variables. Often, variable modelled probability occurring point time. occur, kind influence variables period time goes back normal (). car crash, surgery, vaccination etc. node_time_to_event node function can used model kinds nodes fairly straightforward fashion. function extended version node_time_to_event function. Instead simulating binary event, can generate multiple competing events, occurrence one event time \\(t\\) mutually exclusive occurrence event time. words, multiple events possible, one can occur time. Works: \\(t = 1\\), node initialized first time. adds two columns data: name_event (whether person currently event) name_time (time current event started) name name node. Additionally, adds list max_t entries ce_past_events list returned sim_discrete_time function, records individuals experienced new event point time. ce_past_causes list additionally records kind event happened time. nutshell, simply models occurrence event calculating probability occurrence \\(t\\) drawing single multinomial trial probability. trial \"success\", corresponding event column set drawn event type (described using integers, 0 event events numbered consecutively), time column set current simulation time \\(t\\) columns storing past event times types receive entry. event column stay new integer value event . duration controlled event_duration parameter. modeling terminal events death, one can simply set parameter Inf, making event eternal. many cases also necessary implement kind immunity event, can done using immunity_duration argument. effectively sets probability another occurrence event 0 next immunity_duration time steps. immunity duration, event may > 0 (event still ongoing) 0 (event_duration event type already passed). probability occurrence calculated using function provided user using prob_fun argument. can arbitrary complex function. requirement takes data first argument. columns defined parents argument passed argument automatically. argument called sim_time, current time simulation automatically passed well. arguments can passed using prob_fun_args argument. simple example multinomial logistic regression node, probabilities calculated additive linear combination columns defined parents. complex function include simulation-time dependent effects, effects dependent past event times etc. Examples can found vignettes. can done : type node naturally support implementation competing events, may terminal recurrent nature may influenced pretty much anything. specifying parents prob_fun arguments correctly, possible create event type dependent past events time--event variables variables general. user can include amount nodes simulation. may also used simulate kind binary time-dependent variable one usually associate name \"event\" well. flexible, require user coding . done : function may used generate competing events, meaning occurrence event 1 \\(t = 1\\) makes impossible event 2 \\(t = 1\\) occur. user wants generate multiple events mutually exclusive, may add multiple node_time_to_event based nodes dag argument sim_discrete_time function. fact, competing events node may simulated using multiple calls node_time_to_event based nodes well, defining prob_fun argument nodes way occurrence event makes occurrence event B impossible. might actually easier implement situations, require user manually define probability function outputs matrix subject-specific probabilities.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_competing_events.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generate Data with Multiple Mutually Exclusive Events in Discrete-Time Simulation — node_competing_events","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_competing_events.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Data with Multiple Mutually Exclusive Events in Discrete-Time Simulation — node_competing_events","text":"Returns data.table containing updated columns node.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_competing_events.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Generate Data with Multiple Mutually Exclusive Events in Discrete-Time Simulation — node_competing_events","text":"function called outside sim_discrete_time function. makes sense use type node_td function call, described documentation vignettes.","code":""},{"path":[]},{"path":"https://robindenz1.github.io/simDAG/reference/node_competing_events.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Data with Multiple Mutually Exclusive Events in Discrete-Time Simulation — node_competing_events","text":"","code":"library(simDAG)  ## a competing_events node with only terminal events, all with a constant ## probability of occurrence, independent of any other variable prob_death_illness <- function(data) {    # simply repeat the same probabilities for everyone   n <- nrow(data)   p_mat <- matrix(c(rep(0.9, n), rep(0.005, n), rep(0.005, n)),                   byrow = FALSE, ncol=3)    return(p_mat) }  dag <- empty_dag() +   node_td(\"death_illness\", type=\"competing_events\", prob_fun=prob_death_illness,           event_duration=c(Inf, Inf))  ## making one of the event-types terminal and the other recurrent dag <- empty_dag() +   node_td(\"death_illness\", type=\"competing_events\", prob_fun=prob_death_illness,           event_duration=c(15, Inf))  ## call the sim_discrete_time function to generate data from it sim <- sim_discrete_time(dag, n_sim=100, max_t=500)  ## more examples on how to use the sim_discrete_time function can be found ## in the documentation page of the node_time_to_event function and ## in the package vignettes"},{"path":"https://robindenz1.github.io/simDAG/reference/node_conditional_distr.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Data by Sampling from Different Distributions based on Strata — node_conditional_distr","title":"Generate Data by Sampling from Different Distributions based on Strata — node_conditional_distr","text":"function can used generate kind dichotomous, categorical numeric variables dependent one categorical variables randomly sampling user-defined distributions strata defined nodes parents. even flexible node type, allowing arbitrary node definitions different subsets previously generated data included node_mixture.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_conditional_distr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Data by Sampling from Different Distributions based on Strata — node_conditional_distr","text":"","code":"node_conditional_distr(data, parents, distr, default_distr=NULL,                        default_distr_args=list(), default_val=NA_real_,                        coerce2numeric=TRUE, check_inputs=TRUE)"},{"path":"https://robindenz1.github.io/simDAG/reference/node_conditional_distr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Data by Sampling from Different Distributions based on Strata — node_conditional_distr","text":"data data.table (something can coerced data.table) containing columns specified parents. parents character vector specifying names parents particular child node . distr named list element corresponds one stratum defined parents. one name given parents, means one element possible values variable given parents. node multiple parents, needs one element possible combinations parents (see examples). values elements list , first argument callable function (rnorm, rcategorical, ...) rest named arguments function. function can used, long returns vector n values, n argument function. n set internally based stratum size set user. list contain one element possible strata defined parents, default_val default_distr arguments used. default_distr function used generate values strata explicitly mentioned distr argument, NULL (default). NULL, default_val argument used fill missing strata values.  function passed argument contain argument n, define number samples generate. return vector n values. examples (), rnorm rbernoulli. default_distr_args named list arguments passed function defined default_distr argument. Ignored default_distr NULL. default_val single value used output strata mentioned distr. Ignored default_distr NULL. coerce2numeric single logical value specifying whether try coerce resulting variable numeric . check_inputs single logical value specifying whether perform input checks . May set TRUE speed things little sure input correct.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_conditional_distr.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Data by Sampling from Different Distributions based on Strata — node_conditional_distr","text":"Utilizing user-defined distribution stratum parents (supplied using distr argument), function simply calls user-defined function arguments given user generate new variable. allows new variable consist mix different distributions, based categorical parents. Formal Description: Formally, data generation process can described series conditional equations. example, suppose just one parent node sex levels male female goal creating continuous outcome normal distribution \\(N(10, 3)\\) males \\(N(7, 2)\\) females. conditional equation : $$Y \\sim \\begin{cases} \t\t\tN(10, 3), & \\text{} \\texttt{sex=\"male\"} \\\\ \t\t\tN(7, 2), & \\text{} \\texttt{sex=\"female\"} \\\\ \t\t\\end{cases},$$ two variables, conditional distribution stratified intersection subgroups defined variables.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_conditional_distr.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generate Data by Sampling from Different Distributions based on Strata — node_conditional_distr","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_conditional_distr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Data by Sampling from Different Distributions based on Strata — node_conditional_distr","text":"Returns numeric vector length nrow(data).","code":""},{"path":[]},{"path":"https://robindenz1.github.io/simDAG/reference/node_conditional_distr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Data by Sampling from Different Distributions based on Strata — node_conditional_distr","text":"","code":"library(simDAG)  set.seed(42)  #### with one parent node ####  # define conditional distributions distr <- list(male=list(\"rnorm\", mean=100, sd=5),               female=list(\"rcategorical\", probs=c(0.1, 0.2, 0.7)))  # define DAG dag <- empty_dag() +   node(\"sex\", type=\"rcategorical\", labels=c(\"male\", \"female\"),        output=\"factor\", probs=c(0.4, 0.6)) +   node(\"chemo\", type=\"rbernoulli\", p=0.5) +   node(\"A\", type=\"conditional_distr\", parents=\"sex\", distr=distr)  # generate data data <- sim_from_dag(dag=dag, n_sim=1000)   #### with two parent nodes ####  # define conditional distributions with interaction between parents distr <- list(male.FALSE=list(\"rnorm\", mean=100, sd=5),               male.TRUE=list(\"rnorm\", mean=100, sd=20),               female.FALSE=list(\"rbernoulli\", p=0.5),               female.TRUE=list(\"rcategorical\", probs=c(0.1, 0.2, 0.7)))  # define DAG dag <- empty_dag() +   node(\"sex\", type=\"rcategorical\", labels=c(\"male\", \"female\"),        output=\"factor\", probs=c(0.4, 0.6)) +   node(\"chemo\", type=\"rbernoulli\", p=0.5) +   node(\"A\", type=\"conditional_distr\", parents=c(\"sex\", \"chemo\"), distr=distr)  # generate data data <- sim_from_dag(dag=dag, n_sim=1000)"},{"path":"https://robindenz1.github.io/simDAG/reference/node_conditional_prob.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Data Using Conditional Probabilities — node_conditional_prob","title":"Generate Data Using Conditional Probabilities — node_conditional_prob","text":"function can used generate dichotomous categorical variables dependent one categorical variables probabilities occurrence strata defined variables known.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_conditional_prob.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Data Using Conditional Probabilities — node_conditional_prob","text":"","code":"node_conditional_prob(data, parents, probs, default_probs=NULL,                       default_val=NA, labels=NULL,                       coerce2factor=FALSE, check_inputs=TRUE)"},{"path":"https://robindenz1.github.io/simDAG/reference/node_conditional_prob.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Data Using Conditional Probabilities — node_conditional_prob","text":"data data.table (something can coerced data.table) containing columns specified parents. parents character vector specifying names parents particular child node . probs named list element corresponds one stratum defined parents. one name given parents, means one element possible value variable given parents. node multiple parents, needs one element possible combinations parents (see examples). values elements either single number, corresponding probability occurrence single event/value case dichotomous variable, vector probabilities sum 1, corresponding class probabilities. either case, length elements . possible strata parents (possible combinations case multiple parents) omitted, result set default_val omitted strata. See argument default_val argument default_probs alternative. default_probs possible strata parents included probs, user may set default probabilities omitted strata. example, three strata (, B C) defined parents probs contains defined probabilities strata , probabilities strata B C can set simultaneously using argument. single value 0 1 Bernoulli trials numeric vector sum 1 multinomial trials. NULL (default) value produced output missing strata set default_val (see ). default_val Value produced variable strata included probs argument. default_probs NULL, arguments functionality used instead. labels vector labels generated output. NULL (default) output dichotomous, logical variable returned. NULL output categorical, simply uses integers starting 1 class labels. coerce2factor single logical value specifying whether return drawn events factor . check_inputs single logical value specifying whether input checks performed . Set FALSE save computation time simulations.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_conditional_prob.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Data Using Conditional Probabilities — node_conditional_prob","text":"Utilizing user-defined discrete probability distribution stratum parents (supplied using probs argument), function simply calls either rbernoulli rcategorical function. Formal Description: Formally, data generation process can described series conditional equations. example, suppose just one parent node sex levels male female goal creating binary outcome probability occurrence 0.5 males 0.7 females. conditional equation : $$Y \\sim Bernoulli(p),$$ : $$p = \\begin{cases} \t\t\t0.5, & \\text{} \\texttt{sex=\"male\"} \\\\ \t\t\t0.7, & \\text{} \\texttt{sex=\"female\"} \\\\ \t\t\\end{cases},$$ \\(Bernoulli(p)\\) Bernoulli distribution success probability \\(p\\). outcome two categories, Bernoulli distribution replaced \\(Multinomial(p)\\) \\(p\\) replaced matrix class probabilities. two variables, conditional distribution stratified intersection subgroups defined variables. even flexible node type, allowing arbitrary node definitions different subsets previously generated data included node_mixture.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_conditional_prob.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generate Data Using Conditional Probabilities — node_conditional_prob","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_conditional_prob.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Data Using Conditional Probabilities — node_conditional_prob","text":"Returns numeric vector length nrow(data).","code":""},{"path":[]},{"path":"https://robindenz1.github.io/simDAG/reference/node_conditional_prob.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Data Using Conditional Probabilities — node_conditional_prob","text":"","code":"library(simDAG)  set.seed(42)  #### two classes, one parent node ####  # define conditional probs probs <- list(male=0.5, female=0.8)  # define DAG dag <- empty_dag() +   node(\"sex\", type=\"rcategorical\", labels=c(\"male\", \"female\"),        output=\"factor\", probs=c(0.5, 0.5)) +   node(\"chemo\", type=\"rbernoulli\", p=0.5) +   node(\"A\", type=\"conditional_prob\", parents=\"sex\", probs=probs)  # generate data data <- sim_from_dag(dag=dag, n_sim=1000)   #### three classes, one parent node ####  # define conditional probs probs <- list(male=c(0.5, 0.2, 0.3), female=c(0.8, 0.1, 0.1))  # define DAG dag <- empty_dag() +   node(\"sex\", type=\"rcategorical\", labels=c(\"male\", \"female\"),        output=\"factor\", probs=c(0.5, 0.5)) +   node(\"chemo\", type=\"rbernoulli\", p=0.5) +   node(\"A\", type=\"conditional_prob\", parents=\"sex\", probs=probs)  # generate data data <- sim_from_dag(dag=dag, n_sim=1000)   #### two classes, two parent nodes ####  # define conditional probs probs <- list(male.FALSE=0.5,               male.TRUE=0.8,               female.FALSE=0.1,               female.TRUE=0.3)  # define DAG dag <- empty_dag() +   node(\"sex\", type=\"rcategorical\", labels=c(\"male\", \"female\"),        output=\"factor\", probs=c(0.5, 0.5)) +   node(\"chemo\", type=\"rbernoulli\", p=0.5) +   node(\"A\", type=\"conditional_prob\", parents=c(\"sex\", \"chemo\"), probs=probs)  # generate data data <- sim_from_dag(dag=dag, n_sim=1000)   #### three classes, two parent nodes ####  # define conditional probs probs <- list(male.FALSE=c(0.5, 0.1, 0.4),               male.TRUE=c(0.8, 0.1, 0.1),               female.FALSE=c(0.1, 0.7, 0.2),               female.TRUE=c(0.3, 0.4, 0.3))  # define dag dag <- empty_dag() +   node(\"sex\", type=\"rcategorical\", labels=c(\"male\", \"female\"),        output=\"factor\", probs=c(0.5, 0.5)) +   node(\"chemo\", type=\"rbernoulli\", p=0.5) +   node(\"A\", type=\"conditional_prob\", parents=c(\"sex\", \"chemo\"), probs=probs)  # generate data data <- sim_from_dag(dag=dag, n_sim=1000)"},{"path":"https://robindenz1.github.io/simDAG/reference/node_cox.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Data from a Cox-Regression Model — node_cox","title":"Generate Data from a Cox-Regression Model — node_cox","text":"Data parents used generate node using cox-regression using method Bender et al. (2005).","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_cox.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Data from a Cox-Regression Model — node_cox","text":"","code":"node_cox(data, parents, formula=NULL, betas, surv_dist, lambda, gamma,          cens_dist, cens_args, name, as_two_cols=TRUE)"},{"path":"https://robindenz1.github.io/simDAG/reference/node_cox.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Data from a Cox-Regression Model — node_cox","text":"data data.table (something can coerced data.table) containing columns specified parents. parents character vector specifying names parents particular child node . non-linear combinations interaction effects included, user may specify formula argument instead. formula optional formula object describe node generated NULL (default). supplied start ~, nothing else left hand side. right hand side may contain valid formula syntax, + B + B + (^2), allowing non-linear effects. argument defined, need define parents argument. example, using parents=c(\"\", \"B\") equal using formula= ~ + B. betas numeric vector length equal parents, specifying causal beta coefficients used generate node. surv_dist single character specifying distribution used generating survival times. Can either \"weibull\" \"exponential\". lambda single number used parameter defined surv_dist. gamma single number used parameter defined surv_dist. cens_dist single character naming distribution function used generate censoring times suitable function. example, \"runif\" used generate uniformly distributed censoring times. Set NULL get censoring. cens_args list named arguments passed function specified cens_dist argument. name single character string specifying name node. as_two_cols Either TRUE FALSE, specifying whether output divided two columns. cens_dist specified, argument always treated TRUE two columns needed encode time event status indicator. censoring applied, however, users may set argument FALSE simply return numbers .","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_cox.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Data from a Cox-Regression Model — node_cox","text":"survival times generated according cox proportional-hazards regression model defined user. exactly data-generation works described detail Bender et al. (2005). also include censoring, function allows user supply function generates random censoring times. censoring time smaller generated survival time, individual considered censored. Unlike node type functions, function usually adds two columns resulting dataset instead one. first column called paste0(name, \"_event\") logical variable, TRUE indicates event happened FALSE indicates right-censoring. second column named paste0(name, \"_time\") includes survival censoring time corresponding previously mentioned event indicator. standard format right-censored time--event data without time-varying covariates. censoring applied, behavior can turned using as_two_cols argument. simulate complex time--event data, user may need use sim_discrete_time function instead.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_cox.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Generate Data from a Cox-Regression Model — node_cox","text":"Bender R, Augustin T, Blettner M. Generating survival times simulate Cox proportional hazards models. Statistics Medicine. 2005; 24 (11): 1713-1723.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_cox.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generate Data from a Cox-Regression Model — node_cox","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_cox.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Data from a Cox-Regression Model — node_cox","text":"Returns data.table length nrow(data) containing two columns as_two_cols=TRUE always cens_dist specified. case, columns start nodes name end _event _time. first logical vector, second numeric one. as_two_cols=FALSE cens_dist NULL, numeric vector returned instead.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_cox.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Data from a Cox-Regression Model — node_cox","text":"","code":"library(simDAG)  set.seed(3454)  # define DAG dag <- empty_dag() +   node(\"age\", type=\"rnorm\", mean=50, sd=4) +   node(\"sex\", type=\"rbernoulli\", p=0.5) +   node(\"death\", type=\"cox\", parents=c(\"sex\", \"age\"), betas=c(1.1, 0.4),        surv_dist=\"weibull\", lambda=1.1, gamma=0.7, cens_dist=\"runif\",        cens_args=list(min=0, max=1))  sim_dat <- sim_from_dag(dag=dag, n_sim=1000)"},{"path":"https://robindenz1.github.io/simDAG/reference/node_gaussian.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Data from a (Mixed) Linear Regression Model — node_gaussian","title":"Generate Data from a (Mixed) Linear Regression Model — node_gaussian","text":"Data parents used generate node using linear regression predicting covariate specific mean sampling normal distribution mean specified standard deviation. Allows inclusion arbitrary random effects slopes.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_gaussian.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Data from a (Mixed) Linear Regression Model — node_gaussian","text":"","code":"node_gaussian(data, parents, formula=NULL, betas, intercept, error,               var_corr=NULL, link=\"identity\")"},{"path":"https://robindenz1.github.io/simDAG/reference/node_gaussian.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Data from a (Mixed) Linear Regression Model — node_gaussian","text":"data data.table (something can coerced data.table) containing columns specified parents. parents character vector specifying names parents particular child node . non-linear combinations interaction effects included, user may specify formula argument instead. formula optional formula object describe node generated NULL (default). supplied start ~, nothing else left hand side. right hand side may contain valid formula syntax, + B + B + (^2), allowing non-linear effects. argument defined, need define parents argument. example, using parents=c(\"\", \"B\") equal using formula= ~ + B. May contain random effects random slopes, case simr package used generate data. See details. betas numeric vector length equal parents, specifying causal beta coefficients used generate node. intercept single number specifying intercept used generating node. error single number specifying sigma error used generating node. setting argument 0, linear predictor returned directly. formula contains mixed model syntax, argument passed sigma argument makeLmer function simr package. var_corr Variances covariances random effects. used formula contains mixed model syntax. multiple random effects, parameters supplied named list. complex structures also supported. argument directly passed makeLmer function simr package. Please consult documentation package information mixed models specified. guidance can also found \"Issues\" section official simr github page. link link function used transform linear predictor adding random error . standard linear regression model, set link=\"identity\" (default). allowed values \"log\" \"inverse\", defined way classic glm function.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_gaussian.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Data from a (Mixed) Linear Regression Model — node_gaussian","text":"Using general linear regression equation, observation-specific value expected given model generated every observation dataset generated thus far. stop , create perfect fit node, unrealistic. Instead, add error term taking one sample normal distribution observation mean zero standard deviation error. error term added predicted mean. Formal Description: Formally, data generation can described : $$Y \\sim \\texttt{intercept} + \\texttt{parents}_1 \\cdot \\texttt{betas}_1 + ... + \\texttt{parents}_n \\cdot \\texttt{betas}_n+ N(0, \\texttt{error}),$$ \\(N(0, \\texttt{error})\\) denotes normal distribution mean 0 standard deviation error \\(n\\) number parents (length(parents)). example, given intercept=-15, parents=c(\"\", \"B\"), betas=c(0.2, 1.3) error=2 data generation process defined : $$Y \\sim -15 + \\cdot 0.2 + B \\cdot 1.3 + N(0, 2).$$ using link \"identity\", procedure equivalent, except link function applied linear predictor adding random error term. example, using link=\"log\", \\(exp(-15 + \\cdot 0.2 + B \\cdot 1.3) + N(0, 2)\\) used instead. Random Effects Random Slopes: function also allows users include arbitrary amounts random slopes random effects using formula argument. done, formula, data arguments passed variables name makeLmer function simr package. fixef argument function passed numeric vector c(intercept, betas) VarCorr argument receives var_corr argument input. used node type DAG, taken care behind scenes. Users can simply use regular enhanced formula interface node function define formula terms, shown detail formula vignette (vignette(topic=\"v_using_formulas\", package=\"simDAG\")). Please consult vignette examples. Also, please note inclusion random effects random slopes usually results significantly longer computation times.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_gaussian.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generate Data from a (Mixed) Linear Regression Model — node_gaussian","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_gaussian.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Data from a (Mixed) Linear Regression Model — node_gaussian","text":"Returns numeric vector length nrow(data).","code":""},{"path":[]},{"path":"https://robindenz1.github.io/simDAG/reference/node_gaussian.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Data from a (Mixed) Linear Regression Model — node_gaussian","text":"","code":"library(simDAG)  set.seed(12455432)  # define a DAG dag <- empty_dag() +   node(\"age\", type=\"rnorm\", mean=50, sd=4) +   node(\"sex\", type=\"rbernoulli\", p=0.5) +   node(\"bmi\", type=\"gaussian\", parents=c(\"sex\", \"age\"),        betas=c(1.1, 0.4), intercept=12, error=2)  # define the same DAG, but with a pretty formula for the child node dag <- empty_dag() +   node(\"age\", type=\"rnorm\", mean=50, sd=4) +   node(\"sex\", type=\"rbernoulli\", p=0.5) +   node(\"bmi\", type=\"gaussian\", error=2,        formula= ~ 12 + sexTRUE*1.1 + age*0.4)  sim_dat <- sim_from_dag(dag=dag, n_sim=100)  ## an example using a random effect if (requireNamespace(\"simr\")) {  library(simr)  dag_mixed <- empty_dag() +   node(\"School\", type=\"rcategorical\", probs=rep(0.1, 10),        labels=LETTERS[1:10]) +   node(\"Age\", type=\"rnorm\", mean=12, sd=2) +   node(\"Grade\", type=\"gaussian\", formula= ~ -2 + Age*1.2 + (1|School),        var_corr=0.3, error=1)  sim_dat <- sim_from_dag(dag=dag_mixed, n_sim=20) }"},{"path":"https://robindenz1.github.io/simDAG/reference/node_identity.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Data based on an expression — node_identity","title":"Generate Data based on an expression — node_identity","text":"node type may used generate new node given regular R expression may include function calls valid R syntax. may useful combine components node need simulated separate node calls, just convenient shorthand variable transformations. Also allows calculation just linear predictor generation intermediary variables using enhanced formula syntax.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_identity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Data based on an expression — node_identity","text":"","code":"node_identity(data, parents, formula, kind=\"expr\",               betas, intercept, var_names=NULL,               name=NULL, dag=NULL)"},{"path":"https://robindenz1.github.io/simDAG/reference/node_identity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Data based on an expression — node_identity","text":"data data.table (something can coerced data.table) containing columns specified parents. parents character vector specifying names parents particular child node . using function node type node node_td, argument usually need specified formula argument required contains needed information already. formula formula object. specific way argument specified depends value kind argument used. can expression (kind=\"expr\"), simDAG style enhanced formula calculate linear predictor (kind=\"linpred\") used way store intermediary variable transformations (kind=\"data\"). kind single character string specifying formula interpreted, three allowed values: \"expr\", \"linpred\" \"data\". \"expr\" (default), formula contain ~ symbol nothing LHS, valid R expression can evaluated data RHS. expression needs contain least one variable name (otherwise users may simply use rconstant node type). may contain number function calls valid R syntax, given contained objects included global environment. Note usual formula syntax, using example :B*0.2 specify interaction work case. goal, users use kind=\"linpred\", case formula interpreted normal simDAG way linear combination variables calculated. Finally, kind=\"data\", formula may contain enhanced formula syntax, :B net() calls, contain beta-coefficients intercept. case, transformed variables returned order given, using name column names. See examples. betas used internally kind=\"linpred\". intercept used internally kind=\"linpred\". intercept present, still added formula using simple 0, example ~ 0 + *0.2 + B*0.3 var_names used kind=\"data\". case, multiple terms right-hand side formula, resulting columns re-named according argument. length number terms formula. Names given order variables appear formula. single term right-hand side formula, name supplied node function call automatically used nodes name argument ignored. Set NULL (default) just use terms names. name single character string, specifying name node. Passed internally . See var_names. dag dag node part . passed internally needed (example performing networks-based simulations). argument can therefore always ignored users.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_identity.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Data based on an expression — node_identity","text":"using kind=\"expr\", custom functions objects can used without issues formula, need present global environment, otherwise underlying eval() function call fail. Using function outside node node_td essentially equal using (data, eval(formula)) (without ~ formula). kind!=\"expr\", function used outside defined DAG. Please note using identity nodes kind=\"data\" multiple terms formula, printed structural equations plots dag object may correct.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_identity.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generate Data based on an expression — node_identity","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_identity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Data based on an expression — node_identity","text":"Returns numeric vector length nrow(data).","code":""},{"path":[]},{"path":"https://robindenz1.github.io/simDAG/reference/node_identity.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Data based on an expression — node_identity","text":"","code":"library(simDAG)  set.seed(12455432)  #### using kind = \"expr\" ####  # define a DAG dag <- empty_dag() +   node(\"age\", type=\"rnorm\", mean=50, sd=4) +   node(\"sex\", type=\"rbernoulli\", p=0.5) +   node(\"something\", type=\"identity\", formula= ~ age + sex + 2)  sim_dat <- sim_from_dag(dag=dag, n_sim=100) head(sim_dat) #>         age    sex something #>       <num> <lgcl>     <num> #> 1: 46.90669  FALSE  48.90669 #> 2: 47.25599  FALSE  49.25599 #> 3: 47.05490  FALSE  49.05490 #> 4: 48.06434  FALSE  50.06434 #> 5: 51.62119  FALSE  53.62119 #> 6: 54.11589  FALSE  56.11589  # more complex alternative dag <- empty_dag() +   node(\"age\", type=\"rnorm\", mean=50, sd=4) +   node(\"sex\", type=\"rbernoulli\", p=0.5) +   node(\"something\", type=\"identity\",        formula= ~ age / 2 + age^2 - ifelse(sex, 2, 3) + 2)  sim_dat <- sim_from_dag(dag=dag, n_sim=100) head(sim_dat) #>         age    sex something #>       <num> <lgcl>     <num> #> 1: 48.75325   TRUE  2401.256 #> 2: 48.62980   TRUE  2389.173 #> 3: 56.19418   TRUE  3185.883 #> 4: 53.39997  FALSE  2877.257 #> 5: 45.73172   TRUE  2114.256 #> 6: 56.06411  FALSE  3170.217  #### using kind = \"linpred\" ####  # this would work with both kind=\"expr\" and kind=\"linpred\" dag <- empty_dag() +   node(\"age\", type=\"rnorm\", mean=50, sd=4) +   node(\"sex\", type=\"rbernoulli\", p=0.5) +   node(\"pred\", type=\"identity\", formula= ~ 1 + age*0.2 + sex*1.2,        kind=\"linpred\")  sim_dat <- sim_from_dag(dag=dag, n_sim=10) head(sim_dat) #>         age    sex     pred #>       <num> <lgcl>    <num> #> 1: 52.92694   TRUE 12.78539 #> 2: 50.39227  FALSE 11.07845 #> 3: 56.38631  FALSE 12.27726 #> 4: 53.92836   TRUE 12.98567 #> 5: 55.23475  FALSE 12.04695 #> 6: 49.03310  FALSE 10.80662  # this only works with kind=\"linpred\", due to the presence of a special term dag <- empty_dag() +   node(\"age\", type=\"rnorm\", mean=50, sd=4) +   node(\"sex\", type=\"rbernoulli\", p=0.5, output=\"numeric\") +   node(\"pred\", type=\"identity\", formula= ~ 1 + age*0.2 + sex*1.2 + age:sex*-2,        kind=\"linpred\")  sim_dat <- sim_from_dag(dag=dag, n_sim=10) head(sim_dat) #>         age   sex       pred #>       <num> <num>      <num> #> 1: 52.90500     0  11.581000 #> 2: 44.52789     0   9.905577 #> 3: 47.58274     1 -83.448929 #> 4: 52.43168     1 -92.177030 #> 5: 49.61593     0  10.923186 #> 6: 51.83440     1 -91.101923  #### using kind = \"data\" ####  # simply return the transformed data, useful if the terms are used # frequently in multiple nodes in the DAG to save computation time  # using only a single interaction term dag <- empty_dag() +   node(\"age\", type=\"rnorm\", mean=50, sd=4) +   node(\"sex\", type=\"rbernoulli\", p=0.5, output=\"numeric\") +   node(\"age_sex_interact\", type=\"identity\", formula= ~ age:sex, kind=\"data\")  sim_dat <- sim_from_dag(dag=dag, n_sim=10) head(sim_dat) #>         age   sex age_sex_interact #>       <num> <num>            <num> #> 1: 50.61902     0          0.00000 #> 2: 51.73089     0          0.00000 #> 3: 50.12556     1         50.12556 #> 4: 48.68929     0          0.00000 #> 5: 43.91665     0          0.00000 #> 6: 49.24920     0          0.00000  # using multiple terms dag <- empty_dag() +   node(\"age\", type=\"rnorm\", mean=50, sd=4) +   node(\"sex\", type=\"rbernoulli\", p=0.5, output=\"numeric\") +   node(\"name_not_used\", type=\"identity\", formula= ~ age:sex + I(age^2),        kind=\"data\", var_names=c(\"age_sex_interact\", \"age_squared\"))  sim_dat <- sim_from_dag(dag=dag, n_sim=10) head(sim_dat) #>         age   sex age_sex_interact age_squared #>       <num> <num>            <num>       <num> #> 1: 44.07303     0          0.00000    1942.432 #> 2: 50.21162     0          0.00000    2521.207 #> 3: 51.79592     1         51.79592    2682.817 #> 4: 48.30182     0          0.00000    2333.066 #> 5: 55.40266     0          0.00000    3069.454 #> 6: 43.40470     1         43.40470    1883.968"},{"path":"https://robindenz1.github.io/simDAG/reference/node_mixture.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Data from a Mixture of Node Definitions — node_mixture","title":"Generate Data from a Mixture of Node Definitions — node_mixture","text":"node type allows users apply different nodes different subsets already generated data, making possible generate data arbitrary mixture distributions. similar node_conditional_distr node_conditional_prob, main difference former allow univariate distributions conditional categorical variables, function allows kind node definition condition. makes , example, possible generate data variable different regression models different subsets simulated individuals.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_mixture.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Data from a Mixture of Node Definitions — node_mixture","text":"","code":"node_mixture(data, parents, name, distr, default=NA)"},{"path":"https://robindenz1.github.io/simDAG/reference/node_mixture.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Data from a Mixture of Node Definitions — node_mixture","text":"data data.table (something can coerced data.table) containing columns specified parents. parents character vector specifying names parents particular child node . vector include nodes used conditions node calls specified distr. name single character string specifying name node. distr unnamed list specifies conditions node definitions. specified similar way fcase function pairs conditions (coded strings) node definitions. means condition comes first, example \"==0\", followed call node . Arbitrary numbers pairs allowed restrictions can specified node calls. name argument specified node calls, matter value used ignored processing. Currently supports time-fixed nodes defined using node function, time-dependent nodes defined using node_td function. See examples. default single value kind, used default value individuals covered conditions defined distr. Defaults NA.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_mixture.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generate Data from a Mixture of Node Definitions — node_mixture","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_mixture.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Data from a Mixture of Node Definitions — node_mixture","text":"Internally, data generated extracting relevant part already generated data defined condition using node function generate new response-part. generation done order distr specified, meaning data first condition checked first . safeguards guarantee conditions overlap. example, users free set first condition something like > 10 next one > 11, case value every individual > 11 generated twice (first first specification, secondly next specification). case, last generated value retained. Note also possible use mixture node inside conditions node calls distr, directly added data first condition applied (setting everyone default value). See examples. Additionally, output parts mixture distributions forced one vector, might coerced one class another, depending input distr order used. also needs taken care user.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_mixture.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Data from a Mixture of Node Definitions — node_mixture","text":"Returns vector length nrow(data). class vector determined specified distr.","code":""},{"path":[]},{"path":"https://robindenz1.github.io/simDAG/reference/node_mixture.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Data from a Mixture of Node Definitions — node_mixture","text":"","code":"library(simDAG)  set.seed(1234)  ## different linear regression models per level of a different covariate # here, A is the group that is used for the conditioning, B is a predictor # and Y is the mixture distributed outcome dag <- empty_dag() +   node(\"A\", type=\"rbernoulli\") +   node(\"B\", type=\"rnorm\") +   node(\"Y\", type=\"mixture\", parents=\"A\",        distr=list(          \"A==0\", node(\".\", type=\"gaussian\", formula= ~ -2 + B*2, error=1),          \"A==1\", node(\".\", type=\"gaussian\", formula= ~ 3 + B*5, error=1)        )) data <- sim_from_dag(dag, n_sim=100) head(data) #>         A          B          Y #>    <lgcl>      <num>      <num> #> 1:  FALSE -1.8060313 -5.9893002 #> 2:   TRUE -0.5820759  0.8500827 #> 3:   TRUE -1.1088896 -0.7019845 #> 4:   TRUE -1.0149620 -0.9624472 #> 5:   TRUE -0.1623095  2.2211163 #> 6:   TRUE  0.5630558  4.7008301  # also works with multiple conditions dag <- empty_dag() +   node(c(\"A\", \"C\"), type=\"rbernoulli\") +   node(\"B\", type=\"rnorm\") +   node(\"Y\", type=\"mixture\", parents=c(\"A\", \"C\"),     distr=list(       \"A==0 & C==1\", node(\".\", type=\"gaussian\", formula= ~ -2 + B*2, error=1),       \"A==1\", node(\".\", type=\"gaussian\", formula= ~ 3 + B*5, error=1)     )) data <- sim_from_dag(dag, n_sim=100) head(data) #>         A      C          B         Y #>    <lgcl> <lgcl>      <num>     <num> #> 1:   TRUE  FALSE -2.3160362 -7.691539 #> 2:   TRUE  FALSE  0.5624718  6.085333 #> 3:   TRUE  FALSE -0.7837751 -1.485517 #> 4:  FALSE   TRUE -0.2260540 -2.089441 #> 5:   TRUE  FALSE -1.5871030 -4.975722 #> 6:   TRUE  FALSE  0.5475242  6.285233  # using the mixture node itself in the condition # see cookbook vignette, section on outliers for more info dag <- empty_dag() +   node(c(\"A\", \"B\", \"C\"), type=\"rnorm\") +   node(\"Y\", type=\"mixture\", parents=c(\"A\", \"B\", \"C\"),        distr=list(          \"TRUE\", node(\".\", type=\"gaussian\", formula= ~ -2 + A*0.1 + B*1 + C*-2,                       error=1),          \"Y > 2\", node(\".\", type=\"rnorm\", mean=10000, sd=500)        )) data <- sim_from_dag(dag, n_sim=100)"},{"path":"https://robindenz1.github.io/simDAG/reference/node_multinomial.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Data from a Multinomial Regression Model — node_multinomial","title":"Generate Data from a Multinomial Regression Model — node_multinomial","text":"Data parents used generate node using multinomial regression predicting covariate specific probability class sampling multinomial distribution accordingly.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_multinomial.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Data from a Multinomial Regression Model — node_multinomial","text":"","code":"node_multinomial(data, parents, betas, intercepts,                  labels=NULL, output=\"factor\",                  return_prob=FALSE)"},{"path":"https://robindenz1.github.io/simDAG/reference/node_multinomial.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Data from a Multinomial Regression Model — node_multinomial","text":"data data.table (something can coerced data.table) containing columns specified parents. parents character vector specifying names parents particular child node . betas numeric matrix length(parents) columns one row class simulated, specifying causal beta coefficients used generate node. intercepts numeric vector one entry class simulated, specifying intercepts used generate node. labels optional character vector giving factor levels generated classes. NULL (default), integers simply used factor levels. output single character string specifying output format. Must one \"factor\" (default), \"character\" \"numeric\". argument labels supplied, output coerced \"character\" default. return_prob Either TRUE FALSE (default). Specifies whether return matrix class probabilities . using function inside node call, set TRUE return matrix. may, however, useful using function , probability generating function node_competing_events function.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_multinomial.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Data from a Multinomial Regression Model — node_multinomial","text":"function works essentially like node_binomial function. First, matrix betas coefficients used conjunction values defined parents nodes intercepts calculate expected subject-specific probabilities occurrence possible category. done using standard multinomial regression equations. Using probabilities conjunction rcategorical function, single one possible categories drawn individual. actually fitting multinomial regression model (functions multinom nnet package), coefficients usually equal ones supplied betas. reason functions usually standardize coefficients coefficient reference category.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_multinomial.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generate Data from a Multinomial Regression Model — node_multinomial","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_multinomial.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Data from a Multinomial Regression Model — node_multinomial","text":"Returns vector length nrow(data). Depending used arguments, vector may type character, numeric factor. return_prob used instead returns numeric matrix containing one column per possible event nrow(data) rows.","code":""},{"path":[]},{"path":"https://robindenz1.github.io/simDAG/reference/node_multinomial.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Data from a Multinomial Regression Model — node_multinomial","text":"","code":"library(simDAG)  set.seed(3345235)  dag <- empty_dag() +   node(\"age\", type=\"rnorm\", mean=50, sd=4) +   node(\"sex\", type=\"rbernoulli\", p=0.5) +   node(\"UICC\", type=\"multinomial\", parents=c(\"sex\", \"age\"),        betas=matrix(c(0.2, 0.4, 0.1, 0.5, 1.1, 1.2), ncol=2),        intercepts=1)  sim_dat <- sim_from_dag(dag=dag, n_sim=100)"},{"path":"https://robindenz1.github.io/simDAG/reference/node_negative_binomial.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Data from a Negative Binomial Regression Model — node_negative_binomial","title":"Generate Data from a Negative Binomial Regression Model — node_negative_binomial","text":"Data parents used generate node using negative binomial regression applying betas design matrix sampling rnbinom function.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_negative_binomial.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Data from a Negative Binomial Regression Model — node_negative_binomial","text":"","code":"node_negative_binomial(data, parents, formula=NULL, betas,                        intercept, theta, link=\"log\")"},{"path":"https://robindenz1.github.io/simDAG/reference/node_negative_binomial.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Data from a Negative Binomial Regression Model — node_negative_binomial","text":"data data.table (something can coerced data.table) containing columns specified parents. parents character vector specifying names parents particular child node . non-linear combinations interaction effects included, user may specify formula argument instead. formula optional formula object describe node generated NULL (default). supplied start ~, nothing else left hand side. right hand side may contain valid formula syntax, + B + B + (^2), allowing non-linear effects. argument defined, need define parents argument. example, using parents=c(\"\", \"B\") equal using formula= ~ + B. Contrary node_gaussian, node_binomial node_poisson node types, random effects random slopes currently supported . betas numeric vector length equal parents, specifying causal beta coefficients used generate node. intercept single number specifying intercept used generating node. theta single number specifying theta parameter (size argument rnbinom). link link function used transform linear predictor mu value used rnbinom. standard negative binomial regression model, set \"log\" (default). allowed values \"identity\" \"sqrt\".","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_negative_binomial.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Data from a Negative Binomial Regression Model — node_negative_binomial","text":"function uses linear predictor defined betas input design matrix sample subject-specific negative binomial distribution. calculating linear predictor using data, betas intercept, applying inverse link function passing mu argument rnbinom function stats package. node type currently support inclusion random effects random slopes formula.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_negative_binomial.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generate Data from a Negative Binomial Regression Model — node_negative_binomial","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_negative_binomial.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Data from a Negative Binomial Regression Model — node_negative_binomial","text":"Returns numeric vector length nrow(data).","code":""},{"path":[]},{"path":"https://robindenz1.github.io/simDAG/reference/node_negative_binomial.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Data from a Negative Binomial Regression Model — node_negative_binomial","text":"","code":"library(simDAG)  set.seed(124554)  dag <- empty_dag() +   node(\"age\", type=\"rnorm\", mean=50, sd=4) +   node(\"sex\", type=\"rbernoulli\", p=0.5) +   node(\"smoking\", type=\"negative_binomial\", theta=0.05,        formula= ~ -2 + sexTRUE*1.1 + age*0.4)  sim_dat <- sim_from_dag(dag=dag, n_sim=100, sort_dag=FALSE)"},{"path":"https://robindenz1.github.io/simDAG/reference/node_next_time.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate the Next Time of an Event in Discrete-Event Simulation — node_next_time","title":"Generate the Next Time of an Event in Discrete-Event Simulation — node_next_time","text":"node essentially models dichotomous time-dependent variable time event important later usage. Can used inside sim_discrete_event function, outside simulation functions. See details.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_next_time.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate the Next Time of an Event in Discrete-Event Simulation — node_next_time","text":"","code":"node_next_time(data, prob_fun, ..., distr_fun=rtexp,                distr_fun_args=list(), event_duration=Inf,                immunity_duration=event_duration)"},{"path":"https://robindenz1.github.io/simDAG/reference/node_next_time.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate the Next Time of an Event in Discrete-Event Simulation — node_next_time","text":"data data.table containing columns specified parents. Similar objects data.frames supported. prob_fun function returns numeric vector size nrow(data). numbers used summarise effect considered covariates per person. summarised score used distr_fun function call follows internally. example, using distr_fun=\"rtexp\" (default), prob_fun generate person-specific probability experiencing event 1 time unit. function may used, long named argument called data. Alternatively argument can set single number, resulting fixed summary score used every simulated individual every point time. ... arbitrary amount additional named arguments passed prob_fun. Ignore want pass arguments. Also ignored prob_fun single number. distr_fun function returns (left-truncated) next time variable turns TRUE. function least three named arguments n (number times draw), rate (summary score returned prob_fun) l (time left-truncation) may used. function additionally needs vectorised rate l, vector different values may supplied. left-truncation required, generated times strictly larger l. classic example function rtexp function (default). See examples associated vignette. distr_fun_args list named arguments passed function specified distr_fun argument. event_duration single number > 0 specifying long event last. period, corresponding variable set TRUE. immunity_duration single number >= event_duration specifying long person immune event . count internally starts event starts, order use immunity duration 10 time units event event_duration + 10 used. corresponding variable set FALSE event_duration immunity_duration .","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_next_time.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate the Next Time of an Event in Discrete-Event Simulation — node_next_time","text":"function time-dependent node type may currently used conducting discrete-event simulations using sim_discrete_event function. similar node_time_to_event function spirit, used model binary variable time. , however, usable sim_discrete_time calls. Use node_time_to_event function instead. works: beginning (\\(t = 0\\)) simulation, variable added using function set FALSE individuals. , function supplied prob_fun argument applied individuals current data, potentially using information baseline covariates time-dependent nodes (latter FALSE stage). obtained summary score passed distr_fun order generate time variable changes FALSE TRUE individual. example, consider situation one time-dependent variable includded. case, simulation time individual jumps generated event time immediately. variable set TRUE. Afterwards, simulation time jumps end event_duration (duration Inf, simulation ). variable set back FALSE. Next, simulation time jumps end immunity_duration (, Inf, simulation ). one time-dependent variable, situation little complicated. Consider two time-dependent variables B. \\(t = 0\\), FALSE every individual. prob_fun subsequently distr_fun variables called generate time next event . Lets say 20 42, respectively. simulation time advanced 20, setting TRUE. point, prob_fun distr_fun arguments called B, B might dependent current values , drawing new next event time B. Cruicially, time drawn left-truncated distr_fun, always larger current time 20. Lets say new time 53. simulation advanced , necessarily 53. Lets say event_duration 10. case simulation time advanced 30. set FALSE next time B re-computed using prob_fun distr_fun. point, immunity_duration Inf, next time also re-computed, left-truncated current simulation time + immunity_duration. , time advanced next event cycle continues. process repeated either (1) variables reach terminal state, (2) simulation time individual >= max_t, (3) break condition defined break_if reached (4) individuals left removal remove_if argument. Otherwise, simulation runs forever. can done : type node naturally supports implementation terminal recurrent events may influenced baseline variables events time dynamically. specifying parents prob_fun arguments correctly, possible create event type dependent past events time--event variables variables general, allowing non-markovian data generated. user can include amount nodes simulation. may also used simulate kind binary time-dependent variable one usually associate name \"event\" well. done : Currently function allows binary events. Categorical event types continuous time-dependent variables currently supported. event_duration immunity_duration can also fixed node, allowed vary per person.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_next_time.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generate the Next Time of an Event in Discrete-Event Simulation — node_next_time","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_next_time.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate the Next Time of an Event in Discrete-Event Simulation — node_next_time","text":"function never actually called. used node type \"next_time\" can safely specified node_td calls. make sense ever use outside node_td call, always returns NULL.","code":""},{"path":[]},{"path":"https://robindenz1.github.io/simDAG/reference/node_next_time.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate the Next Time of an Event in Discrete-Event Simulation — node_next_time","text":"","code":"library(simDAG)  ## a simple terminal time-to-event node, with a constant probability of ## occurrence, independent of any other variable dag <- empty_dag() +   node_td(\"death\", type=\"next_time\", prob_fun=0.0001,           event_duration=Inf)  ## a simple recurrent time-to-event node with a constant probability of ## occurrence, independent of any other variable dag <- empty_dag() +   node_td(\"car_crash\", type=\"next_time\", prob_fun=0.001, event_duration=1)  ## a next-time node with a probability function dependent on a ## time-fixed variable prob_car_crash <- function(data) {   ifelse(data$sex==1, 0.001, 0.01) }  dag <- empty_dag() +   node(\"sex\", type=\"rbernoulli\", p=0.5) +   node_td(\"car_crash\", type=\"next_time\", prob_fun=prob_car_crash,           parents=\"sex\")  ## a little more complex car crash simulation, where the probability for ## a car crash is dependent on the sex, and the probability of death is ## highly increased for 3 days after a car crash happened prob_car_crash <- function(data) {   ifelse(data$sex==1, 0.001, 0.01) }  prob_death <- function(data) {   ifelse(data$car_crash, 0.1, 0.0001) }  dag <- empty_dag() +   node(\"sex\", type=\"rbernoulli\", p=0.5) +   node_td(\"car_crash\", type=\"next_time\", prob_fun=prob_car_crash,           parents=\"sex\", event_duration=3) +   node_td(\"death\", type=\"next_time\", prob_fun=prob_death,           parents=\"car_crash\", event_duration=Inf)  # use the sim_discrete_time function to simulate data from one of these DAGs: sim <- sim_discrete_event(dag, n_sim=20, max_t=500)  ## more examples can be found in the vignettes of this package"},{"path":"https://robindenz1.github.io/simDAG/reference/node_poisson.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Data from a (Mixed) Poisson Regression Model — node_poisson","title":"Generate Data from a (Mixed) Poisson Regression Model — node_poisson","text":"Data parents used generate node using poisson regression predicting covariate specific lambda sampling poisson distribution accordingly. Allows inclusion arbitrary random effects slopes.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_poisson.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Data from a (Mixed) Poisson Regression Model — node_poisson","text":"","code":"node_poisson(data, parents, formula=NULL, betas, intercept,              var_corr=NULL, link=\"log\")"},{"path":"https://robindenz1.github.io/simDAG/reference/node_poisson.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Data from a (Mixed) Poisson Regression Model — node_poisson","text":"data data.table (something can coerced data.table) containing columns specified parents. parents character vector specifying names parents particular child node . non-linear combinations interaction effects included, user may specify formula argument instead. formula optional formula object describe node generated NULL (default). supplied start ~, nothing else left hand side. right hand side may contain valid formula syntax, + B + B + (^2), allowing non-linear effects. argument defined, need define parents argument. example, using parents=c(\"\", \"B\") equal using formula= ~ + B. May contain random effects random slopes, case simr package used generate data. See details. betas numeric vector length equal parents, specifying causal beta coefficients used generate node. intercept single number specifying intercept used generating node. var_corr Variances covariances random effects. used formula contains mixed model syntax. multiple random effects, parameters supplied named list. complex structures also supported. argument directly passed makeLmer function simr package. Please consult documentation package information mixed models specified. guidance can also found \"Issues\" section official simr github page. link link function used transform linear predictor lambda value used rpois. standard Poisson regression model, set \"log\" (default). allowed values \"identity\" \"sqrt\", defined way classic glm function.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_poisson.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Data from a (Mixed) Poisson Regression Model — node_poisson","text":"Essentially, function simply calculates linear predictor defined betas-coefficients, intercept values parents. link function applied predictor result passed rpois function. result draw subject-specific poisson distribution, resembling user-defined poisson regression model. Formal Description: Formally, data generation (using link=\"log\") can described : $$Y \\sim Poisson(\\lambda),$$ \\(Poisson()\\) means variable Poisson distributed : $$P_\\lambda(k) = \\frac{\\lambda^k e^{-\\lambda}}{k!}.$$ , \\(k\\) count \\(e\\) eulers number. parameter \\(\\lambda\\) determined : $$\\lambda = \\exp(\\texttt{intercept} + \\texttt{parents}_1 \\cdot \\texttt{betas}_1 + ... + \\texttt{parents}_n \\cdot \\texttt{betas}_n),$$ \\(n\\) number parents (length(parents)). example, given intercept=-15, parents=c(\"\", \"B\"), betas=c(0.2, 1.3) data generation process defined : $$Y \\sim Poisson(\\exp(-15 + \\cdot 0.2 + B \\cdot 1.3)).$$ Random Effects Random Slopes: function also allows users include arbitrary amounts random slopes random effects using formula argument. done, formula, data arguments passed variables name makeGlmer function simr package. fixef argument function passed numeric vector c(intercept, betas) VarCorr argument receives var_corr argument input. used node type DAG, taken care behind scenes. Users can simply use regular enhanced formula interface node function define formula terms, shown detail formula vignette (vignette(topic=\"v_using_formulas\", package=\"simDAG\")). Please consult vignette examples. Also, please note inclusion random effects random slopes usually results significantly longer computation times.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_poisson.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generate Data from a (Mixed) Poisson Regression Model — node_poisson","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_poisson.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Data from a (Mixed) Poisson Regression Model — node_poisson","text":"Returns numeric vector length nrow(data).","code":""},{"path":[]},{"path":"https://robindenz1.github.io/simDAG/reference/node_poisson.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Data from a (Mixed) Poisson Regression Model — node_poisson","text":"","code":"library(simDAG)  set.seed(345345)  dag <- empty_dag() +   node(\"age\", type=\"rnorm\", mean=50, sd=4) +   node(\"sex\", type=\"rbernoulli\", p=0.5) +   node(\"smoking\", type=\"poisson\",        formula= ~ -2 + sexTRUE*1.1 + age*0.4)  sim_dat <- sim_from_dag(dag=dag, n_sim=100)  ## an example using a random effect if (requireNamespace(\"simr\")) {  library(simr)  dag_mixed <- empty_dag() +   node(\"School\", type=\"rcategorical\", probs=rep(0.1, 10),        labels=LETTERS[1:10]) +   node(\"Age\", type=\"rnorm\", mean=12, sd=2) +   node(\"Grade\", type=\"poisson\", formula= ~ -2 + Age*1.2 + (1|School),        var_corr=0.3)  sim_dat <- sim_from_dag(dag=dag_mixed, n_sim=20) }"},{"path":"https://robindenz1.github.io/simDAG/reference/node_rsurv.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Data from Parametric Survival Models — node_rsurv","title":"Generate Data from Parametric Survival Models — node_rsurv","text":"Data parents used generate node using either accelerated failure time model, accelerated hazard model, extended hazard model, proportional odds model Young Prentice model, implemented rsurv package (Demarqui 2024).","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_rsurv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Data from Parametric Survival Models — node_rsurv","text":"","code":"node_aftreg(data, parents, betas, baseline, dist=NULL,             package=NULL, u=stats::runif(nrow(data)),             cens_dist=NULL, cens_args, name, as_two_cols=TRUE,             ...)  node_ahreg(data, parents, betas, baseline, dist=NULL,            package=NULL, u=stats::runif(nrow(data)),            cens_dist=NULL, cens_args, name, as_two_cols=TRUE,            ...)  node_ehreg(data, parents, betas, phi, baseline, dist=NULL,            package=NULL, u=stats::runif(nrow(data)),            cens_dist=NULL, cens_args, name, as_two_cols=TRUE,            ...)  node_poreg(data, parents, betas, baseline, dist=NULL,            package=NULL, u=stats::runif(nrow(data)),            cens_dist=NULL, cens_args, name, as_two_cols=TRUE,            ...)  node_ypreg(data, parents, betas, phi, baseline, dist=NULL,            package=NULL, u=stats::runif(nrow(data)),            cens_dist=NULL, cens_args, name, as_two_cols=TRUE,            ...)"},{"path":"https://robindenz1.github.io/simDAG/reference/node_rsurv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Data from Parametric Survival Models — node_rsurv","text":"data data.table (something can coerced data.table) containing columns specified parents. Passed argument name raftreg, rahreg, rehreg, rporeg rypreg. parents character vector specifying names parents particular child node . Converted formula passed argument name raftreg, rahreg, rehreg, rporeg rypreg. betas numeric vector length equal parents, specifying causal beta coefficients used generate node. Passed beta argument raftreg, rahreg, rehreg, rporeg rypreg. phi numeric vector length equal parents, specifying phi beta coefficients used generate node. required extended hazard Yang Prentice models. Passed phi argument rehreg rypreg. baseline single character string, specifying name baseline survival distribution. Passed argument name raftreg, rahreg, rehreg, rporeg rypreg. dist alternative way specify baseline survival distribution. Passed argument name raftreg, rahreg, rehreg, rporeg rypreg. package single character string, specifying name package assumed quantile function implemented. Passed argument name raftreg, rahreg, rehreg, rporeg rypreg. u numeric vector quantiles length nrow(data). Usually simply passed vector randomly generated uniformly distributed values 0 1, defined default. Passed argument name raftreg, rahreg, rehreg, rporeg rypreg. cens_dist single character naming distribution function used generate censoring times suitable function. example, \"runif\" used generate uniformly distributed censoring times. Set NULL get censoring. cens_args list named arguments passed function specified cens_dist argument. name single character string specifying name node. as_two_cols Either TRUE FALSE, specifying whether output divided two columns. cens_dist specified, argument always treated TRUE two columns needed encode time event status indicator. censoring applied, however, users may set argument FALSE simply return numbers . ... arguments passed raftreg, rahreg, rehreg, rporeg rypreg.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_rsurv.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Data from Parametric Survival Models — node_rsurv","text":"Survival times generated according specified parametric survival model. actual generation values done entirely calls rsurv package. arguments directly passed corresponding function rsurv. censoring added top . convenience wrappers exist allow direct integration data generation functions interface provided simDAG. Please consult documentation excellent paper Demarqui (2024) information models specify arguments.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_rsurv.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Generate Data from Parametric Survival Models — node_rsurv","text":"Demarqui Fabio N. Simulation Survival Data Package rsurv. (2024) arXiv:2406.01750v1.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_rsurv.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generate Data from Parametric Survival Models — node_rsurv","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_rsurv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Data from Parametric Survival Models — node_rsurv","text":"Returns data.table length nrow(data) containing two columns as_two_cols=TRUE always cens_dist specified. case, columns start nodes name end _event _time. first logical vector, second numeric one. as_two_cols=FALSE cens_dist NULL, numeric vector returned instead.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_rsurv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Data from Parametric Survival Models — node_rsurv","text":"","code":"library(simDAG)  set.seed(3454)  if (requireNamespace(\"rsurv\")) {  library(rsurv)  # accelerated failure time model dag <- empty_dag() +   node(c(\"A\", \"B\", \"C\"), type=\"rnorm\", mean=0, sd=1) +   node(\"Y\", type=\"aftreg\", formula= ~ -2 + A*0.2 + B*0.1 + A:B*1,        baseline=\"weibull\", shape=1, scale=2) data <- sim_from_dag(dag, n_sim=100)  # accelerated hazard model dag <- empty_dag() +   node(c(\"A\", \"B\", \"C\"), type=\"rnorm\", mean=0, sd=1) +   node(\"Y\", type=\"ahreg\", formula= ~ -2 + A*0.2 + B*0.1,        baseline=\"weibull\", shape=1, scale=2) data <- sim_from_dag(dag, n_sim=100)  # extended hazard model dag <- empty_dag() +   node(c(\"A\", \"B\", \"C\"), type=\"rnorm\", mean=0, sd=1) +   node(\"Y\", type=\"ehreg\", formula= ~ -2 + A*0.2 + B*0.1,        baseline=\"weibull\", shape=1, scale=2,        phi=c(-1, 1)) data <- sim_from_dag(dag, n_sim=100)  # proportional odds model dag <- empty_dag() +   node(c(\"A\", \"B\", \"C\"), type=\"rnorm\", mean=0, sd=1) +   node(\"Y\", type=\"poreg\", formula= ~ -2 + A*0.2 + B*0.1,        baseline=\"weibull\", shape=1, scale=2) data <- sim_from_dag(dag, n_sim=100)  # Young and Prentice model dag <- empty_dag() +   node(c(\"A\", \"B\", \"C\"), type=\"rnorm\", mean=0, sd=1) +   node(\"Y\", type=\"ypreg\", formula= ~ -2 + A*0.2 + B*0.1,        baseline=\"weibull\", shape=1, scale=2,        phi=c(-1, 1)) data <- sim_from_dag(dag, n_sim=100) } #> Loading required namespace: rsurv"},{"path":"https://robindenz1.github.io/simDAG/reference/node_time_to_event.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Data from repeated Bernoulli Trials in Discrete-Time Simulation — node_time_to_event","title":"Generate Data from repeated Bernoulli Trials in Discrete-Time Simulation — node_time_to_event","text":"node essentially models dichotomous time-dependent variable time event important later usage. adds two columns data: name_event (whether person currently event) name_time (time current event started). Past events stored list. Can used inside sim_discrete_time function, outside . See details.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_time_to_event.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Data from repeated Bernoulli Trials in Discrete-Time Simulation — node_time_to_event","text":"","code":"node_time_to_event(data, parents, sim_time, past_states, name,                    prob_fun, ..., event_duration=1,                    immunity_duration=event_duration, unif=NULL,                    time_since_last=FALSE, event_count=FALSE,                    save_past_events=TRUE, check_inputs=TRUE,                    envir)"},{"path":"https://robindenz1.github.io/simDAG/reference/node_time_to_event.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Data from repeated Bernoulli Trials in Discrete-Time Simulation — node_time_to_event","text":"data data.table containing columns specified parents. Similar objects data.frames supported. parents character vector specifying names parents particular child node . child nodes valid column names data. state variable definition dependent previous states, columns produced function automatically considered parents without user manually specify . sim_time current time simulation. sim_time argument function passed prob_fun argument, time automatically passed well. past_states list data.tables including previous states simulation. argument specified directly user. Instead, passed function internally whenever function passed prob_fun argument includes named argument called past_states. May useful specify nodes dependent specific past states simulation. name name node. used prefix _event, _time columns. time_since_last event_count arguments set TRUE, also used prefix respective columns. prob_fun function returns numeric vector size nrow(data) containing numbers 0 1. numbers specify person-specific probability experiencing event modeled node particular point time simulation. corresponding event generated internally using rbernoulli function. function needs named argument called data. function argument named sim_time, current simulation time also passed function automatically, allowing time-dependent probabilities generated. Alternatively argument can set single number (0 1), resulting fixed probability occurrence every simulated individual every point time. ... arbitrary amount additional named arguments passed prob_fun. Ignore want pass arguments. Also ignored prob_fun single number. event_duration single number > 0 specifying long event last. point time event occurs also counts duration. example, event occurs \\(t = 2\\) duration 3, event set TRUE \\(t \\\\{2, 3, 4\\}\\). Therefore, events must duration least 1 unit (otherwise never happened). immunity_duration single number >= event_duration specifying long person immune event . count internally starts event starts, order use immunity duration 10 time units event event_duration + 10 used. unif Specifies (usually uniformly distributed) numeric vector used perform Bernoulli trials. NULL (default), uniform numbers generated internally point time. single character string supplied, column name data used numbers (can, need mentioned parents). numeric vector supplied directly, values used instead. argument may useful make two time--event nodes use \"seed\". time_since_last Either TRUE FALSE (default), indicating whether additional column generated tracks number time units since individual last event onset. example, individual experienced single event \\(t = 10\\), column NA time 10, 0 time 10 increased 1 point time. another event happens, time set 0 . column named paste0(name, \"_time_since_last\"). difference column ending \"_time\" column set NA immunity_duration . keeps counting end simulation, may useful constructing event-time dependent probability functions. event_count Either TRUE FALSE (default), indicating whether additional column generated tracks number events individual already experienced. column 0 individuals t = 0. time new event occurs, counter increased one. Note new events increase counter. example, individual event t = 10 event_duration 15 value 0 t = 10, value 1 t = 10 afterwards. column named paste0(name, \"_event_count\"). save_past_events event modeled using node recurrent (immunity_duration < Inf & event_duration < Inf), person may experience multiple events course simulation. generally stored tte_past_events list included output sim_discrete_time function. extends runtime increases RAM usage, interested timing previous events using save_states=\"\" functionality can turned setting argument FALSE. check_inputs Whether perform plausibility checks user input . set TRUE default, can set FALSE order speed things using function simulation study something similar. envir used internally efficiently store past event times. used user.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_time_to_event.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Data from repeated Bernoulli Trials in Discrete-Time Simulation — node_time_to_event","text":"performing discrete-time simulation using sim_discrete_time function, standard node functions implemented package usually sufficient capture time-dependent nature interesting variables. Often, variable modelled probability occurring point time. occur, kind influence variables period time goes back normal (). car crash, surgery, vaccination etc. time_to_event node function can used model kinds nodes fairly straightforward fashion. Works: \\(t = 1\\), node initialized first time. adds two columns data: name_event (whether person currently event) name_time (time current event started) name name node. Additionally, adds list max_t entries tte_past_events list returned sim_discrete_time function, records individuals experienced new event point time. nutshell, simply models occurrence event calculating probability occurrence \\(t\\) drawing single bernoulli trial probability. trial \"success\", corresponding event column set TRUE, time column set current simulation time \\(t\\) column storing past event times receive entry. _event column stay TRUE event . duration controlled event_duration parameter. modeling terminal events death, one can simply set parameter Inf, making event eternal. many cases also necessary implement kind immunity event, can done using immunity_duration argument. effectively sets probability another occurrence event 0 next immunity_duration time steps. immunity duration, event may TRUE (event still ongoing) FALSE (event_duration already passed). _time column similarly set time occurrence event reset NA immunity_duration . probability occurrence calculated using function provided user using prob_fun argument. can arbitrary complex function. requirement takes data first argument. columns defined parents argument passed argument automatically. argument called sim_time, current time simulation automatically passed well. arguments can passed using ... syntax. simple example logistic regression node, probability calculated additive linear combination columns defined parents. complex function include simulation-time dependent effects, effects dependent past event times etc. Examples can found vignettes. Used: function never called directly user. Instead, user define DAG object using empty_dag node_td functions set type argument inside node_td call \"time_to_event\". DAG can passed sim_discrete_time function generate desired data. Many examples explanations given vignettes package. can done : type node naturally supports implementation terminal recurrent events may influenced pretty much anything. specifying parents prob_fun arguments correctly, possible create event type dependent past events time--event variables variables general. user can include amount nodes simulation. may also used simulate kind binary time-dependent variable one usually associate name \"event\" well. flexible, require user coding (e.g. creating suitable function prob_fun argument). done : Currently function allows binary events. Categorical event types may implemented using node_competing_events function, works similar fashion.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_time_to_event.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generate Data from repeated Bernoulli Trials in Discrete-Time Simulation — node_time_to_event","text":"Robin Denz, Katharina Meiszl","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_time_to_event.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Data from repeated Bernoulli Trials in Discrete-Time Simulation — node_time_to_event","text":"Returns data.table containing least two columns updated values node.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_time_to_event.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Generate Data from repeated Bernoulli Trials in Discrete-Time Simulation — node_time_to_event","text":"function called outside sim_discrete_time function. makes sense use type node_td function call, described documentation vignettes.","code":""},{"path":[]},{"path":"https://robindenz1.github.io/simDAG/reference/node_time_to_event.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Data from repeated Bernoulli Trials in Discrete-Time Simulation — node_time_to_event","text":"","code":"library(simDAG)  ## a simple terminal time-to-event node, with a constant probability of ## occurrence, independent of any other variable dag <- empty_dag() +   node_td(\"death\", type=\"time_to_event\", prob_fun=0.0001,           event_duration=Inf)  ## a simple recurrent time-to-event node with a constant probability of ## occurrence, independent of any other variable dag <- empty_dag() +   node_td(\"car_crash\", type=\"time_to_event\", prob_fun=0.001, event_duration=1)  ## a time-to-event node with a time-dependent probability function that ## has an additional argument prob_car_crash <- function(data, sim_time, base_p) {   return(base_p + sim_time * 0.0001) }  dag <- empty_dag() +   node_td(\"car_crash\", type=\"time_to_event\", prob_fun=prob_car_crash,           event_duration=1, base_p=0.0001)  ## a time-to-event node with a probability function dependent on a ## time-fixed variable prob_car_crash <- function(data) {   ifelse(data$sex==1, 0.001, 0.01) }  dag <- empty_dag() +   node(\"sex\", type=\"rbernoulli\", p=0.5) +   node_td(\"car_crash\", type=\"time_to_event\", prob_fun=prob_car_crash,           parents=\"sex\")  ## a little more complex car crash simulation, where the probability for ## a car crash is dependent on the sex, and the probability of death is ## highly increased for 3 days after a car crash happened prob_car_crash <- function(data) {   ifelse(data$sex==1, 0.001, 0.01) }  prob_death <- function(data) {   ifelse(data$car_crash_event, 0.1, 0.0001) }  dag <- empty_dag() +   node(\"sex\", type=\"rbernoulli\", p=0.5) +   node_td(\"car_crash\", type=\"time_to_event\", prob_fun=prob_car_crash,           parents=\"sex\") +   node_td(\"death\", type=\"time_to_event\", prob_fun=prob_death,           parents=\"car_crash_event\")  # use the sim_discrete_time function to simulate data from one of these DAGs: sim <- sim_discrete_time(dag, n_sim=20, max_t=500)  ## more examples can be found in the vignettes of this package"},{"path":"https://robindenz1.github.io/simDAG/reference/node_zeroinfl.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Data from a Zero-Inflated Count Model — node_zeroinfl","title":"Generate Data from a Zero-Inflated Count Model — node_zeroinfl","text":"Data parents used first simulate data regular count model, may follow either poisson regression negative binomial regression, implemented node_poisson node_negative_binomial respectively. , zeros simulated using logistic regression model implemented node_binomial. Whenever second binomial part returned 0, first part set 0, leaving rest untouched. Supports random effects random slopes (possible) models. See examples.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_zeroinfl.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Data from a Zero-Inflated Count Model — node_zeroinfl","text":"","code":"node_zeroinfl(data, parents, parents_count,               parents_zero, formula_count, formula_zero,               betas_count, betas_zero,               intercept_count, intercept_zero,               family_count=\"poisson\", theta,               link_count, link_zero=\"logit\",               var_corr_count, var_corr_zero)"},{"path":"https://robindenz1.github.io/simDAG/reference/node_zeroinfl.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Data from a Zero-Inflated Count Model — node_zeroinfl","text":"data data.table (something can coerced data.table) containing columns specified parents, parents_count parents_zero. parents character vector specifying names parents particular child node . Note argument specified parents_count parents_zero specified. non-linear combinations interaction effects included, user specify formula_count /formula_zero arguments instead. parents_count parents contain parents count model part node. parents_zero parents contain parents zero-inflation model part node. formula_count enhanced formula passed node_poisson node_negative_binomial function, used generate count part node. argument specified, need specify parents_count, betas_count intercept_count arguments. syntax usual formula argument described node. formula_zero enhanced formula passed node_binomial function, used generate zero-inflated part node. argument specified, need specify parents_zero, betas_zero intercept_zero arguments. syntax usual formula argument described node. betas_count numeric vector length equal parents_count, specifying causal beta coefficients used generate node count model. betas_zero numeric vector length equal parents_zero, specifying causal beta coefficients used generate node zero-inflation model. intercept_count single number specifying intercept used generating count model part node. intercept_zero single number specifying intercept used generating zero-inflated part node. family_count Either \"poisson\" zero-inflated poisson regression \"negative_binomial\" zero-inflated negative binomial regression. theta single number specifying theta parameter (size argument rnbinom). Ignore family_count=\"poisson\". link_count single character string, passed link argument respective node function used count model part. supplied, default respective link function used. link_zero single character string specifying link node_binomial function. var_corr_count random effects random slopes included formula_count, argument specified define variance structure effects. passed var_corr argument node_poisson. Random effects slopes currently supported family_count=\"negative_binomial\". var_corr_zero random effects random slopes included formula_zero, argument specified define variance structure effects. passed var_corr argument node_binomial.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_zeroinfl.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Data from a Zero-Inflated Count Model — node_zeroinfl","text":"important note data underlying models (count model zero-inflation model) simulated completely independent . using random effects either two models, may therefore use completely different values process.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_zeroinfl.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generate Data from a Zero-Inflated Count Model — node_zeroinfl","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_zeroinfl.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Data from a Zero-Inflated Count Model — node_zeroinfl","text":"Returns numeric vector length nrow(data).","code":""},{"path":[]},{"path":"https://robindenz1.github.io/simDAG/reference/node_zeroinfl.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Data from a Zero-Inflated Count Model — node_zeroinfl","text":"","code":"library(simDAG)  set.seed(5425)  # zero-inflated poisson regression dag <- empty_dag() +   node(c(\"A\", \"B\"), type=\"rnorm\", mean=0, sd=1) +   node(\"Y\", type=\"zeroinfl\",        formula_count= ~ -2 + A*0.2 + B*0.1 + A:B*0.4,        formula_zero= ~ 1 + A*1 + B*2,        family_count=\"poisson\",        parents=c(\"A\", \"B\")) data <- sim_from_dag(dag, n_sim=100)  # above is functionally the same as: dag <- empty_dag() +   node(c(\"A\", \"B\"), type=\"rnorm\", mean=0, sd=1) +   node(\"Y_count\", type=\"poisson\", formula= ~ -2 + A*0.2 + B*0.1 + A:B*0.4) +   node(\"Y_zero\", type=\"binomial\", formula= ~ 1 + A*1 + B*2) +   node(\"Y\", type=\"identity\", formula= ~ Y_zero * Y_count) data <- sim_from_dag(dag, n_sim=100)  # same as above, but specifying each individual component instead of formulas dag <- empty_dag() +   node(c(\"A\", \"B\", \"C\"), type=\"rnorm\", mean=0, sd=1) +   node(\"Y\", type=\"zeroinfl\",        parents_count=c(\"A\", \"B\"),        betas_count=c(0.2, 0.1),        intercept_count=-2,        parents_zero=c(\"A\", \"B\"),        betas_zero=c(1, 2),        intercept_zero=1,        family_count=\"poisson\",        parents=c(\"A\", \"B\")) data <- sim_from_dag(dag, n_sim=100)  # zero-inflated negative-binomial regression dag <- empty_dag() +   node(c(\"A\", \"B\"), type=\"rnorm\", mean=0, sd=1) +   node(\"Y\", type=\"zeroinfl\",        formula_count= ~ -2 + A*0.2 + B*3 + A:B*0.4,        formula_zero= ~ 3 + A*0.1 + B*0.3,        family_count=\"negative_binomial\", theta=1,        parents=c(\"A\", \"B\")) data <- sim_from_dag(dag, n_sim=100)"},{"path":"https://robindenz1.github.io/simDAG/reference/plot.DAG.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot a DAG object — plot.DAG","title":"Plot a DAG object — plot.DAG","text":"Using node information contained DAG object function plots corresponding DAG quick convenient way. options customize plot available, may advisable use packages made explicitly visualize DAGs instead meet users needs.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/plot.DAG.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot a DAG object — plot.DAG","text":"","code":"# S3 method for class 'DAG' plot(x, layout=\"nicely\", node_size=0.2,      node_names=NULL, node_color=\"black\",      node_fill=\"red\", node_linewidth=0.5,      node_linetype=\"solid\", node_alpha=1,      node_text_color=\"black\", node_text_alpha=1,      node_text_size=8, node_text_family=\"sans\",      node_text_fontface=\"bold\", arrow_color=\"black\",      arrow_linetype=\"solid\", arrow_linewidth=1,      arrow_alpha=1, arrow_head_size=0.3,      arrow_head_unit=\"cm\", arrow_type=\"closed\",      arrow_node_dist=0.03, gg_theme=ggplot2::theme_void(),      include_td_nodes=TRUE, mark_td_nodes=TRUE,      ...)"},{"path":"https://robindenz1.github.io/simDAG/reference/plot.DAG.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot a DAG object — plot.DAG","text":"x DAG object created using empty_dag function nodes added using + syntax. See empty_dag node details. layout single character string specifying layout plot. internally calls layout_ function igraph package, offers great variety ways layout nodes graph. Defaults \"nicely\". options : \"as_star\", \"as_tree\", \"in_circle\", \"on_sphere\", \"randomly\" many . details see ?layout_. node_size Either single positive number numeric vector one entry per node DAG, specifying radius circles used draw nodes. single number supplied, nodes size (default). node_names character vector one entry node DAG specifying names used nodes NULL (default). NULL, node names set creation DAG object used names. node_color single character string specifying color outline node circles. node_fill single character string specifying color nodes filled. Ignored time-varying nodes present include_td_nodes mark_td_nodes set TRUE. node_linewidth single number specifying width outline node circles. node_linetype single character string specifying linetype outline node circles. node_alpha single number 0 1 specifying transparency level nodes. node_text_color single character string specifying color text inside node circles. node_text_alpha single number 0 1 specifying transparency level text inside node circles. node_text_size single number specifying size text inside node circles. node_text_family single character string specifying family text inside node circles. node_text_fontface single character string specifying fontface text inside node circles. arrow_color single character string specifying color arrows nodes. arrow_linetype single character string specifying linetype arrows. arrow_linewidth single number specifying width arrows. arrow_alpha single number 0 1 specifying transparency level arrows. arrow_head_size single number specifying size arrow heads. unit size parameter can changed using arrow_head_unit argument. arrow_head_unit single character string specifying unit arrow_head_size argument. arrow_type Either \"open\" \"closed\", controls type head arrows . See ?arrow. arrow_node_dist single positive number specifying distance nodes arrows. setting values greater 0 arrows touch node circles, leaving bit space instead. gg_theme ggplot2 theme. default set theme_void, get rid everything plotted nodes (e.g. everything axis background). Might useful change something else searching good parameters number arguments function. include_td_nodes Whether include time-varying nodes added dag using node_td function . one node specified time-fixed time-varying node, parents calls pooled considered time-varying node argument TRUE. , however, also show argument FALSE. case however, parents node standard node call considered. mark_td_nodes Whether distinguish time-varying time-fixed nodes fill color. TRUE, color set automatically using standard ggplot2 palette, ignoring color specified node_fill. Ignored include_td_nodes=FALSE time-varying variables. ... arguments passed layout function specified argument name.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/plot.DAG.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot a DAG object — plot.DAG","text":"function uses igraph package find suitable layout plot uses ggplot2 package conjunction geom_circle function ggforce package plot directed acyclic graph defined DAG object. Since returns ggplot object, user may use standard ggplot2 syntax augment plot save using ggsave function. Note multiple great packages specifically designed plot directed acyclic graphs, igraph package. See Pitts Fowler (2024) review. function meant competitor packages. functionality offered rather limited. designed produce decent plots small DAGs easy create. function enough create adequate plot, users can use dag2matrix function obtain adjacency matrix DAG object directly use matrix igraph package (similar ones) get much better plots. DAG supplied function contains time-varying variables, resulting plot may contain cycles even bi-directional arrows, depending DAG. reason , time-dimension shown plot. Note also even though, technically, every time-varying node parent, arrows showing dependence added plot.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/plot.DAG.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Plot a DAG object — plot.DAG","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/plot.DAG.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Plot a DAG object — plot.DAG","text":"Pitts, Amy J. Charlotte R. Fowler (2024). Comparison Open-Source Software Producing Directed Acyclic Graphs. : Journal Causal Inference 12.1","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/plot.DAG.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot a DAG object — plot.DAG","text":"Returns standard ggplot2 object.","code":""},{"path":[]},{"path":"https://robindenz1.github.io/simDAG/reference/plot.DAG.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot a DAG object — plot.DAG","text":"","code":"library(simDAG)  # 2 root nodes, 1 child node dag <- empty_dag() +   node(\"age\", type=\"rnorm\", mean=50, sd=4) +   node(\"sex\", type=\"rbernoulli\", p=0.5) +   node(\"smoking\", type=\"binomial\", parents=c(\"sex\", \"age\"), betas=c(1.1, 0.4),        intercept=-2)  if (requireNamespace(\"ggplot2\") & requireNamespace(\"ggforce\")) {  library(ggplot2) library(igraph) library(ggforce)  plot(dag)  # get plot using the igraph package instead g1 <- as.igraph(dag) plot(g1)  # plot with a time-varying node dag <- dag +   node_td(\"lottery\", type=\"time_to_event\", parents=c(\"age\", \"smoking\"))  plot(dag) } #> Loading required namespace: ggforce"},{"path":"https://robindenz1.github.io/simDAG/reference/plot.simDT.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot a Flowchart for a Discrete-Time Simulation — plot.simDT","title":"Plot a Flowchart for a Discrete-Time Simulation — plot.simDT","text":"Given simDT object obtained sim_discrete_time function, plots relatively simple flowchart simulation performed. Shows general information extracted dag.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/plot.simDT.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot a Flowchart for a Discrete-Time Simulation — plot.simDT","text":"","code":"# S3 method for class 'simDT' plot(x, right_boxes=TRUE,      box_hdist=1, box_vdist=1,      box_l_width=0.35, box_l_height=0.23,      box_r_width=box_l_width,      box_r_height=box_l_height + 0.1,      box_alpha=0.5, box_linetype=\"solid\",      box_linewidth=0.5, box_border_colors=NULL,      box_fill_colors=NULL, box_text_color=\"black\",      box_text_alpha=1, box_text_angle=0,      box_text_family=\"sans\", box_text_fontface=\"plain\",      box_text_size=5, box_text_lineheight=1,      box_1_text_left=\"Create initial data\",      box_1_text_right=NULL, box_2_text=\"Increase t by 1\",      box_l_node_labels=NULL, box_r_node_labels=NULL,      box_last_text=paste0(\"t <= \", x$max_t, \"?\"),      arrow_line_type=\"solid\", arrow_line_width=0.5,      arrow_line_color=\"black\", arrow_line_alpha=1,      arrow_head_angle=30, arrow_head_size=0.3,      arrow_head_unit=\"cm\", arrow_head_type=\"closed\",      arrow_left_pad=0.3, hline_width=0.5,      hline_type=\"dashed\", hline_color=\"black\",      hline_alpha=1, ...)"},{"path":"https://robindenz1.github.io/simDAG/reference/plot.simDT.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot a Flowchart for a Discrete-Time Simulation — plot.simDT","text":"x simDT object created using sim_discrete_time function. right_boxes Either TRUE (default) FALSE, specifying whether add boxes right additional information nodes left. box_hdist single positive number specifying horizontal distance left right boxes. box_vdist single positive number specifying vertical distance boxes. box_l_width single positive number specifying width boxes left side. box_l_height single positive number specifying height boxes left side. box_r_width single positive number specifying width boxes right side. Ignored right_boxes=FALSE. box_r_height single positive number specifying height boxes right side. Ignored right_boxes=FALSE. box_alpha single number 0 1 specifying transparency level boxes. box_linetype single positive number specifying linetype box outlines. box_linewidth single positive number specifying width box outlines. box_border_colors character vector length two specifying colors box outlines. Set NULL (default) use ggplot2 default colors. box_fill_colors character vector length two specifying colors inside boxes. Set NULL (default) use ggplot2 default colors. box_text_color single character string specifying color text inside boxes. box_text_alpha single number 0 1 specifying transparency level text inside boxes. box_text_angle single positive number specifying angle text inside boxes. box_text_family single character string specifying family text inside boxes. May one \"sans\", \"serif\", \"mono\". box_text_fontface single character string specifying fontface text inside boxes. May one \"plain\", \"bold\", \"italic\", \"bold.italic\". box_text_size single number specifying size text inside boxes. box_text_lineheight single number specifying lineheight text inside boxes. box_1_text_left single character string specifying text inside first box top left side. box_1_text_right single character string specifying text inside first box top right side NULL. NULL (default) simply state variables generated t = 0. box_2_text single character string specifying text inside second box top. box_l_node_labels character vector one entry time-varying node used simulation. used fill boxes left side plot. Set NULL use default values. box_r_node_labels character vector one entry time-varying node used simulation. used fill boxes right side plot. Set NULL use default values. Ignored right_boxes=FALSE. box_last_text single character string specifying text inside last box left side. default uses max_t argument initial function call construct fitting text. arrow_line_type single character string specifying linetype arrows. arrow_line_width single positive number specifying line width arrows. arrow_line_color single character string specifying color arrows. arrow_line_alpha single number 0 1 specifying transparency level arrows. arrow_head_angle single number specifying angle arrow heads. arrow_head_size single number specifying size arrow heads. unit defined arrow_head_size argument. arrow_head_unit single character string specifying unit use specifying arrow_head_size argument. Defaults \"cm\". arrow_head_type single character string specifying type arrow head use. See ?arrow details. arrow_left_pad single positive number specifying distance left boxes arrow line left . hline_width single number specifying width horizontal lines left right boxes. hline_type single character string specifying linetype horizontal lines left right boxes. hline_color single character string specifying color horizontal lines left right boxes. hline_alpha single number 0 1 specifying transparency level horizontal lines left right boxes. ... Currently used.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/plot.simDT.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot a Flowchart for a Discrete-Time Simulation — plot.simDT","text":"resulting flowchart includes two columns boxes next . left side always starts two boxes: box creation initial data box increasing simulation time 1. Next, box time-varying variable simDT object. Afterwards another box asks maximum simulation time reached. arrow left points back second box top indicates iterative nature simulation process. right column boxes includes additional information boxes left. text boxes may changed custom text using box_1_text_left, box_1_text_right, box_2_text, box_l_node_labels, box_r_node_labels box_last_text arguments. also possible completely remove left line boxes change various sizes appearances. Although quite options, still rather fixed function nature. One add boxes arrows simple way. general structure may also changed. may useful visualize general idea simulation flow, may limited usage scientific publications simulation complex. graphic created using ggplot2 package output standard ggplot object. means user can change result using standard ggplot syntax (adding stuff, changing geoms, ...).","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/plot.simDT.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot a Flowchart for a Discrete-Time Simulation — plot.simDT","text":"Returns standard ggplot object.","code":""},{"path":[]},{"path":"https://robindenz1.github.io/simDAG/reference/plot.simDT.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Plot a Flowchart for a Discrete-Time Simulation — plot.simDT","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/plot.simDT.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot a Flowchart for a Discrete-Time Simulation — plot.simDT","text":"","code":"library(simDAG)  set.seed(435345)  ## exemplary car crash simulation, where the probability for ## a car crash is dependent on the sex, and the probability of death is ## highly increased for 3 days after a car crash happened prob_car_crash <- function(data) {   ifelse(data$sex==1, 0.001, 0.01) }  prob_death <- function(data) {   ifelse(data$car_crash_event, 0.1, 0.0001) }  dag <- empty_dag() +   node(\"sex\", type=\"rbernoulli\", p=0.5) +   node_td(\"car_crash\", type=\"time_to_event\", prob_fun=prob_car_crash,           parents=\"sex\") +   node_td(\"death\", type=\"time_to_event\", prob_fun=prob_death,           parents=\"car_crash_event\")  # generate some data sim <- sim_discrete_time(dag, n_sim=20, max_t=500, save_states=\"last\")  if (requireNamespace(\"ggplot2\")) {  # default plot plot(sim)  # removing boxes on the right plot(sim, right_boxes=FALSE) }"},{"path":"https://robindenz1.github.io/simDAG/reference/rbernoulli.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Random Draws from a Bernoulli Distribution — rbernoulli","title":"Generate Random Draws from a Bernoulli Distribution — rbernoulli","text":"fast implementation generating bernoulli trials. Can take vector probabilities makes useful simulation studies.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/rbernoulli.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Random Draws from a Bernoulli Distribution — rbernoulli","text":"","code":"rbernoulli(n, p=0.5, output=\"logical\", reference=NULL)"},{"path":"https://robindenz1.github.io/simDAG/reference/rbernoulli.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Random Draws from a Bernoulli Distribution — rbernoulli","text":"n many draws make. p numeric vector probabilities, used drawing trials. output single character string, specifying format output returned . Must one \"logical\" (default), \"numeric\", \"character\" \"factor\". reference single character string, specifying two possible values considered reference output=\"factor\" (ignored otherwise).","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/rbernoulli.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Random Draws from a Bernoulli Distribution — rbernoulli","text":"Internally, uses single call runif, making much faster memory efficient using rbinomial. Note function accepts values p smaller 0 greater 1. p < 0 always return FALSE, p > 1 always return TRUE.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/rbernoulli.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generate Random Draws from a Bernoulli Distribution — rbernoulli","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/rbernoulli.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Random Draws from a Bernoulli Distribution — rbernoulli","text":"Returns vector length n desired output format.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/rbernoulli.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Random Draws from a Bernoulli Distribution — rbernoulli","text":"","code":"library(simDAG)  # generating 5 bernoulli random draws from an unbiased coin rbernoulli(n=5, p=0.5) #> [1] FALSE FALSE  TRUE FALSE FALSE  # using different probabilities for each coin throw rbernoulli(n=5, p=c(0.1, 0.2, 0.3, 0.2, 0.7)) #> [1] FALSE FALSE  TRUE FALSE FALSE  # return as numeric instead rbernoulli(n=5, p=0.5, output=\"numeric\") #> [1] 1 0 0 1 1"},{"path":"https://robindenz1.github.io/simDAG/reference/rcategorical.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Random Draws from a Discrete Set of Labels with Associated Probabilities — rcategorical","title":"Generate Random Draws from a Discrete Set of Labels with Associated Probabilities — rcategorical","text":"Allows different class probabilities person supplying matrix one column class one row person.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/rcategorical.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Random Draws from a Discrete Set of Labels with Associated Probabilities — rcategorical","text":"","code":"rcategorical(n, probs, labels=NULL, output=\"numeric\",              reference=NULL)"},{"path":"https://robindenz1.github.io/simDAG/reference/rcategorical.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Random Draws from a Discrete Set of Labels with Associated Probabilities — rcategorical","text":"n many draws make. Passed size argument sample function probs matrix. probs Either numeric vector probabilities sums one matrix one column desired class n rows. Passed probs argument sample function numeric vector passed. labels vector labels draw . NULL (default), simply uses integers starting 1. Passed x argument sample function probs matrix. output single character string specifying output format results. Must either \"numeric\" (default), \"character\" \"factor\". labels supplied, output parsed characters default. reference single character string, specifying possible values considered reference output=\"factor\" (ignored otherwise).","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/rcategorical.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Random Draws from a Discrete Set of Labels with Associated Probabilities — rcategorical","text":"case simple numeric vector (class probabilities draws), function wrapper sample function, make code consistent. uses weighted sampling replacement. Otherwise, custom code used faster standard rmultinom function.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/rcategorical.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generate Random Draws from a Discrete Set of Labels with Associated Probabilities — rcategorical","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/rcategorical.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Random Draws from a Discrete Set of Labels with Associated Probabilities — rcategorical","text":"Returns numeric vector (factor vector coerce2factor=TRUE) length n.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/rcategorical.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Random Draws from a Discrete Set of Labels with Associated Probabilities — rcategorical","text":"","code":"library(simDAG)  rcategorical(n=5, labels=c(\"A\", \"B\", \"C\"), probs=c(0.1, 0.2, 0.7)) #> [1] \"C\" \"C\" \"C\" \"A\" \"C\"  rcategorical(n=2, probs=matrix(c(0.1, 0.2, 0.5, 0.7, 0.4, 0.1), nrow=2)) #> [1] 1 2"},{"path":"https://robindenz1.github.io/simDAG/reference/rconstant.html","id":null,"dir":"Reference","previous_headings":"","what":"Use a single constant value for a root node — rconstant","title":"Use a single constant value for a root node — rconstant","text":"small convenience function simply returns value passed , order allow use constant node root node sim_from_dag function.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/rconstant.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Use a single constant value for a root node — rconstant","text":"","code":"rconstant(n, constant)"},{"path":"https://robindenz1.github.io/simDAG/reference/rconstant.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Use a single constant value for a root node — rconstant","text":"n number times constant repeated. constant single value kind used value resulting variable.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/rconstant.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Use a single constant value for a root node — rconstant","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/rconstant.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Use a single constant value for a root node — rconstant","text":"Returns vector length n type constant.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/rconstant.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Use a single constant value for a root node — rconstant","text":"","code":"library(simDAG)  rconstant(n=10, constant=7) #>  [1] 7 7 7 7 7 7 7 7 7 7  rconstant(n=4, constant=\"Male\") #> [1] \"Male\" \"Male\" \"Male\" \"Male\""},{"path":"https://robindenz1.github.io/simDAG/reference/rsample.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample values from a given vector — rsample","title":"Sample values from a given vector — rsample","text":"function simple wrapper around sample function, allowing users directly sample values given input vector (without replacement without defining selection probabilities).","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/rsample.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample values from a given vector — rsample","text":"","code":"rsample(n, x, replace=FALSE, prob=NULL)"},{"path":"https://robindenz1.github.io/simDAG/reference/rsample.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample values from a given vector — rsample","text":"n many draws make. x vector containing one elements sample . replace Either TRUE FALSE, specifying whether sampling performed without replacement. prob numeric vector probability weights obtaining elements vector sampled NULL (default). NULL, simple random sample without weights performed.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/rsample.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Sample values from a given vector — rsample","text":"function similar rcategorical function, main difference rsample() directly supports kind vector input, just categorical values, support matrix input prob argument. Use rcategorical goal sample categorical distribution categories different probabilities per person use rsample() general sampling purposes. Note function just wrapper around sample function, additional functionality improvements. meant conveniently allow sampling within packages syntax (original function use n argument, can thus used directly without wrapper).","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/rsample.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Sample values from a given vector — rsample","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/rsample.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample values from a given vector — rsample","text":"Returns vector length n type x.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/rsample.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sample values from a given vector — rsample","text":"","code":"library(simDAG)  # without replacement dag <- empty_dag() +   node(\"A\", type=\"rsample\", x=1:10, replace=FALSE) data <- sim_from_dag(dag, n_sim=5) head(data) #>        A #>    <int> #> 1:     4 #> 2:     8 #> 3:     6 #> 4:     9 #> 5:     2  # with replacement and selection probabilities dag <- empty_dag() +   node(\"A\", type=\"rsample\", x=c(1, 2, 3, 4), replace=TRUE,        prob=c(0.1, 0.3, 0.1, 0.5)) data <- sim_from_dag(dag, n_sim=100) head(data) #>        A #>    <num> #> 1:     4 #> 2:     4 #> 3:     3 #> 4:     2 #> 5:     3 #> 6:     4"},{"path":"https://robindenz1.github.io/simDAG/reference/rtexp.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample values from a left-truncated exponential distribution — rtexp","title":"Sample values from a left-truncated exponential distribution — rtexp","text":"function simple wrapper around rexp function, allowing users directly sample values left-truncated exponential distribution.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/rtexp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample values from a left-truncated exponential distribution — rtexp","text":"","code":"rtexp(n, rate, l=NULL)"},{"path":"https://robindenz1.github.io/simDAG/reference/rtexp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample values from a left-truncated exponential distribution — rtexp","text":"n many draws make. rate numeric vector numbers > 0, specifying rate parameter exponential distribution. l numeric vector numbers > 0, specifying value distribution left-truncated.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/rtexp.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Sample values from a left-truncated exponential distribution — rtexp","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/rtexp.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Sample values from a left-truncated exponential distribution — rtexp","text":"function mostly exists can used conveniently performing discrete-event simulations.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/rtexp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample values from a left-truncated exponential distribution — rtexp","text":"Returns numeric vector length n.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/rtexp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sample values from a left-truncated exponential distribution — rtexp","text":"","code":"library(simDAG)  rtexp(n=10, rate=0.05, l=20) #>  [1] 34.34906 88.12827 40.70373 27.78129 43.35305 20.89357 52.47933 20.56222 #>  [9] 49.71915 49.57393  # without replacement dag <- empty_dag() +   node(\"A\", type=\"rtexp\", rate=0.01, l=100) data <- sim_from_dag(dag, n_sim=5) head(data) #>           A #>       <num> #> 1: 129.1568 #> 2: 216.4785 #> 3: 207.6033 #> 4: 120.1542 #> 5: 235.8952"},{"path":"https://robindenz1.github.io/simDAG/reference/sim2data.html","id":null,"dir":"Reference","previous_headings":"","what":"Transform sim_discrete_time output into the start-stop, long- or wide-format — sim2data","title":"Transform sim_discrete_time output into the start-stop, long- or wide-format — sim2data","text":"function transforms output sim_discrete_time function single data.table structured start-stop format (also known counting process format), long format (one row per person per point time) wide format (one row per person, one column per point time time-varying variables). See details.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/sim2data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transform sim_discrete_time output into the start-stop, long- or wide-format — sim2data","text":"","code":"sim2data(sim, to, use_saved_states=sim$save_states==\"all\",          overlap=FALSE, target_event=NULL,          keep_only_first=FALSE, remove_not_at_risk=FALSE,          remove_vars=NULL, as_data_frame=FALSE,          check_inputs=TRUE, ...)  # S3 method for class 'simDT' as.data.table(x, keep.rownames=FALSE, to, overlap=FALSE,               target_event=NULL, keep_only_first=FALSE,               remove_not_at_risk=FALSE,               remove_vars=NULL,               use_saved_states=x$save_states==\"all\",               check_inputs=TRUE, ...)  # S3 method for class 'simDT' as.data.frame(x, row.names=NULL, optional=FALSE, to,               overlap=FALSE, target_event=NULL,               keep_only_first=FALSE, remove_not_at_risk=FALSE,               remove_vars=NULL,               use_saved_states=x$save_states==\"all\",               check_inputs=TRUE, ...)"},{"path":"https://robindenz1.github.io/simDAG/reference/sim2data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transform sim_discrete_time output into the start-stop, long- or wide-format — sim2data","text":"sim, x object created sim_discrete_time function. Specifies format output data. Must one : \"start_stop\", \"long\", \"wide\". use_saved_states Whether saved simulation states (argument save_states sim_discrete_time function) used construct resulting data . See details. overlap used =\"start_stop\". Specifies whether intervals overlap . TRUE, \"stop\" column simply increased one, compared output overlap=FALSE. means changes given \\(t\\) recorded start next interval, previous interval ends day. target_event used =\"start_stop\". default (keeping argument NULL) time--event nodes treated equally creating start-stop intervals. can changed supplying single character string argument, naming one time--event node. node treated outcome. output corresponds needed fit Cox proportional hazards model. See details. keep_only_first used =\"start_stop\" target_event NULL. Either TRUE FALSE (default). TRUE, information first event per person discarded. Useful target_event treated terminal variable. remove_not_at_risk used =\"start_stop\" target_event NULL. Either TRUE FALSE (default). TRUE, event_duration immunity_duration target_event taken account constructing start-stop data. precisely, time individuals -risk either still currently experiencing event immune event removed start-stop data. may necessary fitting survival regression models, time-periods counted time -risk. remove_vars optional character vector specifying variables included ouput. Set NULL include variables included sim object (default). as_data_frame Set argument TRUE return data.frame instead data.table. check_inputs Whether perform input checks (TRUE default). Prints warning messages output may incorrect due missing information. keep.rownames Currently used. row.names Passed .data.frame function called finished data.table. See ?.data.frame information. optional Passed .data.frame function called finished data.table. See ?.data.frame information. ... arguments passed .data.frame (conversion finished data.table data.frame). available directly calling sim2data as_data_frame=TRUE using .data.frame.simDT.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/sim2data.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Transform sim_discrete_time output into the start-stop, long- or wide-format — sim2data","text":"raw output sim_discrete_time function may difficult use analysis. Using one functions, straightforward transform output three different formats, described . Note caution needs applied using function, also described . .data.table .data.frame internally call sim2data exist user convenience. start-stop format: start-stop format (=\"start_stop\"), also known counting process period format corresponds data.table containing multiple rows per person, row corresponds period time variables changed. intervals defined start stop columns. start column gives time period started, stop column denotes time period ended. default intervals coded non-overlapping, meaning edges periods included period . example, respective period exactly 1 point time long, start equal stop. non-overlapping periods desired, user can specify overlap=TRUE instead. default, time--event nodes treated equally. optimal goal fit survival regression models. case, usually want target event treated special way (see example Chiou et al. 2023). general, instead creating new intervals want existing intervals end event times corresponding event indicator. can achieved naming target outcome target_event variable. previously specified duration target event ignored. additionally remove time periods individuals -risk due event still going immune (specified using event_duration immunity_duration parameters node_time_to_event), users may set remove_not_at_risk=TRUE. first occurrence event interest, users may also set keep_only_first=TRUE keep information first event per person. long format: long format (=\"long\") corresponds data.table one row per person per point time. unique person identifier stored .id column unique points time given .time column. wide format: wide format (=\"wide\") corresponds data.table exactly one row per person multiple columns per points time time-varying variable. time-varying variables coded original variable name underscore time-point appended end. example, variable sickness time-point 3 named \"sickness_3\". Output use_saved_states=TRUE: use_saved_states=TRUE, function use data stored past_states list sim object construct resulting data.table. results following behavior, depending save_states option used original sim_discrete_time function call: save_states=\"\": complete data.table desired format information observations points time variables created. safest option, also uses RAM computational time. save_states=\"at_t\": data.table desired format correct information observations user specified times (save_states_at argument) variables created. state simulation times ignored, stored. may useful scenarios, generally discouraged unless good reasons use . warning message printed check_inputs=TRUE. save_states=\"last\": Since last state simulation saved, error message returned. data.table produced. Output use_saved_states=FALSE: use_saved_states=FALSE, function use data stored final state simulation (data object sim) information node_time_to_event objects. tx_nodes time_to_event nodes user cares time_to_event nodes time-fixed variables, best option. data.table desired format correct information observations times produced, correct entries time-varying variables, namely time_to_event nodes. Note information also correct user used save_past_events=TRUE time_to_event nodes. Support competing_events nodes implemented future well. time-varying variables specified tx_nodes argument still appear output, value observed last state simulation. Optional columns created using time_to_event node: using time-dependent node type \"time_to_event\" event_count=TRUE time_since_last=TRUE, columns created using either argument included output =\"start_stop\", included set either \"long\" \"wide\". reason behavior including columns lead nonsense intervals start-stop format, makes sense formats. tx_nodes time_to_event nodes?: want correct output tx_nodes one time_to_event nodes, use save_states=\"\" original sim_discrete_time call. plan add support competing_events save_states arguments near future. Support arbitrary tx_nodes probably take longer.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/sim2data.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Transform sim_discrete_time output into the start-stop, long- or wide-format — sim2data","text":"Using node names \"start\", \"stop\", \".id\", \".time\" names automatically generated time-dependent nodes type \"time_to_event\" may break function.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/sim2data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Transform sim_discrete_time output into the start-stop, long- or wide-format — sim2data","text":"Returns single data.table (data.frame) containing simulated variables desired format.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/sim2data.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Transform sim_discrete_time output into the start-stop, long- or wide-format — sim2data","text":"Robin Denz","code":""},{"path":[]},{"path":"https://robindenz1.github.io/simDAG/reference/sim2data.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Transform sim_discrete_time output into the start-stop, long- or wide-format — sim2data","text":"Sy Han Chiou, Gongjun Xu, Jun Yan, Chiung-Yu Huang (2023). \"Regression Modeling Recurrent Events Possibly Informative Terminal Event Using R Package reReg\". : Journal Statistical Software. 105.5, pp. 1-34.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/sim2data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Transform sim_discrete_time output into the start-stop, long- or wide-format — sim2data","text":"","code":"library(simDAG)  set.seed(435345)  ## exemplary car crash simulation, where the probability for ## a car crash is dependent on the sex, and the probability of death is ## highly increased for 3 days after a car crash happened prob_car_crash <- function(data) {   ifelse(data$sex==1, 0.001, 0.01) }  prob_death <- function(data) {   ifelse(data$car_crash_event, 0.1, 0.001) }  dag <- empty_dag() +   node(\"sex\", type=\"rbernoulli\", p=0.5) +   node_td(\"car_crash\", type=\"time_to_event\", prob_fun=prob_car_crash,           parents=\"sex\", event_duration=3) +   node_td(\"death\", type=\"time_to_event\", prob_fun=prob_death,           parents=\"car_crash_event\", event_duration=Inf)  # generate some data, only saving the last state # not a problem here, because the only time-varying nodes are # time-to-event nodes where the event times are saved sim <- sim_discrete_time(dag, n_sim=20, max_t=500, save_states=\"last\")  # transform to standard start-stop format d_start_stop <- sim2data(sim, to=\"start_stop\") head(d_start_stop) #>      .id start  stop car_crash  death    sex #>    <int> <int> <num>    <lgcl> <lgcl> <lgcl> #> 1:     1     1   114     FALSE  FALSE  FALSE #> 2:     1   115   117      TRUE   TRUE  FALSE #> 3:     1   118   417     FALSE   TRUE  FALSE #> 4:     1   418   420      TRUE   TRUE  FALSE #> 5:     1   421   481     FALSE   TRUE  FALSE #> 6:     1   482   484      TRUE   TRUE  FALSE  # transform to \"death\" centric start-stop format # and keep only information until death, cause it's a terminal event # (this could be used in a Cox model) d_start_stop <- sim2data(sim, to=\"start_stop\", target_event=\"death\",                          keep_only_first=TRUE, overlap=TRUE) head(d_start_stop) #>      .id start  stop car_crash  death    sex #>    <int> <int> <num>    <lgcl> <lgcl> <lgcl> #> 1:     1     1   115     FALSE  FALSE  FALSE #> 2:     1   115   116      TRUE   TRUE  FALSE #> 3:     2     1    42     FALSE  FALSE  FALSE #> 4:     2    42    45      TRUE  FALSE  FALSE #> 5:     2    45   232     FALSE  FALSE  FALSE #> 6:     2   232   235      TRUE  FALSE  FALSE  # transform to long-format d_long <- sim2data(sim, to=\"long\") head(d_long) #> Key: <.id, .time> #>      .id .time car_crash  death    sex #>    <int> <int>    <lgcl> <lgcl> <lgcl> #> 1:     1     1     FALSE  FALSE  FALSE #> 2:     1     2     FALSE  FALSE  FALSE #> 3:     1     3     FALSE  FALSE  FALSE #> 4:     1     4     FALSE  FALSE  FALSE #> 5:     1     5     FALSE  FALSE  FALSE #> 6:     1     6     FALSE  FALSE  FALSE  # transform to wide-format d_wide <- sim2data(sim, to=\"wide\") #head(d_wide)"},{"path":"https://robindenz1.github.io/simDAG/reference/simDAG.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate Data from a DAG and Associated Node Information — simDAG-package","title":"Simulate Data from a DAG and Associated Node Information — simDAG-package","text":"package ? package aims give comprehensive framework simulate static longitudinal data given directed acyclic graph information node. goal make package user-friendly intuitive possible, allowing extreme flexibility keeping underlying code fast RAM efficient possible. features included package? package includes two main simulation functions: sim_from_dag function, can used simulate data previously defined causal DAG node information sim_discrete_time function, implements framework conduct discrete-time simulations. former easy use, deal time-varying variable easily. latter little difficult use (usually requiring user write functions ), allows simulation arbitrarily complex longitudinal data. collection implemented node types, package allows user generate data mix binary, categorical, count time--event data. sim_discrete_time function additionally enables user generate time--event data , desired, mix competing events, recurrent events, time-varying variables influence types censoring. package also includes functions transform resulting data multiple formats, augment existing DAGs, plot DAGs plot flow-chart data generation process. mentioned features may also combined networks-based simulation, user-specified network dependencies among individuals may used directly specifying nodes. One multiple networks (directed undirected, weighted unweighted) may may change time (possibly function variables) supported. typical workflow using package look like? Users start defining DAG object using empty_dag node functions. DAG can passed one two simulation functions included package. information can found respective documentation pages three vignettes package. use sim_from_dag sim_discrete_time? want simulate data easily described using standard DAG without time-varying variables, use sim_from_dag function. DAG includes time-varying variables, want consider points time can easily describe relations manually, can still use sim_from_dag function. want complex data time-varying variables, particularly time--event outcomes, consider using sim_discrete_time function. features missing package? package currently implements possible child nodes. future like implement child node types, complex survival time models extending already existing support multilevel modeling node types. use package instead simcausal package? simcausal package big inspiration package. contrast , however, allows quite bit flexibility. big difference package includes comprehensive framework discrete-time simulations simcausal package . can get information? documentation pages contain lot information, relevant examples literature references. Additional examples can found vignettes package, can accessed using: vignette(topic=\"v_sim_from_dag\", package=\"simDAG\") vignette(topic=\"v_sim_discrete_time\", package=\"simDAG\") vignette(topic=\"v_covid_example\", package=\"simDAG\") vignette(topic=\"v_using_formulas\", package=\"simDAG\") vignette(topic=\"v_custom_nodes\", package=\"simDAG\") vignette(topic=\"v_cookbook\", package=\"simDAG\") vignette(topic=\"v_sim_networks\", package=\"simDAG\") separate (already peer-reviewed) article package provisionally accepted Journal Statistical Software. preprint version article available arXiv (Denz Timmesfeld 2025). problem using sim_discrete_time function sim_discrete_time function can become difficult use depending kind data user wants generate. reason put extra effort make documentation examples clear helpful possible. Please consult relevant documentation pages vignettes contacting authors directly programming related questions clearly bugs code. want suggest new feature / want report bug. can ? Bug reports, suggestions feature requests highly welcome. Please file issue official github page contact author directly using supplied e-mail address.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/simDAG.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Simulate Data from a DAG and Associated Node Information — simDAG-package","text":"Denz, Robin Nina Timmesfeld (2025). Simulating Complex Crossectional Longitudinal Data using simDAG R Package. arXiv preprint, doi: 10.48550/arXiv.2506.01498. Banks, Jerry, John S. Carson II, Barry L. Nelson, David M. Nicol (2014). Discrete-Event System Simulation. Vol. 5. Edinburgh Gate: Pearson Education Limited.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/simDAG.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Simulate Data from a DAG and Associated Node Information — simDAG-package","text":"Robin Denz, <robin.denz@rub.de>","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/sim_discrete_event.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate Data from a DAG with Time-Dependent Variables using Discrete-Event Simulation — sim_discrete_event","title":"Simulate Data from a DAG with Time-Dependent Variables using Discrete-Event Simulation — sim_discrete_event","text":"EXPERIMENTAL: Similar sim_discrete_time, function allows users generate complex data time-varying variables DAG defined using node node_td calls. contrast sim_discrete_time, time modelled continuous variable using discrete-event simulation approach. See details.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/sim_discrete_event.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate Data from a DAG with Time-Dependent Variables using Discrete-Event Simulation — sim_discrete_event","text":"","code":"sim_discrete_event(dag, n_sim=NULL, t0_sort_dag=FALSE,                    t0_data=NULL, t0_transform_fun=NULL,                    t0_transform_args=list(),                    max_t, remove_if, break_if,                    redraw_at_t=NULL,                    censor_at_max_t=FALSE, target_event=NULL,                    keep_only_first=FALSE, check_inputs=TRUE)"},{"path":"https://robindenz1.github.io/simDAG/reference/sim_discrete_event.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate Data from a DAG with Time-Dependent Variables using Discrete-Event Simulation — sim_discrete_event","text":"dag DAG object created using empty_dag function node_td calls added (see details examples). dag contains root nodes child nodes time-fixed (added using node calls), data according DAG generated time = 0. data used starting data following simulation. Alternatively, user can specify t0_data argument directly. either case, supplied dag needs contain least one time-dependent node type \"next_time\", added using node_td function. time-dependent node types currently supported. n_sim single number specifying many observations generated. data.table supplied t0_data argument, argument ignored. sample size correspond number rows t0_data. t0_sort_dag Corresponds sort_dag argument sim_from_dag function. Ignored t0_data specified. t0_data optional data.table like object (also accepts data.frame, tibble etc.) containing values relevant variables \\(t = 0\\). dataset transformed time according nodes specified using node_td calls dag. Alternatively, data \\(t = 0\\) may generated automatically function standard node calls added dag. t0_transform_fun optional function takes data created \\(t = 0\\) first argument. function applied starting data output replace data.table. Can used perform arbitrary data transformations starting data created. Set NULL (default) use functionality. t0_transform_args named list additional arguments passed t0_transform_fun. Ignored t0_transform_fun=NULL. max_t single number specifying time needs reached individuals simulation terminated. can set Inf, end simulation can determinated means (e.g. remove_if break_if arguments, variables event duration immunity duration infinite). remove_if condition evaluated directly generated data.table jump next event. rows condition TRUE removed data point time. condition may contain names variable generated. rows removed condition, simulation stops early. argument may useful save computation time, large number variables many state changed need considered user cares first time condition met individuals. Keep argument unspecified (default) use functionality. break_if condition evaluated jump next event (subsetting, remove_if specified). condition met, simulation stops early. Contrary remove_if argument, condition return exactly one TRUE FALSE value directly evaluated data. use variables generated simulation condition, users use $ syntax (e.g. use data$X instead just X). Keep argument unspecified (default) use functionality. redraw_at_t numeric vector positive values specifying times time next event re-drawn, regardless whether event occurred time . may useful specify effects baseline probabilities vary discrete intervals time. Note using argument potentially adds multiple additional rows output, variables change. Set NULL use functionality (default). censor_at_max_t Either TRUE FALSE, specifying whether last generated time censored user-specified value max_t. Since simulation jumps times events, last observed event time may often larger max_t initially. Setting TRUE censors values appropriately potentially discards last state-change. target_event default (keeping argument FALSE) time-varying nodes treated equally creating start-stop intervals. can changed supplying single character string argument, naming one nodes. node treated outcome. output corresponds needed fit Cox proportional hazards model node outcome. keep_only_first used target_event NULL. Either TRUE FALSE (default). TRUE, information first event per person discarded. Useful target_event treated terminal variable. check_inputs Whether perform plausibility checks user input . set TRUE default, can set FALSE order speed things using function simulation study something similar.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/sim_discrete_event.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulate Data from a DAG with Time-Dependent Variables using Discrete-Event Simulation — sim_discrete_event","text":"function purely experimental. currently needs tests checks. Use risk. Discrete-Event Simulation?: discrete-event simulations (DES), system modelled sequence distinct events occur time may influence . contrast discrete-time simulations, time DES advanced amount whenever event occurs. state system updated according event next advancement made. possibly simplest example DES, compared discrete-time simulation system just one variable, Y single individual. start, Y zero. interested time Y turns 1 first time. probability 1 turning one one unit time set fixed value 0.01. discrete-time simulation, perform single Bernoulli trial probability 0.01. trial returns 1, finished save current simulation time. 0, increase time 1 repeat process Y eventually 1. DES hand, simply draw time Y turns 1 suitable distribution (example simple exponential distribution sufficient). simple cases, using discrete-time simulation approach clearly worse strategy. reason perform many computations drawing single exponentially distributed random number enough. complex data generation processes, example include time-varying variables influence time, using DES gets complicated. Works: Internally, function works first simulating data using sim_from_dag function. Alternatively, user can supply custom data.table using t0_data argument. data defines state entities \\(t = 0\\). Afterwards, following algorithm used simulated individual: (1) time next change variable generated included time-varying variable separately, possibly dependent variables. (2) minimum times used new simulation time. (3) variable corresponding choosen time updated. process repeated changes needed anymore (e.g. time-dependent variables reached absorbing states, max_t reached), user-specified break condition reached (argument break_if), individuals left conditional subsetting (argument remove_if). first iteration, times sampled step (1) sampled left-truncated distributions, truncation time equal current simulation time. case time already passed individual, next event change must least time afterwards. Users may specify function calculate rate probability used depending state. Users may also use function draw time next change. Specifying dag argument: dag argument specified described node documentation page. examples specific discrete-event simulations can found vignettes examples. difference specifying dag sim_from_dag function dag contain least one time-dependent node added using node_td function, uses type=\"next_time\". Networks-Based Simulation: Currently supported, future versions. Speed Considerations: general, function lot faster corresponding sim_discrete_time call, require going considered points time directly. computation time therefore change substantially () higher values max_t. Instead, increases higher values n_sim, amount time-dependent variables , importantly, frequency variables change. frequently variable changes back forth TRUE FALSE, iterations needed thus time needed. Current limitations: Unlike sim_discrete_time function, assume parametric distributions, function requires user specify function may used generate time next change binary variable. Multiple built-options provided, nevertheless less flexible. Additionally, binary time-dependent variables supported (restrictions set time-fixed variables). forms dependencies harder (impossible) specify using discrete-event approach. example, simulating effects variables overall event probabilities smooth functions time difficult. event probability constant time changes variable changed, simple left-truncated exponential distribution (see rtexp) may used. general event probability vary time, times may generated using Weibull parametric functions. case, users know clearly functions use provide function able generate truncated random values distribution. requirements met, discrete-time simulation may alternative.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/sim_discrete_event.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Simulate Data from a DAG with Time-Dependent Variables using Discrete-Event Simulation — sim_discrete_event","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/sim_discrete_event.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate Data from a DAG with Time-Dependent Variables using Discrete-Event Simulation — sim_discrete_event","text":"Returns single data.table including least following columns: .id: unique individual identifier, coded integers. start: start time period, coded numeric value. stop: end time period, coded numeric value. Additionally, returned data include time-constant time-dependent variables generated. options data formatted given function (see censor_at_max_t, target_event keep_only_first). long- wide-format supported, time usually modelled continuous variable.","code":""},{"path":[]},{"path":"https://robindenz1.github.io/simDAG/reference/sim_discrete_event.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Simulate Data from a DAG with Time-Dependent Variables using Discrete-Event Simulation — sim_discrete_event","text":"Denz, Robin Nina Timmesfeld (2025). Simulating Complex Crossectional Longitudinal Data using simDAG R Package. arXiv preprint, doi: 10.48550/arXiv.2506.01498. Tang, Jiangjun, George Leu, und Hussein . Abbass. 2020. Simulation Computational Red Teaming Problem Solving. Hoboken: IEEE Press. Banks, Jerry, John S. Carson II, Barry L. Nelson, David M. Nicol (2014). Discrete-Event System Simulation. Vol. 5. Edinburgh Gate: Pearson Education Limited.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/sim_discrete_event.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate Data from a DAG with Time-Dependent Variables using Discrete-Event Simulation — sim_discrete_event","text":"","code":"library(simDAG)  set.seed(454236)  ## simulating death dependent on age, sex, bmi ## NOTE: this example is explained in detail in one of the vignettes  # initializing a DAG with nodes for generating data at t0 dag <- empty_dag() +   node(\"age\", type=\"rnorm\", mean=50, sd=4) +   node(\"sex\", type=\"rbernoulli\", p=0.5) +   node(\"bmi\", type=\"gaussian\", parents=c(\"sex\", \"age\"),        betas=c(1.1, 0.4), intercept=12, error=2)  # a function to calculate the probability of death as a # linear combination of age, sex and bmi on the log scale prob_death <- function(data, beta_age, beta_sex, beta_bmi,                        beta_sickness, intercept) {   prob <- intercept + data$age*beta_age + data$sex*beta_sex +     data$bmi*beta_bmi + data$sickness*beta_sickness   prob <- 1/(1 + exp(-prob))   return(prob) }  # adding time-dependent nodes to the dag dag <- dag +   node_td(\"sickness\", type=\"next_time\", prob_fun=0.01,           event_duration=50, immunity_duration=Inf) +   node_td(\"death\", type=\"next_time\", parents=c(\"age\", \"sex\", \"bmi\"),           prob_fun=prob_death, beta_age=0.1, beta_bmi=0.3, beta_sex=-0.2,           beta_sickness=1.1,           intercept=-20, event_duration=Inf)  # run simulation for 100 people, until everyone died sim_dt <- sim_discrete_event(n_sim=100, dag=dag, max_t=Inf,                              remove_if=death==TRUE,                              target_event=\"death\")"},{"path":"https://robindenz1.github.io/simDAG/reference/sim_discrete_time.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate Data from a DAG with Time-Dependent Variables — sim_discrete_time","title":"Simulate Data from a DAG with Time-Dependent Variables — sim_discrete_time","text":"Similar sim_from_dag function, function can used generate data given DAG created using empty_dag node node_td functions (possibly network network_td functions). contrast sim_from_dag function, function utilizes discrete-time simulation approach. \"--shelves\" simulation function, rather seen \"framework-function\", making easier create discrete-time-simulations. usually requires custom functions written user. See details.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/sim_discrete_time.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate Data from a DAG with Time-Dependent Variables — sim_discrete_time","text":"","code":"sim_discrete_time(dag, n_sim=NULL, t0_sort_dag=FALSE,                   t0_data=NULL, t0_transform_fun=NULL,                   t0_transform_args=list(), max_t,                   tx_nodes_order=NULL, tx_transform_fun=NULL,                   tx_transform_args=list(),                   remove_if, break_if,                   save_states=\"last\", save_states_at=NULL,                   save_networks=FALSE,                   verbose=FALSE, check_inputs=TRUE)"},{"path":"https://robindenz1.github.io/simDAG/reference/sim_discrete_time.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate Data from a DAG with Time-Dependent Variables — sim_discrete_time","text":"dag DAG object created using empty_dag function node_td calls added (see details examples). dag contains root nodes child nodes time-fixed (added using node calls), data according DAG generated time = 0. data used starting data following simulation. Alternatively, user can specify t0_data argument directly. either case, supplied dag needs contain least one time-dependent node added using node_td function. n_sim single number specifying many observations generated. data.table supplied t0_data argument, argument ignored. sample size correspond number rows t0_data. t0_sort_dag Corresponds sort_dag argument sim_from_dag function. Ignored t0_data specified. t0_data optional data.table like object (also accepts data.frame, tibble etc.) containing values relevant variables \\(t = 0\\). dataset transformed time according nodes specified using node_td calls dag. Alternatively, data \\(t = 0\\) may generated automatically function standard node calls added dag. t0_transform_fun optional function takes data created \\(t = 0\\) first argument. function applied starting data output replace data.table. Can used perform arbitrary data transformations starting data created. Set NULL (default) use functionality. t0_transform_args named list additional arguments passed t0_transform_fun. Ignored t0_transform_fun=NULL. max_t single integer specifying final point time simulation carried . simulation start \\(t = 1\\) (creating starting data arguments ) continue max_t increasing time one unit every step, updating time-dependent nodes along way. tx_nodes_order numeric vector specifying order time-dependent nodes added dag object using node_td function executed time step. NULL (default), nodes generated order originally added. tx_transform_fun optional function takes data created every point time  \\(t > 0\\) first argument simulation time second argument. function applied data node functions point time executed output replace previous data.table. Can used perform arbitrary data transformations every point time. Set NULL (default) use functionality. tx_transform_args named list additional arguments passed tx_transform_fun. Ignored tx_transform_fun=NULL. remove_if condition evaluated directly generated data.table beginning time-period. rows condition TRUE removed data point time. condition may contain names variable generated. individuals removed condition, simulation stops early. argument may useful save computation time, large number points time considered user cares first time condition met individuals. Keep argument unspecified (default) use functionality. break_if condition evaluated beginning time-period (subsetting, remove_if specified). condition met, simulation stops early. Contrary remove_if argument, condition return exactly one TRUE FALSE value directly evaluated data. use variables generated simulation condition, users use $ syntax (e.g. use data$X instead just X). Keep argument unspecified (default) use functionality. save_states Specifies amount simulation states saved output object. one \"\", \"at_t\" \"last\" (default). set \"\", list containing data.table every point time added output object. \"at_t\", states specific points time specified save_states_at argument saved (plus final state). \"last\", final state data.table added output. save_states_at specific points time simulated data.table saved. Ignored save_states!=\"at_t\". save_networks Either TRUE FALSE, specifying whether networks saved time. relevant dag contains one network network_td calls. set TRUE networks (including time-independent ones) saved according specification save_states argument. verbose TRUE prints one line every point time node function executed. can useful debugging custom node functions. Defaults FALSE. check_inputs Whether perform plausibility checks user input . set TRUE default, can set FALSE order speed things using function simulation study something similar.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/sim_discrete_time.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulate Data from a DAG with Time-Dependent Variables — sim_discrete_time","text":"Sometimes necessary simulate complex data described easily single DAG node information. may case desired data contain multiple time-dependent variables time--event variables event time-dependent effects events. example data vaccinations effects occurrence adverse events (see vignette). Discrete-Time Simulation can effective tool generate kinds datasets. Discrete-Time Simulation?: discrete-time simulation, entities certain states associated change discrete points time. example, entities people state alive dead. example generate 100 people covariates age, sex etc.. start increasing simulation time one day. person now check person died using bernoulli trial, probability dying generated point time based covariates. simulation time increased process repeated reach max_t. Due iterative process easy simulate arbitrarily complex data. covariates may change time arbitrary ways, event probability can functional relationship covariates . want model event type terminal, occurrence cardiovascular disease, events can easily simulated dependent timing number previous events. Since Discrete-Time Simulation special case Discrete-Event Simulation, introductory textbooks latter can great help getting better understanding former. Works: Internally, function works first simulating data using sim_from_dag function. Alternatively, user can supply custom data.table using t0_data argument. data defines state entities \\(t = 0\\). Afterwards, simulation time increased one unit data transformed place calling node function defined time-dependent nodes added dag using node_td function (either order added dag object order defined tx_nodes_order argument). Usually, transformation changes state entities way. example age variable, probably increase age person one time unit every step. max_t reached, resulting data.table returned. contains state entities last step additional information experienced events (node_time_to_event used time-dependent node). Multiple -depth examples can found vignettes package. Specifying dag argument: dag argument specified described node documentation page. examples specific discrete-time simulations can found vignettes examples. difference specifying dag sim_from_dag function dag contain least one time-dependent node added using node_td function. Usage formula argument non-linear interaction terms discouraged performance reasons. Networks-Based Simulation: sim_from_dag function, networks-based simulations also directly supported. Users may define static networks (using network function) / dynamic networks may evolve time(using network_td function). using net function inside formula argument node node_td calls, complex dependencies among observations depending neighbors observation may simulated. information given associated vignette documentation pages network network_td. Speed Considerations: functions package rely data.table backend order make memory efficient faster. however important note time simulate dataset increases non-linearly increasing max_t value additional time-dependent nodes. usually concern smaller datasets, n_sim large (say > 1 million) function get rather slow. Note also using formula argument lot computationally expensive using parents, betas approach specify certain nodes. cases, remove_if break_if arguments may reduce computation time considerably. example, user interested first time variable Y turns TRUE, may make sense use remove_if=Y==TRUE. hood, function removes individual Y already TRUE, data shrinks computations performed individuals. Unofrtunately, whether actually improve performance dependent multiple factors. large n_sim max_t, constant skewed probability distribution Y especially expensive calculations performed point time, performance gains may large. , however, always case. added computational burden actually subsetting point time may offset performance gains even deteriorate performance scenarios. recommend checking computation time single example without using either remove_if /break_if (appropriate) making decision based small benchmark. output?: function outputs simDT object, data.table. obtain actual dataset output function, users use sim2data function transform desired format. Currently, long-format, wide-format start-stop format supported. See sim2data information. Words Caution: cases necessary user write functions order actually use sim_discrete_time function. Unlike sim_from_dag function, many popular node types can implemented re-usable way, discrete-time simulation always require custom input user. price users pay almost unlimited flexibility offered simulation methodology.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/sim_discrete_time.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Simulate Data from a DAG with Time-Dependent Variables — sim_discrete_time","text":"Robin Denz, Katharina Meiszl","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/sim_discrete_time.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate Data from a DAG with Time-Dependent Variables — sim_discrete_time","text":"Returns simDT object, containing general information simulated data well final state simulated dataset (states, depending specification save_states argument). particular, includes following objects: past_states: list containing generated data specified points time. past_networks: list containing generated / updated networks specified points time. save_states: value save_states argument supplied user. data: data time max_t. Note remove_if used, data may include n_sim individuals. data_t0: data time 0. included remove_if specified. tte_past_events: list storing times events happened variables type \"time_to_event\", specified. ce_past_events: list storing times events happened variables type \"competing_events\", specified. ce_past_causes: list storing types events happened variables type \"competing_events\", specified. tx_nodes: list time-varying nodes, specified supplied dag object. max_t: value max_t, supplied user. d_max_t: data.table containing n_sim rows two columns .id (unique person identifier) max_t (maximum time individual actually included data generation). included remove_if specified user. break_t: time simulation stopped either break condition defined break_if argument first met, time individuals included data everyone removed remove_if argument. neither break_if remove_if specified, simply equal max_t. t0_var_names: character vector containing names variable names vary time. obtain single dataset function can processed , please use sim2data function.","code":""},{"path":[]},{"path":"https://robindenz1.github.io/simDAG/reference/sim_discrete_time.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Simulate Data from a DAG with Time-Dependent Variables — sim_discrete_time","text":"Denz, Robin Nina Timmesfeld (2025). Simulating Complex Crossectional Longitudinal Data using simDAG R Package. arXiv preprint, doi: 10.48550/arXiv.2506.01498. Tang, Jiangjun, George Leu, und Hussein . Abbass. 2020. Simulation Computational Red Teaming Problem Solving. Hoboken: IEEE Press. Banks, Jerry, John S. Carson II, Barry L. Nelson, David M. Nicol (2014). Discrete-Event System Simulation. Vol. 5. Edinburgh Gate: Pearson Education Limited.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/sim_discrete_time.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate Data from a DAG with Time-Dependent Variables — sim_discrete_time","text":"","code":"library(simDAG)  set.seed(454236)  ## simulating death dependent on age, sex, bmi ## NOTE: this example is explained in detail in one of the vignettes  # initializing a DAG with nodes for generating data at t0 dag <- empty_dag() +   node(\"age\", type=\"rnorm\", mean=50, sd=4) +   node(\"sex\", type=\"rbernoulli\", p=0.5) +   node(\"bmi\", type=\"gaussian\", parents=c(\"sex\", \"age\"),        betas=c(1.1, 0.4), intercept=12, error=2)  # a function that increases age as time goes on node_advance_age <- function(data) {   return(data$age + 1/365) }  # a function to calculate the probability of death as a # linear combination of age, sex and bmi on the log scale prob_death <- function(data, beta_age, beta_sex, beta_bmi, intercept) {   prob <- intercept + data$age*beta_age + data$sex*beta_sex + data$bmi*beta_bmi   prob <- 1/(1 + exp(-prob))   return(prob) }  # adding time-dependent nodes to the dag dag <- dag +   node_td(\"age\", type=\"advance_age\", parents=\"age\") +   node_td(\"death\", type=\"time_to_event\", parents=c(\"age\", \"sex\", \"bmi\"),           prob_fun=prob_death, beta_age=0.1, beta_bmi=0.3, beta_sex=-0.2,           intercept=-20, event_duration=Inf, save_past_events=FALSE) #> Error in get(paste0(\"node_\", type)): object 'node_advance_age' not found  # run simulation for 100 people, 50 days long sim_dt <- sim_discrete_time(n_sim=100,                             dag=dag,                             max_t=50,                             verbose=FALSE) #> Error: 'dag' must contain at least one time-varying node added using the node_td() function. For dag objects with no time-varying nodes, please use the sim_from_dag() function instead."},{"path":"https://robindenz1.github.io/simDAG/reference/sim_from_DAG.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate Data from a DAG — sim_from_dag","title":"Simulate Data from a DAG — sim_from_dag","text":"function can used generate data given DAG. DAG created using empty_dag node functions, require user fully specify variables, including information distributions, beta coefficients , depending node type, parameters intercepts. Network dependencies among observations may also included using network function.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/sim_from_DAG.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate Data from a DAG — sim_from_dag","text":"","code":"sim_from_dag(dag, n_sim, sort_dag=FALSE, return_networks=FALSE,              check_inputs=TRUE)"},{"path":"https://robindenz1.github.io/simDAG/reference/sim_from_DAG.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate Data from a DAG — sim_from_dag","text":"dag DAG object created using empty_dag function node calls (potentially network calls) added using + syntax. See details. n_sim single number specifying many observations generated. sort_dag Whether topologically sort DAG starting simulation . nodes dag already added topologically sorted manner, argument can kept FALSE. recommended rely argument heavily, sorting may sometimes fail formula supplied one node calls. return_networks Whether also return networks included generated due presence network calls supplied dag . set TRUE, named list length 2 returned instead returning generated data. Defaults FALSE. check_inputs Whether perform plausibility checks user input . set TRUE default, can set FALSE order speed things using function simulation study something similar.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/sim_from_DAG.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulate Data from a DAG — sim_from_dag","text":"Works: First, n_sim ..d. samples root nodes drawn. Children nodes generated one one according specified relationships causal coefficients. example, lets suppose two root nodes, age sex. generated normal distribution bernoulli distribution respectively. Afterward, child node height generated using variables parents according linear regression defined coefficients, intercept sigma (random error). works every DAG least one topological ordering, linear ordering vertices every directed edge \\(u\\) \\(v\\), vertex \\(u\\) comes \\(v\\) ordering. using sort_dag=TRUE ensured nodes processed ordering. procedure simple theory, can get complex manually coded. function offers simplified workflow requiring user define dag object appropriate information (see documentation node function). sample size n_sim generated DAG specified two arguments. Specifying DAG: Concrete details specify needed dag object given documentation page node network functions vignettes package. Can function create longitudinal data? Yes . theoretically can, user-specified dag directly specifies node desired point time. Using sim_discrete_time better cases. brief discussion topic can found vignettes package. time-dependent nodes added dag using node_td calls, function may used. sim_discrete_time function work case. Networks-Based Simulation cases assumption observations (rows) independent sufficient. function allows relax assumption directly supporting network-based dependencies among individuals. Users may specify one multiple networks dependencies individuals add dag using network function. possible use net function inside formula argument node calls directly make value node dependent variable values ' neighbors network. See documentation associated vignette information.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/sim_from_DAG.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Simulate Data from a DAG — sim_from_dag","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/sim_from_DAG.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate Data from a DAG — sim_from_dag","text":"return_networks=FALSE, returns single data.table including simulated data (least) one column per node specified dag n_sim rows. Otherwise returns named list containing data networks supplied generated course simulation.","code":""},{"path":[]},{"path":"https://robindenz1.github.io/simDAG/reference/sim_from_DAG.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Simulate Data from a DAG — sim_from_dag","text":"Denz, Robin Nina Timmesfeld (2025). Simulating Complex Crossectional Longitudinal Data using simDAG R Package. arXiv preprint, doi: 10.48550/arXiv.2506.01498.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/sim_from_DAG.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate Data from a DAG — sim_from_dag","text":"","code":"library(simDAG)  set.seed(345345)  dag <- empty_dag() +   node(\"age\", type=\"rnorm\", mean=50, sd=4) +   node(\"sex\", type=\"rbernoulli\", p=0.5) +   node(\"bmi\", type=\"gaussian\", parents=c(\"sex\", \"age\"),        betas=c(1.1, 0.4), intercept=12, error=2)  sim_dat <- sim_from_dag(dag=dag, n_sim=1000)  # More examples for each directly supported node type as well as for custom # nodes can be found in the documentation page of the respective node function"},{"path":"https://robindenz1.github.io/simDAG/reference/sim_n_datasets.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate multiple datasets from a single DAG object — sim_n_datasets","title":"Simulate multiple datasets from a single DAG object — sim_n_datasets","text":"function takes single DAG object generates list multiple datasets, possible using parallel processing","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/sim_n_datasets.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate multiple datasets from a single DAG object — sim_n_datasets","text":"","code":"sim_n_datasets(dag, n_sim, n_repeats, n_cores=1,                data_format=\"raw\", data_format_args=list(),                seed=NULL, progressbar=TRUE, ...)"},{"path":"https://robindenz1.github.io/simDAG/reference/sim_n_datasets.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate multiple datasets from a single DAG object — sim_n_datasets","text":"dag DAG object created using empty_dag function nodes added using + syntax. See ?empty_dag ?node details. dag contains time-varying nodes added using node_td function, sim_discrete_time function used generate data. Otherwise, sim_from_dag function used. n_sim single number specifying many observations per dataset generated. n_repeats single number specifying many datasets generated. n_cores single number specifying amount cores used. n_cores = 1, simple loop used generate datasets parallel processing. n_cores > 1 used, doSNOW package used conjunction doRNG package generate datasets parallel. using doRNG package, results completely reproducible setting seed. data_format optional character string specifying output format generated datasets. \"raw\" (default), dataset returned generated respective data generation function. dag contains time-varying nodes added using node_td function argument set either \"start_stop\", \"long\" \"wide\", sim2data function called transform dataset defined format. string supplied, regardless whether time-varying nodes included dag , function name given string called transform data. can function. requirement named argument called data. Arguments function can set using data_format_args argument (see ). data_format_args optional list named arguments passed function specified data_format. Set list() use arguments. Ignored data_format=\"raw\". seed seed random number generator. supplying value argument, results replicable, even parallel processing used generate datasets (using n_cores > 1), thanks magic performed doRNG package. See details. progressbar Either TRUE (default) FALSE, specifying whether progressbar used. Currently works n_cores > 1, ignored otherwise. ... arguments passed sim_from_dag function (dag contain time-varying nodes) sim_discrete_time function (dag contains time-varying nodes).","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/sim_n_datasets.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulate multiple datasets from a single DAG object — sim_n_datasets","text":"Generating number datasets single defined dag object usually first step conducting monte-carlo simulation studies. simply convenience function automates process using parallel processing (specified). Note complex monte-carlo simulations function may ideal, allow user vary aspects data-generation mechanism inside main loop, can handle single dag. example, user wants simulate n_repeats datasets confounding n_repeats datasets without confounding, /call function twice. optimal, setting clusters parallel processing takes processing time. many different dags used, make sense write single function generates dag desired settings. can sadly automated us though.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/sim_n_datasets.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Simulate multiple datasets from a single DAG object — sim_n_datasets","text":"previous versions (< 0.4.1) seed argument set stats::runif(1), equivalent using seed=0. mistake, results output generated regardless set.seed call used calling sim_n_datasets(). default changed NULL, equivalent setting seed. obtain results versions < 0.4.1 (`seed` specified), use seed=0.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/sim_n_datasets.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Simulate multiple datasets from a single DAG object — sim_n_datasets","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/sim_n_datasets.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate multiple datasets from a single DAG object — sim_n_datasets","text":"Returns list length n_repeats containing datasets generated according supplied dag object.","code":""},{"path":[]},{"path":"https://robindenz1.github.io/simDAG/reference/sim_n_datasets.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate multiple datasets from a single DAG object — sim_n_datasets","text":"","code":"library(simDAG)  # some example DAG dag <- empty_dag() +   node(\"death\", type=\"binomial\", parents=c(\"age\", \"sex\"), betas=c(1, 2),        intercept=-10) +   node(\"age\", type=\"rnorm\", mean=10, sd=2) +   node(\"sex\", parents=\"\", type=\"rbernoulli\", p=0.5) +   node(\"smoking\", parents=c(\"sex\", \"age\"), type=\"binomial\",        betas=c(0.6, 0.2), intercept=-2)  # generate 10 datasets without parallel processing out <- sim_n_datasets(dag, n_repeats=10, n_cores=1, n_sim=100)  if (requireNamespace(\"doSNOW\") & requireNamespace(\"doRNG\") &     requireNamespace(\"foreach\")) {  # generate 10 datasets with parallel processing out <- sim_n_datasets(dag, n_repeats=10, n_cores=2, n_sim=100) } #> Loading required namespace: doSNOW #> Loading required namespace: doRNG #>    |                                                                               |                                                                      |   0%   |                                                                               |=======                                                               |  10%   |                                                                               |==============                                                        |  20%   |                                                                               |=====================                                                 |  30%   |                                                                               |============================                                          |  40%   |                                                                               |===================================                                   |  50%   |                                                                               |==========================================                            |  60%   |                                                                               |=================================================                     |  70%   |                                                                               |========================================================              |  80%   |                                                                               |===============================================================       |  90%   |                                                                               |======================================================================| 100%  # generate 10 datasets and transforming the output # (using the sim2data function internally) dag <- dag + node_td(\"CV\", type=\"time_to_event\", prob_fun=0.01) out <- sim_n_datasets(dag, n_repeats=10, n_cores=1, n_sim=100,                       max_t=20, data_format=\"start_stop\")"},{"path":"https://robindenz1.github.io/simDAG/news/index.html","id":"simdag-042","dir":"Changelog","previous_headings":"","what":"simDAG 0.4.2","title":"simDAG 0.4.2","text":"New Features Added rsample() function convenient wrapper around sample(), suggested Ed Hagen. Enhancements Added remove_if break_if arguments sim_discrete_time() function, allow users options potentially make simulation much faster.","code":""},{"path":"https://robindenz1.github.io/simDAG/news/index.html","id":"simdag-041","dir":"Changelog","previous_headings":"","what":"simDAG 0.4.1","title":"simDAG 0.4.1","text":"CRAN release: 2025-10-15 New Features Added link argument node_gaussian(), node_binomial(), node_poisson(), node_negative_binomial() node_zeroinfl() allow different link functions generating data nodes. Added .dagitty.DAG() function allow direct conversion DAG objects dagitty objects. Bug Fixes Previously, sim_n_datasets() function used stats::runif(1) default seed argument. seeds coerced integers set.seed(), essentially meant seed argument always set 0 (unless changed user), intended. changed default NULL, equivalent setting seed. might change results obtained using previous versions. get result previous versions, use seed=0 seed=stats::runif(1). Fixed bug occurred calling node() node_td() inside function objects passed parents formula. Documentation Added explanations simulate data Cox models time-varying covariates Aalen additive hazards models time-varying covariates cookbook vignette.","code":""},{"path":"https://robindenz1.github.io/simDAG/news/index.html","id":"simdag-040","dir":"Changelog","previous_headings":"","what":"simDAG 0.4.0","title":"simDAG 0.4.0","text":"CRAN release: 2025-08-27 New Features Added network(), network_td() net() functions allow simulations network based dependencies among individuals. includes static dynamic networks regular DAGs discrete-time simulations. Enhancements Added kind argument node_identity() allow different kinds input formula argument. Added include_networks argument dag2matrix() .igraph(), due new networks-based simulation features. Added unif argument node_time_to_event() allow users generate multiple time--event nodes basically using “seed” value random number generator. Bug Fixes Fixed minor bug occurred using node + DAG (order). Fixed faulty error message produced using formula just one predictor nodes need intercept. Fixed faulty error message using string formula node_identity() sim_discrete_time(). Documentation Added new vignette describe new networks-based simulation features. Updated existing documentation pages include networks-based simulation features.","code":""},{"path":"https://robindenz1.github.io/simDAG/news/index.html","id":"simdag-032","dir":"Changelog","previous_headings":"","what":"simDAG 0.3.2","title":"simDAG 0.3.2","text":"CRAN release: 2025-06-24 Documentation Added vignette Journal Statistical Software paper (provisionally accepted) Changed citation information accordingly","code":""},{"path":"https://robindenz1.github.io/simDAG/news/index.html","id":"simdag-031","dir":"Changelog","previous_headings":"","what":"simDAG 0.3.1","title":"simDAG 0.3.1","text":"CRAN release: 2025-05-28 Enhancements Added remove_vars argument sim2data() function, allow users exclude certain variables output desired. Bug Fixes Fixed bug sim_n_datasets() fail n_cores > 1 whenever nested custom functions used nodes. Documentation previous node_custom documentation page turned vignette (start).","code":""},{"path":"https://robindenz1.github.io/simDAG/news/index.html","id":"simdag-030","dir":"Changelog","previous_headings":"","what":"simDAG 0.3.0","title":"simDAG 0.3.0","text":"CRAN release: 2025-03-30 New Features Support random effects random slopes (mixed model syntax) added formula interface node() node_td() using nodes type \"gaussian\", \"binomial\" \"poisson\". Added seven new node types: node_aftreg(), node_ahreg(), node_poreg(), node_ypreg(), node_ehreg(), node_zeroinfl() node_mixture(). Enhancements Added reference argument rbernoulli() rcategorical() make easier specify reference category coding output factor variable. +.DAG now checks whether DAG become cyclic adding node() returns error . Added include_td_nodes include_root_nodes arguments .igraph.DAG(). Changed default n_cores sim_n_datasets() function 1 parallel::detectCores() Function input cens_dist argument node_cox() function now allowed. argument as_two_cols added node_cox() function allow users return time--event single column censoring applied. Bug Fixes Fixed bug occurred user-specified root node function returned data.frame-like object one column. Fixed bug printing structural equation poisson node, exp() call show node defined using formula argument. Documentation Added new “cookbook” vignette showcase possible use cases package. Visual update DAGs shown vignette figures.","code":""},{"path":"https://robindenz1.github.io/simDAG/news/index.html","id":"simdag-022","dir":"Changelog","previous_headings":"","what":"simDAG 0.2.2","title":"simDAG 0.2.2","text":"CRAN release: 2025-02-23 Bug Fixes specifying node root child node time-dependent node, longer counted twice print.DAG() Fix small error tests due changes data.table","code":""},{"path":"https://robindenz1.github.io/simDAG/news/index.html","id":"simdag-021","dir":"Changelog","previous_headings":"","what":"simDAG 0.2.1","title":"simDAG 0.2.1","text":"CRAN release: 2025-01-07 Enhancements External variables may now used formula interface using eval() calls. Added remove_not_at_risk argument sim2data() function. Change default t0_sort_dag sim_discrete_time() TRUE FALSE consistency sim_from_dag(). Bug Fixes Using sim2data() time-dependent nodes type node_competing_events() longer results unwarranted error message. Using column name \"time\" time argument long2start_stop() now works properly. New Features Added node_identity() function allow users directly calculate nodes R expression nodes without need define new function. Documentation Added examples formula vignette.","code":""},{"path":"https://robindenz1.github.io/simDAG/news/index.html","id":"simdag-020","dir":"Changelog","previous_headings":"","what":"simDAG 0.2.0","title":"simDAG 0.2.0","text":"CRAN release: 2024-09-03 Enhancements Added output argument rbernoulli() function allow different output formats. Change default sort_dag sim_from_dag() TRUE FALSE. Moved functionality coerce2factor coerce2numeric arguments rcategorical(), node_multinomial() node_binomial() output argument consistent syntax easier usage. now allowed directly supply functions type argument node() node_td(). Passing optional arguments layout function plot.DAG() now supported. Bug Fixes node_fill argument plot.DAG() function longer ignored mark_td_nodes set TRUE. New Features Added new enhanced formula interface, allows users directly type underlying structural equations many node types. replaces old formula argument. Standard formulas (without betas intercepts) still supported, longer mentioned documentation deprecated future versions. Documentation Added new vignette explaining detail new enhanced formula interface node() function works.","code":""},{"path":"https://robindenz1.github.io/simDAG/news/index.html","id":"simdag-012","dir":"Changelog","previous_headings":"","what":"simDAG 0.1.2","title":"simDAG 0.1.2","text":"CRAN release: 2024-06-13 General simDAG longer lists data.table “Depends” description file. instead listed “Imports” recommended data.table crew Enhancements Print underlying structural equations summary.DAG() summary.DAG.node() Added overlap argument long2start_stop() sim2data() directly create start-stop data overlapping durations, needed statistical models Added target_event keep_only_first arguments sim2data() related functions, allow direct transformation model-ready dataset Made long2start_stop() function computationally efficient Bug Fixes Fixed small bug input checks node_time_to_event() function, printed error arguments prob_fun supplied, even arguments default values Fixed bug print.DAG.node() occurred time--event node parents supplied Fixed bug sim2data() lead inconsistent results event_duration=0 used one nodes type “time_to_event” “competing_events”. made realize event durations smaller 1 make sense. now longer allowed default node types changed accordingly. Fixed bug resulted errors interaction terms supplied formula objects child nodes New Features Added .igraph.DAG() method extends generic function .igraph() conveniently parse DAG objects igraph objects Added .data.table.simDT() .data.frame.simDT() user convenience Documentation Documentation pages nodes now include formal descriptions data generation mechanism Re-wrote documentation page custom node definition","code":""},{"path":"https://robindenz1.github.io/simDAG/news/index.html","id":"simdag-011","dir":"Changelog","previous_headings":"","what":"simDAG 0.1.1","title":"simDAG 0.1.1","text":"CRAN release: 2024-03-07 Enhancements node() node_td() now support character vectors ‘name’ argument, allowing easy creation multiple nodes definition Bug Fixes bug node_time_to_event() function lead immunity_duration parameter used incorrectly. Since events still recorded correctly, apparent using save_states=\"\". Works correctly now. small bug dag2matrix() dag object contained root nodes. case, logical matrix returned. Now returns correct numeric matrix. New Features Added sim_n_datasets() function generate multiple datasets single dag object, possibly using multicore processing Documentation Minor changes documentation pages Minor changes vignettes","code":""},{"path":"https://robindenz1.github.io/simDAG/news/index.html","id":"simdag-010","dir":"Changelog","previous_headings":"","what":"simDAG 0.1.0","title":"simDAG 0.1.0","text":"CRAN release: 2023-08-28 first release package","code":""}]
