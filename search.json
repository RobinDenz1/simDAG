[{"path":"https://robindenz1.github.io/simDAG/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"GNU General Public License","title":"GNU General Public License","text":"Version 3, 29 June 2007Copyright © 2007 Free Software Foundation, Inc. <http://fsf.org/> Everyone permitted copy distribute verbatim copies license document, changing allowed.","code":""},{"path":"https://robindenz1.github.io/simDAG/LICENSE.html","id":"preamble","dir":"","previous_headings":"","what":"Preamble","title":"GNU General Public License","text":"GNU General Public License free, copyleft license software kinds works. licenses software practical works designed take away freedom share change works. contrast, GNU General Public License intended guarantee freedom share change versions program–make sure remains free software users. , Free Software Foundation, use GNU General Public License software; applies also work released way authors. can apply programs, . speak free software, referring freedom, price. General Public Licenses designed make sure freedom distribute copies free software (charge wish), receive source code can get want , can change software use pieces new free programs, know can things. protect rights, need prevent others denying rights asking surrender rights. Therefore, certain responsibilities distribute copies software, modify : responsibilities respect freedom others. example, distribute copies program, whether gratis fee, must pass recipients freedoms received. must make sure , , receive can get source code. must show terms know rights. Developers use GNU GPL protect rights two steps: (1) assert copyright software, (2) offer License giving legal permission copy, distribute /modify . developers’ authors’ protection, GPL clearly explains warranty free software. users’ authors’ sake, GPL requires modified versions marked changed, problems attributed erroneously authors previous versions. devices designed deny users access install run modified versions software inside , although manufacturer can . fundamentally incompatible aim protecting users’ freedom change software. systematic pattern abuse occurs area products individuals use, precisely unacceptable. Therefore, designed version GPL prohibit practice products. problems arise substantially domains, stand ready extend provision domains future versions GPL, needed protect freedom users. Finally, every program threatened constantly software patents. States allow patents restrict development use software general-purpose computers, , wish avoid special danger patents applied free program make effectively proprietary. prevent , GPL assures patents used render program non-free. precise terms conditions copying, distribution modification follow.","code":""},{"path":[]},{"path":"https://robindenz1.github.io/simDAG/LICENSE.html","id":"id_0-definitions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"0. Definitions","title":"GNU General Public License","text":"“License” refers version 3 GNU General Public License. “Copyright” also means copyright-like laws apply kinds works, semiconductor masks. “Program” refers copyrightable work licensed License. licensee addressed “”. “Licensees” “recipients” may individuals organizations. “modify” work means copy adapt part work fashion requiring copyright permission, making exact copy. resulting work called “modified version” earlier work work “based ” earlier work. “covered work” means either unmodified Program work based Program. “propagate” work means anything , without permission, make directly secondarily liable infringement applicable copyright law, except executing computer modifying private copy. Propagation includes copying, distribution (without modification), making available public, countries activities well. “convey” work means kind propagation enables parties make receive copies. Mere interaction user computer network, transfer copy, conveying. interactive user interface displays “Appropriate Legal Notices” extent includes convenient prominently visible feature (1) displays appropriate copyright notice, (2) tells user warranty work (except extent warranties provided), licensees may convey work License, view copy License. interface presents list user commands options, menu, prominent item list meets criterion.","code":""},{"path":"https://robindenz1.github.io/simDAG/LICENSE.html","id":"id_1-source-code","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"1. Source Code","title":"GNU General Public License","text":"“source code” work means preferred form work making modifications . “Object code” means non-source form work. “Standard Interface” means interface either official standard defined recognized standards body, , case interfaces specified particular programming language, one widely used among developers working language. “System Libraries” executable work include anything, work whole, () included normal form packaging Major Component, part Major Component, (b) serves enable use work Major Component, implement Standard Interface implementation available public source code form. “Major Component”, context, means major essential component (kernel, window system, ) specific operating system () executable work runs, compiler used produce work, object code interpreter used run . “Corresponding Source” work object code form means source code needed generate, install, (executable work) run object code modify work, including scripts control activities. However, include work’s System Libraries, general-purpose tools generally available free programs used unmodified performing activities part work. example, Corresponding Source includes interface definition files associated source files work, source code shared libraries dynamically linked subprograms work specifically designed require, intimate data communication control flow subprograms parts work. Corresponding Source need include anything users can regenerate automatically parts Corresponding Source. Corresponding Source work source code form work.","code":""},{"path":"https://robindenz1.github.io/simDAG/LICENSE.html","id":"id_2-basic-permissions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"2. Basic Permissions","title":"GNU General Public License","text":"rights granted License granted term copyright Program, irrevocable provided stated conditions met. License explicitly affirms unlimited permission run unmodified Program. output running covered work covered License output, given content, constitutes covered work. License acknowledges rights fair use equivalent, provided copyright law. may make, run propagate covered works convey, without conditions long license otherwise remains force. may convey covered works others sole purpose make modifications exclusively , provide facilities running works, provided comply terms License conveying material control copyright. thus making running covered works must exclusively behalf, direction control, terms prohibit making copies copyrighted material outside relationship . Conveying circumstances permitted solely conditions stated . Sublicensing allowed; section 10 makes unnecessary.","code":""},{"path":"https://robindenz1.github.io/simDAG/LICENSE.html","id":"id_3-protecting-users-legal-rights-from-anti-circumvention-law","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"3. Protecting Users’ Legal Rights From Anti-Circumvention Law","title":"GNU General Public License","text":"covered work shall deemed part effective technological measure applicable law fulfilling obligations article 11 WIPO copyright treaty adopted 20 December 1996, similar laws prohibiting restricting circumvention measures. convey covered work, waive legal power forbid circumvention technological measures extent circumvention effected exercising rights License respect covered work, disclaim intention limit operation modification work means enforcing, work’s users, third parties’ legal rights forbid circumvention technological measures.","code":""},{"path":"https://robindenz1.github.io/simDAG/LICENSE.html","id":"id_4-conveying-verbatim-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"4. Conveying Verbatim Copies","title":"GNU General Public License","text":"may convey verbatim copies Program’s source code receive , medium, provided conspicuously appropriately publish copy appropriate copyright notice; keep intact notices stating License non-permissive terms added accord section 7 apply code; keep intact notices absence warranty; give recipients copy License along Program. may charge price price copy convey, may offer support warranty protection fee.","code":""},{"path":"https://robindenz1.github.io/simDAG/LICENSE.html","id":"id_5-conveying-modified-source-versions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"5. Conveying Modified Source Versions","title":"GNU General Public License","text":"may convey work based Program, modifications produce Program, form source code terms section 4, provided also meet conditions: ) work must carry prominent notices stating modified , giving relevant date. b) work must carry prominent notices stating released License conditions added section 7. requirement modifies requirement section 4 “keep intact notices”. c) must license entire work, whole, License anyone comes possession copy. License therefore apply, along applicable section 7 additional terms, whole work, parts, regardless packaged. License gives permission license work way, invalidate permission separately received . d) work interactive user interfaces, must display Appropriate Legal Notices; however, Program interactive interfaces display Appropriate Legal Notices, work need make . compilation covered work separate independent works, nature extensions covered work, combined form larger program, volume storage distribution medium, called “aggregate” compilation resulting copyright used limit access legal rights compilation’s users beyond individual works permit. Inclusion covered work aggregate cause License apply parts aggregate.","code":""},{"path":"https://robindenz1.github.io/simDAG/LICENSE.html","id":"id_6-conveying-non-source-forms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"6. Conveying Non-Source Forms","title":"GNU General Public License","text":"may convey covered work object code form terms sections 4 5, provided also convey machine-readable Corresponding Source terms License, one ways: ) Convey object code , embodied , physical product (including physical distribution medium), accompanied Corresponding Source fixed durable physical medium customarily used software interchange. b) Convey object code , embodied , physical product (including physical distribution medium), accompanied written offer, valid least three years valid long offer spare parts customer support product model, give anyone possesses object code either (1) copy Corresponding Source software product covered License, durable physical medium customarily used software interchange, price reasonable cost physically performing conveying source, (2) access copy Corresponding Source network server charge. c) Convey individual copies object code copy written offer provide Corresponding Source. alternative allowed occasionally noncommercially, received object code offer, accord subsection 6b. d) Convey object code offering access designated place (gratis charge), offer equivalent access Corresponding Source way place charge. need require recipients copy Corresponding Source along object code. place copy object code network server, Corresponding Source may different server (operated third party) supports equivalent copying facilities, provided maintain clear directions next object code saying find Corresponding Source. Regardless server hosts Corresponding Source, remain obligated ensure available long needed satisfy requirements. e) Convey object code using peer--peer transmission, provided inform peers object code Corresponding Source work offered general public charge subsection 6d. separable portion object code, whose source code excluded Corresponding Source System Library, need included conveying object code work. “User Product” either (1) “consumer product”, means tangible personal property normally used personal, family, household purposes, (2) anything designed sold incorporation dwelling. determining whether product consumer product, doubtful cases shall resolved favor coverage. particular product received particular user, “normally used” refers typical common use class product, regardless status particular user way particular user actually uses, expects expected use, product. product consumer product regardless whether product substantial commercial, industrial non-consumer uses, unless uses represent significant mode use product. “Installation Information” User Product means methods, procedures, authorization keys, information required install execute modified versions covered work User Product modified version Corresponding Source. information must suffice ensure continued functioning modified object code case prevented interfered solely modification made. convey object code work section , , specifically use , User Product, conveying occurs part transaction right possession use User Product transferred recipient perpetuity fixed term (regardless transaction characterized), Corresponding Source conveyed section must accompanied Installation Information. requirement apply neither third party retains ability install modified object code User Product (example, work installed ROM). requirement provide Installation Information include requirement continue provide support service, warranty, updates work modified installed recipient, User Product modified installed. Access network may denied modification materially adversely affects operation network violates rules protocols communication across network. Corresponding Source conveyed, Installation Information provided, accord section must format publicly documented (implementation available public source code form), must require special password key unpacking, reading copying.","code":""},{"path":"https://robindenz1.github.io/simDAG/LICENSE.html","id":"id_7-additional-terms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"7. Additional Terms","title":"GNU General Public License","text":"“Additional permissions” terms supplement terms License making exceptions one conditions. Additional permissions applicable entire Program shall treated though included License, extent valid applicable law. additional permissions apply part Program, part may used separately permissions, entire Program remains governed License without regard additional permissions. convey copy covered work, may option remove additional permissions copy, part . (Additional permissions may written require removal certain cases modify work.) may place additional permissions material, added covered work, can give appropriate copyright permission. Notwithstanding provision License, material add covered work, may (authorized copyright holders material) supplement terms License terms: ) Disclaiming warranty limiting liability differently terms sections 15 16 License; b) Requiring preservation specified reasonable legal notices author attributions material Appropriate Legal Notices displayed works containing ; c) Prohibiting misrepresentation origin material, requiring modified versions material marked reasonable ways different original version; d) Limiting use publicity purposes names licensors authors material; e) Declining grant rights trademark law use trade names, trademarks, service marks; f) Requiring indemnification licensors authors material anyone conveys material (modified versions ) contractual assumptions liability recipient, liability contractual assumptions directly impose licensors authors. non-permissive additional terms considered “restrictions” within meaning section 10. Program received , part , contains notice stating governed License along term restriction, may remove term. license document contains restriction permits relicensing conveying License, may add covered work material governed terms license document, provided restriction survive relicensing conveying. add terms covered work accord section, must place, relevant source files, statement additional terms apply files, notice indicating find applicable terms. Additional terms, permissive non-permissive, may stated form separately written license, stated exceptions; requirements apply either way.","code":""},{"path":"https://robindenz1.github.io/simDAG/LICENSE.html","id":"id_8-termination","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"8. Termination","title":"GNU General Public License","text":"may propagate modify covered work except expressly provided License. attempt otherwise propagate modify void, automatically terminate rights License (including patent licenses granted third paragraph section 11). However, cease violation License, license particular copyright holder reinstated () provisionally, unless copyright holder explicitly finally terminates license, (b) permanently, copyright holder fails notify violation reasonable means prior 60 days cessation. Moreover, license particular copyright holder reinstated permanently copyright holder notifies violation reasonable means, first time received notice violation License (work) copyright holder, cure violation prior 30 days receipt notice. Termination rights section terminate licenses parties received copies rights License. rights terminated permanently reinstated, qualify receive new licenses material section 10.","code":""},{"path":"https://robindenz1.github.io/simDAG/LICENSE.html","id":"id_9-acceptance-not-required-for-having-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"9. Acceptance Not Required for Having Copies","title":"GNU General Public License","text":"required accept License order receive run copy Program. Ancillary propagation covered work occurring solely consequence using peer--peer transmission receive copy likewise require acceptance. However, nothing License grants permission propagate modify covered work. actions infringe copyright accept License. Therefore, modifying propagating covered work, indicate acceptance License .","code":""},{"path":"https://robindenz1.github.io/simDAG/LICENSE.html","id":"id_10-automatic-licensing-of-downstream-recipients","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"10. Automatic Licensing of Downstream Recipients","title":"GNU General Public License","text":"time convey covered work, recipient automatically receives license original licensors, run, modify propagate work, subject License. responsible enforcing compliance third parties License. “entity transaction” transaction transferring control organization, substantially assets one, subdividing organization, merging organizations. propagation covered work results entity transaction, party transaction receives copy work also receives whatever licenses work party’s predecessor interest give previous paragraph, plus right possession Corresponding Source work predecessor interest, predecessor can get reasonable efforts. may impose restrictions exercise rights granted affirmed License. example, may impose license fee, royalty, charge exercise rights granted License, may initiate litigation (including cross-claim counterclaim lawsuit) alleging patent claim infringed making, using, selling, offering sale, importing Program portion .","code":""},{"path":"https://robindenz1.github.io/simDAG/LICENSE.html","id":"id_11-patents","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"11. Patents","title":"GNU General Public License","text":"“contributor” copyright holder authorizes use License Program work Program based. work thus licensed called contributor’s “contributor version”. contributor’s “essential patent claims” patent claims owned controlled contributor, whether already acquired hereafter acquired, infringed manner, permitted License, making, using, selling contributor version, include claims infringed consequence modification contributor version. purposes definition, “control” includes right grant patent sublicenses manner consistent requirements License. contributor grants non-exclusive, worldwide, royalty-free patent license contributor’s essential patent claims, make, use, sell, offer sale, import otherwise run, modify propagate contents contributor version. following three paragraphs, “patent license” express agreement commitment, however denominated, enforce patent (express permission practice patent covenant sue patent infringement). “grant” patent license party means make agreement commitment enforce patent party. convey covered work, knowingly relying patent license, Corresponding Source work available anyone copy, free charge terms License, publicly available network server readily accessible means, must either (1) cause Corresponding Source available, (2) arrange deprive benefit patent license particular work, (3) arrange, manner consistent requirements License, extend patent license downstream recipients. “Knowingly relying” means actual knowledge , patent license, conveying covered work country, recipient’s use covered work country, infringe one identifiable patents country reason believe valid. , pursuant connection single transaction arrangement, convey, propagate procuring conveyance , covered work, grant patent license parties receiving covered work authorizing use, propagate, modify convey specific copy covered work, patent license grant automatically extended recipients covered work works based . patent license “discriminatory” include within scope coverage, prohibits exercise , conditioned non-exercise one rights specifically granted License. may convey covered work party arrangement third party business distributing software, make payment third party based extent activity conveying work, third party grants, parties receive covered work , discriminatory patent license () connection copies covered work conveyed (copies made copies), (b) primarily connection specific products compilations contain covered work, unless entered arrangement, patent license granted, prior 28 March 2007. Nothing License shall construed excluding limiting implied license defenses infringement may otherwise available applicable patent law.","code":""},{"path":"https://robindenz1.github.io/simDAG/LICENSE.html","id":"id_12-no-surrender-of-others-freedom","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"12. No Surrender of Others’ Freedom","title":"GNU General Public License","text":"conditions imposed (whether court order, agreement otherwise) contradict conditions License, excuse conditions License. convey covered work satisfy simultaneously obligations License pertinent obligations, consequence may convey . example, agree terms obligate collect royalty conveying convey Program, way satisfy terms License refrain entirely conveying Program.","code":""},{"path":"https://robindenz1.github.io/simDAG/LICENSE.html","id":"id_13-use-with-the-gnu-affero-general-public-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"13. Use with the GNU Affero General Public License","title":"GNU General Public License","text":"Notwithstanding provision License, permission link combine covered work work licensed version 3 GNU Affero General Public License single combined work, convey resulting work. terms License continue apply part covered work, special requirements GNU Affero General Public License, section 13, concerning interaction network apply combination .","code":""},{"path":"https://robindenz1.github.io/simDAG/LICENSE.html","id":"id_14-revised-versions-of-this-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"14. Revised Versions of this License","title":"GNU General Public License","text":"Free Software Foundation may publish revised /new versions GNU General Public License time time. new versions similar spirit present version, may differ detail address new problems concerns. version given distinguishing version number. Program specifies certain numbered version GNU General Public License “later version” applies , option following terms conditions either numbered version later version published Free Software Foundation. Program specify version number GNU General Public License, may choose version ever published Free Software Foundation. Program specifies proxy can decide future versions GNU General Public License can used, proxy’s public statement acceptance version permanently authorizes choose version Program. Later license versions may give additional different permissions. However, additional obligations imposed author copyright holder result choosing follow later version.","code":""},{"path":"https://robindenz1.github.io/simDAG/LICENSE.html","id":"id_15-disclaimer-of-warranty","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"15. Disclaimer of Warranty","title":"GNU General Public License","text":"WARRANTY PROGRAM, EXTENT PERMITTED APPLICABLE LAW. EXCEPT OTHERWISE STATED WRITING COPYRIGHT HOLDERS /PARTIES PROVIDE PROGRAM “” WITHOUT WARRANTY KIND, EITHER EXPRESSED IMPLIED, INCLUDING, LIMITED , IMPLIED WARRANTIES MERCHANTABILITY FITNESS PARTICULAR PURPOSE. ENTIRE RISK QUALITY PERFORMANCE PROGRAM . PROGRAM PROVE DEFECTIVE, ASSUME COST NECESSARY SERVICING, REPAIR CORRECTION.","code":""},{"path":"https://robindenz1.github.io/simDAG/LICENSE.html","id":"id_16-limitation-of-liability","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"16. Limitation of Liability","title":"GNU General Public License","text":"EVENT UNLESS REQUIRED APPLICABLE LAW AGREED WRITING COPYRIGHT HOLDER, PARTY MODIFIES /CONVEYS PROGRAM PERMITTED , LIABLE DAMAGES, INCLUDING GENERAL, SPECIAL, INCIDENTAL CONSEQUENTIAL DAMAGES ARISING USE INABILITY USE PROGRAM (INCLUDING LIMITED LOSS DATA DATA RENDERED INACCURATE LOSSES SUSTAINED THIRD PARTIES FAILURE PROGRAM OPERATE PROGRAMS), EVEN HOLDER PARTY ADVISED POSSIBILITY DAMAGES.","code":""},{"path":"https://robindenz1.github.io/simDAG/LICENSE.html","id":"id_17-interpretation-of-sections-15-and-16","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"17. Interpretation of Sections 15 and 16","title":"GNU General Public License","text":"disclaimer warranty limitation liability provided given local legal effect according terms, reviewing courts shall apply local law closely approximates absolute waiver civil liability connection Program, unless warranty assumption liability accompanies copy Program return fee. END TERMS CONDITIONS","code":""},{"path":"https://robindenz1.github.io/simDAG/LICENSE.html","id":"how-to-apply-these-terms-to-your-new-programs","dir":"","previous_headings":"","what":"How to Apply These Terms to Your New Programs","title":"GNU General Public License","text":"develop new program, want greatest possible use public, best way achieve make free software everyone can redistribute change terms. , attach following notices program. safest attach start source file effectively state exclusion warranty; file least “copyright” line pointer full notice found. Also add information contact electronic paper mail. program terminal interaction, make output short notice like starts interactive mode: hypothetical commands show w show c show appropriate parts General Public License. course, program’s commands might different; GUI interface, use “box”. also get employer (work programmer) school, , sign “copyright disclaimer” program, necessary. information , apply follow GNU GPL, see <http://www.gnu.org/licenses/>. GNU General Public License permit incorporating program proprietary programs. program subroutine library, may consider useful permit linking proprietary applications library. want , use GNU Lesser General Public License instead License. first, please read <http://www.gnu.org/philosophy/--lgpl.html>.","code":"<one line to give the program's name and a brief idea of what it does.> Copyright (C) <year>  <name of author>  This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program.  If not, see <http://www.gnu.org/licenses/>. <program>  Copyright (C) <year>  <name of author> This program comes with ABSOLUTELY NO WARRANTY; for details type 'show w'. This is free software, and you are welcome to redistribute it under certain conditions; type 'show c' for details."},{"path":"https://robindenz1.github.io/simDAG/articles/v_covid_example.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Simulating Covid-19 Vaccine Data using a Discrete-Time Simulation","text":"vignette contains -depth example use sim_discrete_time() function generate complex time--event data. Unlike vignettes, rely overly simple example . Instead, aim generate somewhat realistic data Covid-19 pandemic. particular, interested generating longitudinal data set containing Covid-19 infections, vaccines adverse side effects vaccines. aim real study create data set reasonably close real data, including measurement problems described . data generation algorithm used identify suitable data analysis strategy real data. describe slightly simplified version data generation part give detailed example sim_discrete_time() function may used effectively. Note algorithm described completely one originally used, require us include confidential data vignette, sadly impossible. also strongly recommend reading two vignettes package first.","code":""},{"path":"https://robindenz1.github.io/simDAG/articles/v_covid_example.html","id":"how-to-get-started","dir":"Articles","previous_headings":"","what":"How to get started","title":"Simulating Covid-19 Vaccine Data using a Discrete-Time Simulation","text":"Simulating data reasonably close complex real system trivial task, even using package. Dividing big task obtaining valid data generation model multiple sub-tasks great first step right direction. suggest following 7 steps :","code":""},{"path":"https://robindenz1.github.io/simDAG/articles/v_covid_example.html","id":"formulate-the-goal-of-your-research-project-in-a-detailed-fashion-","dir":"Articles","previous_headings":"How to get started","what":"1.) Formulate the goal of your research project in a detailed fashion.","title":"Simulating Covid-19 Vaccine Data using a Discrete-Time Simulation","text":"haven’t done yet, now time. Try make goal explicit possible. help deciding aspects system important can safely ignored.","code":""},{"path":"https://robindenz1.github.io/simDAG/articles/v_covid_example.html","id":"build-a-theoretical-model-of-the-system-you-want-to-simulate-","dir":"Articles","previous_headings":"How to get started","what":"2.) Build a theoretical model of the system you want to simulate.","title":"Simulating Covid-19 Vaccine Data using a Discrete-Time Simulation","text":"entails reading relevant literature writing assumptions may already system. Perhaps (usually likely) researchers tried build simulation model system (similar system). great way encode causal assumptions system time-dependent DAG, discussed vignettes.","code":""},{"path":"https://robindenz1.github.io/simDAG/articles/v_covid_example.html","id":"identify-the-parts-of-the-system-that-you-are-most-interested-in-","dir":"Articles","previous_headings":"How to get started","what":"3.) Identify the parts of the system that you are most interested in.","title":"Simulating Covid-19 Vaccine Data using a Discrete-Time Simulation","text":"Real systems incredibly complex. simulation make simplifying assumptions. building moderately detailed version theoretical model, decide aspects interest research project aren’t.","code":""},{"path":"https://robindenz1.github.io/simDAG/articles/v_covid_example.html","id":"obtain-and-analyze-real-data-","dir":"Articles","previous_headings":"How to get started","what":"4.) Obtain and analyze real data.","title":"Simulating Covid-19 Vaccine Data using a Discrete-Time Simulation","text":"simulated data correspond real data, crucial base input model actual empirical data. Using empirical data, may able derive appropriate distributions root nodes appropriate functional forms relationship considered variables.","code":""},{"path":"https://robindenz1.github.io/simDAG/articles/v_covid_example.html","id":"simulate-data-for-t-0-if-needed-","dir":"Articles","previous_headings":"How to get started","what":"5.) Simulate data for t=0t = 0 (if needed).","title":"Simulating Covid-19 Vaccine Data using a Discrete-Time Simulation","text":"specified suitable distributions relationships, generate initial data used simulation process. important check data thoroughly, used basis subsequent steps simulation. sim_from_dag() function might helpful step.","code":""},{"path":"https://robindenz1.github.io/simDAG/articles/v_covid_example.html","id":"write-functions-for-each-time-varying-node-one-at-a-time-","dir":"Articles","previous_headings":"How to get started","what":"6.) Write functions for each time-varying node, one at a time.","title":"Simulating Covid-19 Vaccine Data using a Discrete-Time Simulation","text":"time-varying node requires user written function transforms data tt data t+1t + 1. might helpful add one time-varying node time proceeding step 7.) adding variables, possible.","code":""},{"path":"https://robindenz1.github.io/simDAG/articles/v_covid_example.html","id":"inspect-the-resulting-data-for-inconsistencies-","dir":"Articles","previous_headings":"How to get started","what":"7.) Inspect the resulting data for inconsistencies.","title":"Simulating Covid-19 Vaccine Data using a Discrete-Time Simulation","text":"Validating simulation code important ensure mistakes slipped . may done fitting models relying modeling assumptions generated data checking whether models produce expected results.","code":""},{"path":"https://robindenz1.github.io/simDAG/articles/v_covid_example.html","id":"our-research-goal-and-the-theoretical-model","dir":"Articles","previous_headings":"","what":"Our research goal and the theoretical model","title":"Simulating Covid-19 Vaccine Data using a Discrete-Time Simulation","text":"Since vignette mostly concerned practical implementation discrete-time simulation approach using R-package, spend much time first 4 steps process mentioned previous section. briefly present important points.","code":""},{"path":"https://robindenz1.github.io/simDAG/articles/v_covid_example.html","id":"research-goal","dir":"Articles","previous_headings":"Our research goal and the theoretical model","what":"Research goal","title":"Simulating Covid-19 Vaccine Data using a Discrete-Time Simulation","text":"actual research goal identify suitable data analysis strategy assessment Covid-19 vaccine side-effects particular real-life data set. decided simulate data close real data possible. Using data try different analysis strategies see one performed adequately. goal vignette use parts model showcase capabilities simDAG package. information actual simulation can found first related publication (Denz et al. 2023).","code":""},{"path":"https://robindenz1.github.io/simDAG/articles/v_covid_example.html","id":"theoretical-model","dir":"Articles","previous_headings":"Our research goal and the theoretical model","what":"Theoretical model","title":"Simulating Covid-19 Vaccine Data using a Discrete-Time Simulation","text":"seemingly endless amount literature describing models Covid-19 pandemic associated Covid-19 vaccines. Trying include relevant aspects unfeasible task. deliberating literature decided include key variables. make vignette readable limited variables include essential: vaccination: time person received first vaccine. covid: Whether Covid-19 infection occurred. sickness: Whether person developed sickness interest. assume three variables vary time cause .","code":""},{"path":"https://robindenz1.github.io/simDAG/articles/v_covid_example.html","id":"implementing-the-model","dir":"Articles","previous_headings":"","what":"Implementing the model","title":"Simulating Covid-19 Vaccine Data using a Discrete-Time Simulation","text":"Instead diving deep start trying include relevant variables relevant relationships , often better build simplified version first start adding stuff continue.","code":""},{"path":"https://robindenz1.github.io/simDAG/articles/v_covid_example.html","id":"part-1-adding-vaccination-covid-and-sickness","dir":"Articles","previous_headings":"Implementing the model","what":"Part 1: Adding vaccination, covid and sickness","title":"Simulating Covid-19 Vaccine Data using a Discrete-Time Simulation","text":"important variables us vaccination, covid-19 infection sickness. variables certain probability occurrence point time. occur, last duration (e.g. someone sick two weeks something similar). event , usually duration person “immune” receiving event . perfect case using time-dependent node type \"time_to_event\". start modeling every one variables completely independent using following DAG: DAG , supplied constant value prob_fun arguments, indicating regardless time variables, event constant probability occurring day. set event_duration vaccination 21, want model time vaccination risk adverse side-effect (e.g. sickness) higher usual later . setting immunity_duration vaccination Inf, currently allowing person get one vaccination entire time. sickness allowed occur directly .","code":"library(data.table) library(ggplot2) #> Error in get(paste0(generic, \".\", class), envir = get_method_env()) :  #>   object 'type_sum.accel' not found library(simDAG)  dag <- empty_dag() +   node_td(\"vaccination\", type=\"time_to_event\", prob_fun=0.001,           event_duration=21, immunity_duration=Inf) +   node_td(\"covid\", type=\"time_to_event\", prob_fun=0.001, event_duration=30,           immunity_duration=80) +   node_td(\"sickness\", type=\"time_to_event\", prob_fun=0.0001,           event_duration=2, immunity_duration=2)"},{"path":"https://robindenz1.github.io/simDAG/articles/v_covid_example.html","id":"part-2-adding-adverse-effects-of-vaccination-and-covid","dir":"Articles","previous_headings":"Implementing the model","what":"Part 2: Adding adverse effects of vaccination and covid","title":"Simulating Covid-19 Vaccine Data using a Discrete-Time Simulation","text":"can make data-generation process little interesting making vaccination covid effect probability developing sickness. simply raising probability occurrence sickness constant factor whenever either covid vaccination event currently happening. can done formulating appropriate prob_fun sickness node: works number exponent 1 , number exponent 0 one. vaccination_event covid_event columns always either TRUE (event currently happening) FALSE (event currently happening), interpreted 1 0 R. Let’s update DAG: Instead passing constant value prob_fun argument, now passing previously defined function. function base_p, rr_covid rr_vacc arguments without defaults, specify node_td call well. keep original base_p, set relative risks 3.5 3.24 respectively. Additionally, set vaccination_event covid_event columns parents now, used prob_sickness function.","code":"prob_sickness <- function(data, rr_covid, rr_vacc, base_p) {    # multiply base probability by relevant RRs   p <- base_p * rr_vacc^(data$vaccination_event) * rr_covid^(data$covid_event)    return(p) } dag <- empty_dag() +   node_td(\"vaccination\", type=\"time_to_event\", prob_fun=0.001,           event_duration=21, immunity_duration=Inf) +   node_td(\"covid\", type=\"time_to_event\", prob_fun=0.001, event_duration=30,           immunity_duration=80) +   node_td(\"sickness\", type=\"time_to_event\", prob_fun=prob_sickness,           parents=c(\"vaccination_event\", \"covid_event\"),           base_p=0.0001, rr_covid=3.5, rr_vacc=3.24,           event_duration=2, immunity_duration=2)"},{"path":"https://robindenz1.github.io/simDAG/articles/v_covid_example.html","id":"part-3-making-the-vaccine-useful","dir":"Articles","previous_headings":"Implementing the model","what":"Part 3: Making the vaccine useful","title":"Simulating Covid-19 Vaccine Data using a Discrete-Time Simulation","text":"far assumed covid infection probability unaffected whether person received vaccine . now change implementing time-window receiving vaccine person develop covid infection. , can done defining appropriate prob_fun function, time covid node: function use column vaccination_time_since_last, column can optionally created time--event nodes setting time_since_last TRUE. let’s update DAG accordingly: Instead just updating parents prob_fun arguments covid node, now also set time_since_last argument vaccination node TRUE well get required additional column. data-generation algorithm getting better now. still lot can .","code":"prob_covid <- function(data, base_p, vacc_duration) {      p <- fifelse(data$vaccination_time_since_last < vacc_duration,                0, base_p, na=base_p)   return(p) } dag <- empty_dag() +   node_td(\"vaccination\", type=\"time_to_event\", prob_fun=0.001,           event_duration=21, immunity_duration=Inf,           time_since_last=TRUE) +   node_td(\"covid\", type=\"time_to_event\", prob_fun=prob_covid,           parents=c(\"vaccination_time_since_last\"),           base_p=0.001, vacc_duration=80, event_duration=30,           immunity_duration=80) +   node_td(\"sickness\", type=\"time_to_event\", prob_fun=prob_sickness,           parents=c(\"vaccination_event\", \"covid_event\"),           base_p=0.0001, rr_covid=3.5, rr_vacc=3.24,           event_duration=2, immunity_duration=2)"},{"path":"https://robindenz1.github.io/simDAG/articles/v_covid_example.html","id":"part-4-sick-people-dont-get-vaccinated","dir":"Articles","previous_headings":"Implementing the model","what":"Part 4: Sick people don’t get vaccinated","title":"Simulating Covid-19 Vaccine Data using a Discrete-Time Simulation","text":"reality, little people currently experiencing Covid-19 infection went got vaccine. fact, absolutely discouraged doctors world-wide. add circumstance model, simply update probability receiving vaccination, defining appropriate prob_fun: Using function, probability getting vaccinated individual currently experiencing covid infection 0. Let’s update DAG one time include changes: simply changed prob_fun argument added correct parents appropriate node. final “DAG” looks like :  Note plot doesn’t look like classic DAG anymore, bi-directional arrow covid vaccination due time-dependent nature relationship.","code":"prob_vaccination <- function(data, base_p) {      p <- fifelse(data$covid_event, 0, base_p)      return(p) } dag <- empty_dag() +   node_td(\"vaccination\", type=\"time_to_event\",           prob_fun=prob_vaccination,           parents=c(\"covid_event\"), base_p=0.001,           event_duration=21, immunity_duration=Inf,           time_since_last=TRUE) +   node_td(\"covid\", type=\"time_to_event\", prob_fun=prob_covid,           parents=c(\"vaccination_time_since_last\"),           base_p=0.001, vacc_duration=80, event_duration=30,           immunity_duration=80) +   node_td(\"sickness\", type=\"time_to_event\", prob_fun=prob_sickness,           parents=c(\"vaccination_event\", \"covid_event\"),           base_p=0.0001, rr_covid=3.5, rr_vacc=3.24,           event_duration=2, immunity_duration=2) plot(dag, mark_td_nodes=FALSE) #> Loading required namespace: ggforce"},{"path":"https://robindenz1.github.io/simDAG/articles/v_covid_example.html","id":"generating-data-using-the-final-model","dir":"Articles","previous_headings":"Implementing the model","what":"Generating Data using the final model","title":"Simulating Covid-19 Vaccine Data using a Discrete-Time Simulation","text":"Suppose now pleased complexity data-generation algorithm want simulate data . can simply calling sim_discrete_time() function specified DAG: exemplary purposes, kind arbitrarily used 1000 individuals let simulation run 800 days. calling plot() method, get concise overview process simulated:  useful output resulting data can obtained using sim2data() function. example, transform output start-stop format: can seen, managed implement fairly complex data-generation mechanism using small function definitions lines code, allowing us generate complex dataset three interdependent time-varying variables minimal effort.","code":"set.seed(42) sim <- sim_discrete_time(dag, n_sim=1000, max_t=800) summary(sim) #> A simDT object with: #>   -  1000  observations #>   -  800  distinct points in time #>   -  3  time-varying variables in total #>   -  3  time_to_event nodes #>   -  0  competing_events nodes #> Only the last state of the simulation was saved. plot(sim, box_text_size=4) sim2data(sim, to=\"start_stop\") #>         .id start  stop vaccination  covid sickness #>       <int> <int> <num>      <lgcl> <lgcl>   <lgcl> #>    1:     1     1   178       FALSE  FALSE    FALSE #>    2:     1   179   199        TRUE  FALSE    FALSE #>    3:     1   200   800       FALSE  FALSE    FALSE #>    4:     2     1   501       FALSE  FALSE    FALSE #>    5:     2   502   531       FALSE   TRUE    FALSE #>   ---                                               #> 3466:  1000     1    47       FALSE  FALSE    FALSE #> 3467:  1000    48    49       FALSE  FALSE     TRUE #> 3468:  1000    50   131       FALSE  FALSE    FALSE #> 3469:  1000   132   152        TRUE  FALSE    FALSE #> 3470:  1000   153   800       FALSE  FALSE    FALSE"},{"path":"https://robindenz1.github.io/simDAG/articles/v_covid_example.html","id":"going-even-further","dir":"Articles","previous_headings":"Implementing the model","what":"Going even further","title":"Simulating Covid-19 Vaccine Data using a Discrete-Time Simulation","text":"need stop . make simulation model even complex implementing following things: Adding time-dependent base-probabilities vaccination, covid sickness Adding different kinds vaccinations, perhaps different effects covid /sickness Adding time-fixed variables sex effect variables Allowing multiple vaccinations Changing constant raising probabilities form relative risk realistic non-linear time-dependent relative risk course many possible extensions, can implemented augmenting respective prob_fun arguments updating dag accordingly. fact, real monte-carlo simulation conducted, exactly . used empirical data model time-dependent base-probabilities . much complexity really need completely . hope simDAG package can help whatever need.","code":""},{"path":"https://robindenz1.github.io/simDAG/articles/v_covid_example.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Simulating Covid-19 Vaccine Data using a Discrete-Time Simulation","text":"Banks, Jerry, John S. Carson II, Barry L. Nelson, David M. Nicol (2014). Discrete-Event System Simulation. Vol. 5. Edinburgh Gate: Pearson Education Limited. Denz, Robin, Katharina Meiszl, Peter Ihle, Doris F. Oberle, Ursula Drechsel-Bäuerle, Katrin Scholz, Ingo Meyer Nina Timmesfeld (2023). “Impact Record-Linkage Errors Covid-19 Vaccine-Safety Analyses using German Health-Care Data: Simulation Study”. : arXiv:2310.15016","code":""},{"path":"https://robindenz1.github.io/simDAG/articles/v_sim_discrete_time.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Simulating Data using a Discrete-Time Approach","text":"small vignette, introduce sim_discrete_time() function, can used generate arbitrarily complex longitudinal data discrete points time. Just sim_from_dag() function contained package, allows mixture continuous, binary, categorical, count, time--event data. main advantage sim_discrete_time() function naturally generates longitudinal data without need define node variable point time. also makes generation complex time--event data lot easier. Features time-dependent effects, time-dependent covariates, form censoring, recurrent-events competing events may included straightforward fashion.","code":""},{"path":"https://robindenz1.github.io/simDAG/articles/v_sim_discrete_time.html","id":"what-is-discrete-time-simulation-and-why-use-it","dir":"Articles","previous_headings":"","what":"What is Discrete-Time Simulation and Why Use it?","title":"Simulating Data using a Discrete-Time Approach","text":"discrete-time simulation (DTS) consists two steps. First, bunch entities (usually necessarily people) created. Afterwards, change states entities time simulated increasing simulation time iteratively discrete steps, updating states step (Tang et al. 2020). example, suppose entities people interested states age death. Every time simulation time increases, age person increases , raising probability death. every step check person still alive. die, state death changes 0 1. everyone dead, stop simulation. schematic flow DTS shown figure . generalized flow-chart discrete-time simulation approach sim_discrete_time() directly implements workflow. data set t=0t = 0 either simulated using sim_from_dag() function supplied directly user (using t0_data argument). data set updated according time-dependent nodes added dag using node_td() calls. give short example works practice. realistic (therefore complex) example can found different vignette. DTS can seen special case simulation modeling. closely related dynamic microsimulation (Spooner et al. 2021), discrete-event simulation (Banks 2014) agent-based modeling (Ugur & Saka 2006). , requires lot input users. general, sim_discrete_time() function “--shelves” function can used “-” simulate data. cases, user needs write functions actually use function effectively. price one pay nearly unlimited flexibility simulation methodology. Nevertheless, may valid simulation strategy user interested highly complex longitudinal time--event data.","code":""},{"path":"https://robindenz1.github.io/simDAG/articles/v_sim_discrete_time.html","id":"defining-the-dag","dir":"Articles","previous_headings":"","what":"Defining the DAG","title":"Simulating Data using a Discrete-Time Approach","text":"Similar sim_from_dag() function, user needs specify nodes underlying causal DAG use function. variables DTS can categorized three categories: t0_root nodes, t0_child_nodes tx_nodes. t0_root_nodes: Variables completely independent variables generated called t0_root_nodes. something like sex geographic entities. generally simply sampled previously defined distribution, also sampled directly existing data. prefix t0_ indicates variables created beginning. t0_child_nodes: Much like t0_root_nodes, t0_child_nodes also variables generated beginning discrete-time simulation. difference , variables simply sampled defined distribution. Instead causally depend way variables. variables can root nodes child nodes, long underlying causal structure can described directed acyclic graph. tx_nodes: type node complex reason use DTS. Variables category updated step time simulation process. updates can fairly easy, increasing age person one time unit step, can complex. example, want model occurrence kind time-dependent-event, can generate probability occurrence step depending variables simulation model past states variable . t0_root_nodes t0_child_nodes arguments specified using DAG object calls node() function usual using sim_from_dag() function. fact, simply passed hood. role data generation process obtain initial data set need t=0t = 0. equivalent call sim_from_dag() function manually pass output t0_data argument. therefore won’t go detail . information correctly specify DAG can found documentation sim_from_dag() node() functions associated vignette.","code":""},{"path":"https://robindenz1.github.io/simDAG/articles/v_sim_discrete_time.html","id":"a-simple-example---one-terminal-event","dir":"Articles","previous_headings":"","what":"A Simple Example - One Terminal Event","title":"Simulating Data using a Discrete-Time Approach","text":"Let us consider simple example first. Suppose want generate data according following causal DAG: small DAG time-varying age , sex time-invariant variable, whereas age death . Suppose tick simulation corresponds duration one year. , naturally, people age one year every simulation tick. assume sex age direct causal effect probability death, regardless time. people dead, stay dead (reincarnation allowed). want use structure sim_discrete_time() function, first generate initial dataset state population t=0t = 0 described . first specifying t0_root_nodes follows: assume age normally distributed equal numbers sex. information enough specify data set t=0t = 0. Now need add additional time-dependent nodes using node_td() function ready. First, define function increases age individuals 1 step: Next, need define function return probability death every individual time tt, given current age sex. use logistic regression model, make explicit exemplary reasons: Now can add nodes DAG follows: simply pass node_advance_age() function type argument age node. death time--event node, ’s event generated probability step time. probability, defined , determined prob_death function defined earlier. set event_duration Inf make permanent event (dead, going back). visualize resulting DAG, can use associated plot() method:  finally generate desired data, simply call sim_discrete_time() function: setting max_t=50, letting simulation run 50 (simulated) years. results look like : easy see people died course 50 years looking death_event column. death_time column records time person died. want graphically display flow diagram data-generation mechanism, may use plot() method associated output sim_discrete_time() function like :  particular example simulated much easier fashion, without relying discrete-time approach, age increases linearly model death exactly regardless time. DTS useful truly complex data structures required. extend simple example little bit, still keep relatively simple.","code":"library(data.table) library(ggplot2) #> Error in get(paste0(generic, \".\", class), envir = get_method_env()) :  #>   object 'type_sum.accel' not found library(simDAG)  dag <- empty_dag() +   node(\"age\", type=\"rnorm\", mean=30, sd=5) +   node(\"sex\", type=\"rbernoulli\", p=0.5) node_advance_age <- function(data) {   return(data$age + 1) } prob_death <- function(data) {   score <- -10 + 0.15 * data$age + 0.25 * data$sex   prob <- 1/(1 + exp(-score))   return(prob) } dag <- dag +   node_td(\"age\", type=\"advance_age\", parents=\"age\") +   node_td(\"death\", type=\"time_to_event\", parents=c(\"age\", \"sex\"),           prob_fun=prob_death, event_duration=Inf, save_past_events=TRUE,           check_inputs=FALSE) plot(dag) #> Loading required namespace: ggforce set.seed(43) sim_dat <- sim_discrete_time(n_sim=10, dag=dag, max_t=50, check_inputs=FALSE) head(sim_dat$data) #>         age    sex death_event death_time   .id #>       <num> <lgcl>      <lgcl>      <int> <int> #> 1: 79.81243   TRUE        TRUE         27     1 #> 2: 72.12698   TRUE        TRUE         13     2 #> 3: 77.57016  FALSE        TRUE         31     3 #> 4: 82.32593  FALSE        TRUE         16     4 #> 5: 75.47951  FALSE        TRUE         17     5 #> 6: 78.61284  FALSE        TRUE          9     6 plot(sim_dat)"},{"path":"https://robindenz1.github.io/simDAG/articles/v_sim_discrete_time.html","id":"extending-the-simple-example---recurrent-events","dir":"Articles","previous_headings":"","what":"Extending the Simple Example - Recurrent Events","title":"Simulating Data using a Discrete-Time Approach","text":"Suppose event interest wasn’t death, cardiovascular event (cve). case simplicity assume causal structure causal coefficients still apply, event now longer terminal may re-occur arbitrary number times. First, let’s redefine nodes get new name right: also redefine function generates required event probabilities: Now, case change arguments node_time_to_event() function: Apart changing node name, also changed event_duration parameter 1, meaning cardiovascular event lasts 1 year. also set save_past_events TRUE order store possible recurrent events. Now call sim_discrete_time() function : case, data little complex. time t=50t = 50, one person currently experiencing cardiovascular event, cve_event column FALSE almost rows cve_time column NA almost rows. need transform output data different formats using sim2data() function gain information. example, can transform start-stop format: format, can clearly see events occurred. type format usually used fit statistical models time--event data (although fitting , might want take look target_event, overlap keep_only_first arguments sim2data()). Another possibility transform long-format: may also useful fit discrete-time survival models. simulation done assumes time number previous events effect events patient. assumption may relaxed explicitly formulating prob_cve function way uses cve_time column change probability events. -depth example includes considerations like can found third vignette package.","code":"dag <- empty_dag() +   node(\"age\", type=\"rnorm\", mean=30, sd=5) +   node(\"sex\", type=\"rbernoulli\", p=0.5) prob_cve <- function(data) {   score <- -15 + 0.15 * data$age + 0.25 * data$sex   prob <- 1/(1 + exp(-score))   return(prob) } dag <- dag +   node_td(\"age\", type=\"advance_age\", parents=c(\"age\")) +   node_td(\"cve\", type=\"time_to_event\", parents=c(\"age\", \"sex\"),           prob_fun=prob_cve, event_duration=1, save_past_events=TRUE) sim_dat <- sim_discrete_time(n_sim=10, dag=dag, max_t=50) head(sim_dat$data) #>         age    sex cve_event cve_time   .id #>       <num> <lgcl>    <lgcl>    <int> <int> #> 1: 82.67833   TRUE     FALSE       NA     1 #> 2: 90.30020  FALSE      TRUE       50     2 #> 3: 88.25512   TRUE     FALSE       NA     3 #> 4: 90.28344  FALSE     FALSE       NA     4 #> 5: 79.90450   TRUE     FALSE       NA     5 #> 6: 81.70720   TRUE     FALSE       NA     6 d_start_stop <- sim2data(sim_dat, to=\"start_stop\") head(d_start_stop) #>      .id start  stop    cve      age    sex #>    <int> <int> <num> <lgcl>    <num> <lgcl> #> 1:     1     1    50  FALSE 82.67833   TRUE #> 2:     2     1    43  FALSE 90.30020  FALSE #> 3:     2    44    44   TRUE 90.30020  FALSE #> 4:     2    45    49  FALSE 90.30020  FALSE #> 5:     2    50    50   TRUE 90.30020  FALSE #> 6:     3     1    50  FALSE 88.25512   TRUE d_long <- sim2data(sim_dat, to=\"long\") head(d_long) #> Key: <.id, .time> #>      .id .time    cve      age    sex #>    <int> <int> <lgcl>    <num> <lgcl> #> 1:     1     1  FALSE 82.67833   TRUE #> 2:     1     2  FALSE 82.67833   TRUE #> 3:     1     3  FALSE 82.67833   TRUE #> 4:     1     4  FALSE 82.67833   TRUE #> 5:     1     5  FALSE 82.67833   TRUE #> 6:     1     6  FALSE 82.67833   TRUE"},{"path":"https://robindenz1.github.io/simDAG/articles/v_sim_discrete_time.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Simulating Data using a Discrete-Time Approach","text":"Banks, Jerry, John S. Carson II, Barry L. Nelson, David M. Nicol (2014). Discrete-Event System Simulation. Vol. 5. Edinburgh Gate: Pearson Education Limited. Bilge, Ugur Osman Saka (2006). “Agent Based Simulations Healthcare”. : Ubiquity: Technologies Better Health Aging Societies - Proceedings MIE2006. Ed. Arie Hassman, Reinhold Haux, Johan van der Lei, Etienne De Clercq, Francis H. Roger France. IOS Press. Spooner, Fiona, Jesse F. Abrams, Karyn Morrissey, Gavin Shaddick, Michael Batty, Richard Milton, Adam Dennett, Nik Lomax, Nick Malleson, Natalie Nelissen, Alex Coleman, Jamil Nur, Ying Jin, Rory Greig, Charlie Shenton, Mark Birkin (2021). “Dynamic Microsimulation Model Epidemics”. : Social Science & Medicine 291.114461. Tang, Jiangjun, George Leu, und Hussein . Abbass. 2020. Simulation Computational Red Teaming Problem Solving. Hoboken: IEEE Press.","code":""},{"path":"https://robindenz1.github.io/simDAG/articles/v_sim_from_dag.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Simulating Data from a known DAG","text":"small vignette, introduce sim_from_dag() function, can used simulate complex data arbitrary causal directed acyclic graphs (DAGs). simulated data may include continuous, binary, categorical, count time--event variables. function useful DAG static, meaning time-varying variables. theoretically possible use function simulate data DAGs time structure well, difficulties associated discussed later.","code":""},{"path":"https://robindenz1.github.io/simDAG/articles/v_sim_from_dag.html","id":"what-are-causal-dags-and-why-use-them","dir":"Articles","previous_headings":"","what":"What are causal DAGs and why use them?","title":"Simulating Data from a known DAG","text":"causal DAG DAG nodes correspond variables directed edges correspond direct causal relationships variables. direct edge node AA node BB implies direct causal effect AA BB. hand, edge node AA node BB, direct causal relationship variables. Using DAG way makes easy encode causal structure given system, useful causal inference. general idea centerpiece structural approach causality developed Pearl (2002) Spirtes et al. (1993). strongly encourage reader make familiar literature moving . simple generate data defined causal DAG. see first need introduce concept root nodes child nodes. root node node DAG edges pointing (incoming arrows). child node hand node least one incoming edge. words, root nodes direct causes child nodes . Every node pointing another node considered parent child node. example, consider DAG figure 1. small DAG four nodes Nodes AA BB root nodes directed edges pointing . Nodes CC DD hand child nodes. parents node CC AA BB nodes directed edge towards CC. Note node BB parent node DD edge BB DD. name implies, DAGs cycles. Therefore every DAG least one root node. Generating data nodes first step simulate data whole DAG. Since root nodes parents, can simply generate random data using appropriate distribution. data root nodes, can generate directly connected child nodes next function root nodes (perhaps additional random error). direct child nodes used input next child nodes line . continues every node generated. Since every DAG can topologically sorted (Chickering 1995), always work. need specify DAG functional relationship node parents.","code":""},{"path":"https://robindenz1.github.io/simDAG/articles/v_sim_from_dag.html","id":"defining-the-dag","dir":"Articles","previous_headings":"","what":"Defining the DAG","title":"Simulating Data from a known DAG","text":"sim_from_dag() function uses method described , requires information causal structure exact form relationship child nodes parents. information included dag argument, DAG object created using empty_dag() function grown using node() calls described . can done completely manually (usual strategy conducting simulation studies) (partially) using existing data (may useful interest getting toy data set resembling real data closely possible). Regardless strategy want use, first initialize empty DAG object like : Afterwards can add unlimited amount root nodes child nodes . Multiple different types implemented.","code":"library(data.table) library(ggplot2) #> Error in get(paste0(generic, \".\", class), envir = get_method_env()) :  #>   object 'type_sum.accel' not found library(simDAG)  dag <- empty_dag()"},{"path":"https://robindenz1.github.io/simDAG/articles/v_sim_from_dag.html","id":"root-node-types","dir":"Articles","previous_headings":"Defining the DAG","what":"Root node types","title":"Simulating Data from a known DAG","text":"values root_nodes simply sampled defined distributions. Therefore, function generates random draws distribution may used . Popular alternatives continuous data normal-, beta-, gamma-distributions implemented base R inside rnorm(), rbeta() rgamma() functions. binary categorical data use custom functions rbernoulli() rcategorical() instead.","code":""},{"path":"https://robindenz1.github.io/simDAG/articles/v_sim_from_dag.html","id":"child-node-types","dir":"Articles","previous_headings":"Defining the DAG","what":"Child node types","title":"Simulating Data from a known DAG","text":"simDAG package implements following types child_nodes directly: node_gaussian: node based linear regression (continuous data). node_binomial: node based logistic regression (binary data). node_multinomial: node based multinomial logistic regression (categorical data). node_poisson: node based poisson regression (count data). node_negative_binomial: node based negative binomial regression (count data). node_cox: node based cox regression (time--event data). node_conditional_prob: node based conditional probabilities (binary / categorical data). node_conditional_distr: node based conditional distributions (data type). node_identity: node just R expression nodes (data type). nodes documentation page containing detailed description data generated . Although collection nodes covers lot data types, still somewhat limited collection. , example, wanted add child node normally distributed also truncated specific values, using just offered node functions. reason, sim_from_dag() function also allows user use custom functions nodes, makes possible model kind data kind relationship.","code":""},{"path":"https://robindenz1.github.io/simDAG/articles/v_sim_from_dag.html","id":"defining-nodes-manually","dir":"Articles","previous_headings":"Defining the DAG","what":"Defining nodes manually","title":"Simulating Data from a known DAG","text":"Suppose node AA figure stands age, BB stands sex, CC stands Body-Mass-Index (BMI) DD stands death. start defining root nodes look like. use following code define age sex: nodes defined calling node() function adding output dag object using simple +. syntax heavily inspired simCausal R-package (Sofrygin et al. 2017). , assume age continuous normally distributed variable mean 50 standard deviation 4 (real simulation study probably use truncated normal distribution ensure age negative). can done setting dist parameter \"rnorm\", standard R function generating random values normal distribution. arguments listed params parameter passed function. Similarly, define sex Bernoulli distributed variable (taking values 0/1). assume even gender distribution setting p = 0.5. Next, define relationship child nodes parents look like. may use following code: Since bmi node dependent sex age, list nodes parents bmi. specify bmi continuous variable modeled using linear regression setting type=\"gaussian\". concrete regression equation defined use intercept, betas error arguments. specification bmi node corresponds following equation: bmi=12+sex⋅1.1+age⋅0.4+N(0,2), bmi = 12 + sex \\cdot 1.1 + age \\cdot 0.4 + N(0, 2), N(0,2)N(0, 2) indicates error term modelled normally distributed variable mean 0 standard deviation 2. Since death two states (alive vs. dead), use logistic regression model instead. can easily setting type=\"binomial\". rest syntax essentially stays . regression equation death described code : logit(death)=−15+age⋅0.1+bmi⋅0.3. logit(death) = -15 + age \\cdot 0.1 + bmi \\cdot 0.3. check whether got causal relationships right, can call plot() function DAG object. output look similar hand-drawn DAG .  can also directly print underlying structural equations using summary() function: correct. can now use DAG object generate random data using sim_from_dag() function: Setting seed random number generator necessary obtain replicable results. data generated using code looks like : Binary variables sex death default treated logical variables, memory efficient way store . can now check distributions relationships dataset confirm indeed corresponds specified causal DAG. Starting root nodes:  seems correct. Note finite dataset, means results never exactly match theoretical distributions. ’s definitely close enough . check child nodes modeled correctly, simply fit corresponding models using glm() function: Evidently, coefficients match causal coefficients specified earlier.","code":"dag <- dag +    node(\"age\", type=\"rnorm\", mean=50, sd=4) +   node(\"sex\", type=\"rbernoulli\", p=0.5) dag <- dag +   node(\"bmi\", type=\"gaussian\", parents=c(\"sex\", \"age\"), betas=c(1.1, 0.4),        intercept=12, error=2) +   node(\"death\", type=\"binomial\", parents=c(\"age\", \"bmi\"), betas=c(0.1, 0.3),        intercept=-15) plot(dag) #> Loading required namespace: ggforce summary(dag) #> A DAG object using the following structural equations: #>  #>   age ~ N(50, 4) #>   sex ~ Bernoulli(0.5) #>   bmi ~ N(12 + 1.1*sex + 0.4*age, 2) #> death ~ Bernoulli(logit(-15 + 0.1*age + 0.3*bmi)) set.seed(42) sim_dat <- sim_from_dag(dag=dag, n_sim=10000) head(sim_dat, 5) #>         age    sex      bmi  death #>       <num> <lgcl>    <num> <lgcl> #> 1: 55.48383   TRUE 33.25311  FALSE #> 2: 47.74121  FALSE 29.58815  FALSE #> 3: 51.45251  FALSE 30.12967  FALSE #> 4: 52.53145   TRUE 32.07877  FALSE #> 5: 51.61707  FALSE 36.09082   TRUE hist(sim_dat$age) table(sim_dat$sex) #>  #> FALSE  TRUE  #>  5051  4949 mod_bmi <- glm(bmi ~ age + sex, data=sim_dat, family=\"gaussian\") summary(mod_bmi) #>  #> Call: #> glm(formula = bmi ~ age + sex, family = \"gaussian\", data = sim_dat) #>  #> Coefficients: #>              Estimate Std. Error t value Pr(>|t|)     #> (Intercept) 12.184254   0.253188   48.12   <2e-16 *** #> age          0.396020   0.005039   78.58   <2e-16 *** #> sexTRUE      1.177159   0.040563   29.02   <2e-16 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>  #> (Dispersion parameter for gaussian family taken to be 4.112615) #>  #>     Null deviance: 70134  on 9999  degrees of freedom #> Residual deviance: 41114  on 9997  degrees of freedom #> AIC: 42524 #>  #> Number of Fisher Scoring iterations: 2 mod_death <- glm(death ~ age + bmi, data=sim_dat, family=\"binomial\") summary(mod_death) #>  #> Call: #> glm(formula = death ~ age + bmi, family = \"binomial\", data = sim_dat) #>  #> Coefficients: #>               Estimate Std. Error z value Pr(>|z|)     #> (Intercept) -14.319144   0.371511  -38.54   <2e-16 *** #> age           0.093229   0.007057   13.21   <2e-16 *** #> bmi           0.289714   0.011331   25.57   <2e-16 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>  #> (Dispersion parameter for binomial family taken to be 1) #>  #>     Null deviance: 13773  on 9999  degrees of freedom #> Residual deviance: 11805  on 9997  degrees of freedom #> AIC: 11811 #>  #> Number of Fisher Scoring iterations: 3"},{"path":"https://robindenz1.github.io/simDAG/articles/v_sim_from_dag.html","id":"defining-nodes-using-existing-data","dir":"Articles","previous_headings":"Defining the DAG","what":"Defining nodes using existing data","title":"Simulating Data from a known DAG","text":"data resemble specific real data set, makes sense base values causal coefficients specific data set. can done fitting single model child node, extracting estimated coefficients fitted models putting appropriate DAG object. assumed DAG big, can time-extensive task. dag_from_data() function automates process. function takes node list containing minimal information causal structure node type outputs fully specified DAG object. example, lets assume data just generated (sim_dat) data set interest. Let us also assume know true underlying causal diagram rough idea nature relationship nodes (e.g. know can reasonably guess node type). Now create partially specified DAG accordance assumptions first: looks lot like code used , except explicitly defining actual beta coefficients. define causal structure node types. Now can call dag_from_data() function: returns object includes fully specified DAG, can used directly sim_from_dag() function: dag_from_data() function essentially just fits corresponding models one one node extracts relevant data models fill gaps empty nodes. set return_models TRUE dag_from_data() function call , can actually see used exact models fit earlier check simulation valid.","code":"dag <- empty_dag() +   node(\"age\", type=\"rnorm\") +   node(\"sex\", type=\"rbernoulli\") +   node(\"bmi\", type=\"gaussian\", parents=c(\"sex\", \"age\")) +   node(\"death\", type=\"binomial\", parents=c(\"age\", \"bmi\")) est_dag <- dag_from_data(dag=dag, data=sim_dat) sim_dat2 <- sim_from_dag(dag=est_dag$dag, n_sim=10000)"},{"path":"https://robindenz1.github.io/simDAG/articles/v_sim_from_dag.html","id":"time-varying-covariates","dir":"Articles","previous_headings":"","what":"Time-varying covariates","title":"Simulating Data from a known DAG","text":"real data sets include time-varying covariates, e.g. variables measured multiple points time subject changes. possible generate type data using sim_from_dag() function well. need define appropriate DAG directly specifies variables change time. example, can extend simple DAG include dimension time: small DAG four nodes , nodes AA BB time-constant variables causal effect initial state CC DD, nodes CC DD change time interdependently. want simulate data DAG looks like using sim_from_dag() function, add node every point time want consider. quickly go somewhat simpler example, considering 2 points time. define nodes following way: example, bmi t=1t = 1 function sex age, bmi t=2t = 2 function previous bmi. death node determined initial age time-varying bmi. surely realistic example. meant show sim_from_dag() function may used incorporate time-dependent covariates. many points time considered complex time-dependent structures may easily described using DAG like one , sim_discrete_time() function also included package may used instead.","code":"dag <- empty_dag() +   node(\"age\", type=\"rnorm\", mean=50, sd=4) +   node(\"sex\", type=\"rbernoulli\", p=0.5) +   node(\"bmi_t1\", type=\"gaussian\", betas=c(1.1, 0.4), parents=c(\"sex\", \"age\"),        intercept=12, error=2) +   node(\"death_t1\", type=\"binomial\", parents=c(\"age\", \"sex\", \"bmi_t1\"),        betas=c(0.1, 0.3, 0.1), intercept=-15) +   node(\"bmi_t2\", type=\"gaussian\", parents=\"bmi_t1\", betas=c(1.1), intercept=0,        error=2) +   node(\"death_t2\", type=\"binomial\", betas=c(0.1, 0.3),        parents=c(\"age\", \"bmi_t2\"), intercept=-15)  sim_dat <- sim_from_dag(dag=dag, n_sim=10000)"},{"path":"https://robindenz1.github.io/simDAG/articles/v_sim_from_dag.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Simulating Data from a known DAG","text":"Judea Pearl (2009). Causality: Models, Reasoning Inference. 2nd ed. Cambridge: Cambridge University Press Peter Spirtes, Clark Glymour, Richard Scheines (2000) Causation, Prediction, Search. 2nd ed. MIT Press, Cambridge Chickering, D.M. (1995). transformational characterization equivalent Bayesian network structures. Proceedings 11th Conference Uncertainty Artificial Intelligence, Montreal, Canada, 87-98. Oleg Sofrygin, Mark J. van der Laan, Romain Neugebauer (2017). simcausal R Package: Conducting Transparent Reproducible Simulation Studies Causal Effect Estimation Complex Longitudinal Data. : Journal Statistical Software. 81.2, pp. 1-47","code":""},{"path":"https://robindenz1.github.io/simDAG/articles/v_using_formulas.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Specifying Formulas in a DAG","text":"small vignette, give detailed examples best use formula argument node() node_td() functions. argument allows users directly specify full structural equation used generate respective node clear easy way, directly rely parents, betas associated arguments. Note formula argument may used certain node types, mentioned documentation.","code":""},{"path":"https://robindenz1.github.io/simDAG/articles/v_using_formulas.html","id":"a-simple-example","dir":"Articles","previous_headings":"","what":"A simple example","title":"Specifying Formulas in a DAG","text":"start simple example. Suppose want generate data simple DAG time-varying variables. Consider following DAG: DAG contains three root nodes different types. AA normally distributed, BB Bernoulli distributed CC simple categorical variable levels “low”, “medium” “high”. generate data DAG alone, look like : Suppose now want generate additional child node called DD based linear regression model form: D∼−8+⋅0.4+B⋅−2+N(0,1.5).D \\sim -8 + \\cdot 0.4 + B \\cdot -2 + N(0, 1.5). using node() function, supplying appropriate values parents, betas, intercept error arguments. following code used: work just fine, may little cumbersome specify DAG way. Since want use linear regression model, instead use formula argument like : Given random number generator seed, output produced DAGs, shown : Formulas always start ~ sign nothing else left hand side. parts formula connected + signs, never - signs. name respective variable always connected associated coefficient * sign. matter whether name term coefficient go first, consistent formula. example, ~ 1 + *2 + B*3 works, ~ 1 + 2*+ 3*B also works, ~ 1 + 2*+ B*2 produce error. formula may also supplied string produce output. Apart easier read, also allows user lot options. use formulas possible specify nodes categorical parents. also possible include order interaction effects cubic terms using formulas, shown .","code":"library(simDAG)  dag <- empty_dag() +   node(\"A\", type=\"rnorm\", mean=0, sd=1) +   node(\"B\", type=\"rbernoulli\", p=0.5, output=\"numeric\") +   node(\"C\", type=\"rcategorical\", probs=c(0.3, 0.2, 0.5),        output=\"factor\", labels=c(\"low\", \"medium\", \"high\")) set.seed(23143)  dat <- sim_from_dag(dag, n_sim=10) head(dat) #>             A     B      C #>         <num> <num> <fctr> #> 1: -0.8041685     0    low #> 2:  1.3390885     0 medium #> 3:  0.9455804     0   high #> 4: -2.3437852     1    low #> 5: -0.9045554     1 medium #> 6:  0.8532361     1 medium dag_without_formula <- dag +   node(\"D\", type=\"gaussian\", parents=c(\"A\", \"B\"), betas=c(0.4, -2),        intercept=-8, error=1.5) dag_with_formula <- dag +   node(\"D\", type=\"gaussian\", formula= ~ -8 + A*0.4 + B*-2, error=1.5) set.seed(34) dat1 <- sim_from_dag(dag_without_formula, n_sim=100)  set.seed(34) dat2 <- sim_from_dag(dag_with_formula, n_sim=100)  all.equal(dat1, dat2) #> [1] TRUE"},{"path":"https://robindenz1.github.io/simDAG/articles/v_using_formulas.html","id":"using-a-categorical-parent-variable","dir":"Articles","previous_headings":"","what":"Using a Categorical Parent Variable","title":"Specifying Formulas in a DAG","text":"Suppose DD additionally depend CC, categorical variable. example, suppose regression model want generate data : D∼−8+⋅0.4+B⋅−2+Cmedium⋅−1+Chigh⋅−3+N(0,1.5).D \\sim -8 + \\cdot 0.4 + B \\cdot -2 + Cmedium \\cdot -1 + Chigh \\cdot -3 + N(0, 1.5). model, “low” category used reference category. want , using simple parents, betas, intercept approach longer works. use formula. Fortunately, really simple using following code: Essentially, use name categorical variable immediately followed category name. Note different reference category used, user needs re-define factor levels categorical variable accordingly first. Note also defined parents argument case. strictly necessary generate data case, recommended whenever categorical variables used formula two reasons: 1.) parents specified, sim_from_dag() function know CC parent DD. sort_dag=TRUE /nodes specified correctly topologically sorted order, may lead errors trying generate data. 2.) parents specified, functions take DAG objects input (plot.DAG() function) may produce incorrect output, won’t know CC parent DD.","code":"dag2 <- dag +   node(\"D\", type=\"gaussian\", error=1.5,        formula=~ -8 + A*0.4 + B*-2 + Cmedium*-1 + Chigh*-3,        parents=c(\"A\", \"B\", \"C\"))"},{"path":"https://robindenz1.github.io/simDAG/articles/v_using_formulas.html","id":"using-interaction-effects","dir":"Articles","previous_headings":"","what":"Using Interaction Effects","title":"Specifying Formulas in a DAG","text":"Interactions sort may also added DAG. Suppose want generate data following regression model: D∼−8+⋅0.4+B⋅−2+*B⋅−5+N(0,1.5),D \\sim -8 + \\cdot 0.4 + B \\cdot -2 + *B \\cdot -5 + N(0, 1.5), *BA*B indicates interaction AA BB. can specified formula argument using : sign: Since AA BB coded numeric variables , works fine. instead want include interaction includes categorical variable, use name respective category appended . example, following DAG includes interaction AA CC: Higher order interactions may specified exactly way, just using : symbols. may always obvious order variables interaction need specified. “wrong” order used, sim_from_dag() function return helpful error message explaining ones used instead. example, used “Cmedium:” instead “:Cmedium”, work internally latter recognized valid column. Note CC categorical, also specified parents argument just safe.","code":"dag3 <- dag +   node(\"D\", type=\"gaussian\", formula= ~ -8 + A*0.4 + B*-2 + A:B*-5, error=1.5) dag4 <- dag +   node(\"D\", type=\"gaussian\", error=1.5,        formula=~ -8 + A*0.4 + B*-2 + Cmedium*-1 + Chigh*-3 + A:Cmedium*0.3 +           A:Chigh*10,        parents=c(\"A\", \"B\", \"C\"))"},{"path":"https://robindenz1.github.io/simDAG/articles/v_using_formulas.html","id":"using-cubic-terms","dir":"Articles","previous_headings":"","what":"Using Cubic Terms","title":"Specifying Formulas in a DAG","text":"Sometimes also want include non-linear relationships continuous variable outcome data generation process. can done including cubic terms variable formula. Suppose regression model want use following form: D∼−8+⋅0.4+A2⋅0.02+B⋅−2+N(0,1.5).D \\sim -8 + \\cdot 0.4 + ^2 \\cdot 0.02 + B \\cdot -2 + N(0, 1.5). following code may used define node: Users may course use many cubic terms like.","code":"dag_with_formula <- dag +   node(\"D\", type=\"gaussian\", formula= ~ -8 + A*0.4 + I(A^2)*0.02 + B*-2,        error=1.5)"},{"path":"https://robindenz1.github.io/simDAG/articles/v_using_formulas.html","id":"using-functions-in-formula","dir":"Articles","previous_headings":"","what":"Using Functions in formula","title":"Specifying Formulas in a DAG","text":"also direct support including functions formula well. example, allowed call function beta coefficients, useful specify betas different scale (example using Odds-Ratios instead betas). example: valid syntax. function can used place log(), long single function called beta-coefficient. also possible use functions variables . However, required wrap () call. example, using something like ~ -3 + log()*0.5 + B*0.2 work, ~ -3 + (log())*0.5 + B*0.2 valid syntax.","code":"dag_with_fun <- dag +   node(\"D\", type=\"binomial\", formula= ~ -3 + A*log(0.5) + B*0.2)"},{"path":"https://robindenz1.github.io/simDAG/articles/v_using_formulas.html","id":"using-special-characters-in-formula","dir":"Articles","previous_headings":"","what":"Using Special Characters in formula","title":"Specifying Formulas in a DAG","text":"Although recommended, possible use variable names containing special characters formula, escaping using usual R syntax. example, user wanted use -var variable name use variable parent node formula, done using following code: , however, three special characters may used formula: spaces, + *. Errors may produced using characters variable names. best avoid special characters though, just safe.","code":"dag_with_fun <- dag +   node(\"this-var\", type=\"binomial\", formula= ~ -3 + A*log(0.5) + B*0.2) +   node(\"D\", type=\"binomial\", formula= ~ 5 + `this-var`*0.3)"},{"path":"https://robindenz1.github.io/simDAG/articles/v_using_formulas.html","id":"using-external-coefficients-advanced-usage","dir":"Articles","previous_headings":"","what":"Using External Coefficients (Advanced Usage)","title":"Specifying Formulas in a DAG","text":"Sometimes may useful define causal coefficients external variables, example writing function creates DAG objects set coefficients. supported use eval() function well. example: valid syntax. Note works variable wrapped eval() function call defined environment DAG object created. case, weird error messages may produced, depending code used.","code":"beta_coef <- log(0.5)  dag_with_external <- dag +   node(\"D\", type=\"binomial\", formula= ~ -3 + A*eval(beta_coef) + B*0.2)"},{"path":"https://robindenz1.github.io/simDAG/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Robin Denz. Author, maintainer. Katharina Meiszl. Author.","code":""},{"path":"https://robindenz1.github.io/simDAG/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Robin Denz Katharina Meiszl (2023): simDAG: R Package Simulate Simple Complex (Longitudinal) Data DAG Associated Node Information, available https://github.com/RobinDenz1/simDAG","code":"@Misc{,   title = {simDAG: An R Package to Simulate Simple and Complex (Longitudinal) Data from a DAG and Associated Node Information},   author = {Robin Denz and Katharina Meiszl},   year = {2023},   url = {https://github.com/RobinDenz1/simDAG}, }"},{"path":"https://robindenz1.github.io/simDAG/index.html","id":"simdag-","dir":"","previous_headings":"","what":"Simulate Data from a DAG and Associated Node Information","title":"Simulate Data from a DAG and Associated Node Information","text":"Author: Robin Denz","code":""},{"path":"https://robindenz1.github.io/simDAG/index.html","id":"description","dir":"","previous_headings":"","what":"Description","title":"Simulate Data from a DAG and Associated Node Information","text":"simDAG R-Package can used generate data known directed acyclic graph (DAG) associated information distributions causal coefficients. root nodes sampled first subsequent child node generated according regression model (linear, logistic, multinomial, cox, …) function. result dataset causal structure specified DAG expectation distributions coefficients initially specified. also implements comprehensive framework conducting discrete-time simulations similar fashion.","code":""},{"path":"https://robindenz1.github.io/simDAG/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Simulate Data from a DAG and Associated Node Information","text":"stable version package can installed CRAN: developmental version may installed github using remotes R-Package:","code":"install.packages(\"simDAG\") library(remotes)  remotes::install_github(\"RobinDenz1/simDAG\")"},{"path":"https://robindenz1.github.io/simDAG/index.html","id":"bug-reports-and-feature-requests","dir":"","previous_headings":"","what":"Bug Reports and Feature Requests","title":"Simulate Data from a DAG and Associated Node Information","text":"encounter bugs specific feature requests, please file Issue.","code":""},{"path":"https://robindenz1.github.io/simDAG/index.html","id":"examples","dir":"","previous_headings":"","what":"Examples","title":"Simulate Data from a DAG and Associated Node Information","text":"Suppose want generate data following causal structure:  age normally distributed mean 50 standard deviation 4 sex bernoulli distributed p = 0.5 (equal number men women). “root nodes” (meaning parents - arrows pointing ) direct causal effect bmi. causal coefficients 1.1 0.4 respectively, intercept 12 sigma standard deviation 2. death modeled bernoulli variable, caused age bmi causal coefficients 0.1 0.3 respectively. intercept use -15. following code can used generate 10000 samples specifications: fitting appropriate regression models, can check data really approximately conform specifications. First, lets look bmi: seems right. Now look death: estimated coefficients also close ones specified. examples can found documentation vignette.","code":"library(simDAG)  dag <- empty_dag() +   node(\"age\", type=\"rnorm\", mean=50, sd=4) +   node(\"sex\", type=\"rbernoulli\", p=0.5) +   node(\"bmi\", type=\"gaussian\", formula= ~ 12 + age*1.1 + sex*0.4, error=2) +   node(\"death\", type=\"binomial\", formula= ~ -15 + age*0.1 + bmi*0.3)  set.seed(42)  sim_dat <- sim_from_dag(dag, n_sim=100000) mod_bmi <- glm(bmi ~ age + sex, data=sim_dat, family=\"gaussian\") summary(mod_bmi) #>  #> Call: #> glm(formula = bmi ~ age + sex, family = \"gaussian\", data = sim_dat) #>  #> Deviance Residuals:  #>     Min       1Q   Median       3Q      Max   #> -8.4802  -1.3555   0.0005   1.3423   8.6826   #>  #> Coefficients: #>             Estimate Std. Error t value Pr(>|t|)     #> (Intercept) 11.89194    0.07954  149.51   <2e-16 *** #> age          1.10220    0.00158  697.41   <2e-16 *** #> sexTRUE      0.40447    0.01268   31.89   <2e-16 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>  #> (Dispersion parameter for gaussian family taken to be 4.022026) #>  #>     Null deviance: 2361465  on 99999  degrees of freedom #> Residual deviance:  402190  on 99997  degrees of freedom #> AIC: 422971 #>  #> Number of Fisher Scoring iterations: 2 mod_death <- glm(death ~ age + bmi, data=sim_dat, family=\"binomial\") summary(mod_death) #>  #> Call: #> glm(formula = death ~ age + bmi, family = \"binomial\", data = sim_dat) #>  #> Deviance Residuals:  #>     Min       1Q   Median       3Q      Max   #> -4.4111   0.0035   0.0066   0.0126   0.2883   #>  #> Coefficients: #>             Estimate Std. Error z value Pr(>|z|)     #> (Intercept) -14.6833     3.5538  -4.132  3.6e-05 *** #> age           0.2607     0.1698   1.535    0.125     #> bmi           0.1842     0.1402   1.314    0.189     #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>  #> (Dispersion parameter for binomial family taken to be 1) #>  #>     Null deviance: 258.65  on 99999  degrees of freedom #> Residual deviance: 214.03  on 99997  degrees of freedom #> AIC: 220.03 #>  #> Number of Fisher Scoring iterations: 13"},{"path":"https://robindenz1.github.io/simDAG/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Simulate Data from a DAG and Associated Node Information","text":"Use citation(\"simDAG\") get relevant citation information.","code":""},{"path":"https://robindenz1.github.io/simDAG/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"Simulate Data from a DAG and Associated Node Information","text":"© 2024 Robin Denz contents repository distributed GNU General Public License. can find full text License github repository. Alternatively, see http://www.gnu.org/licenses/.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/add_node.html","id":null,"dir":"Reference","previous_headings":"","what":"Add a DAG.node object to a DAG object — add_node","title":"Add a DAG.node object to a DAG object — add_node","text":"function allows users add DAG.node objects created using node node_td function DAG objects created using empty_dag function, makes easy fully specify DAG use sim_from_dag function sim_discrete_time.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/add_node.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add a DAG.node object to a DAG object — add_node","text":"","code":"add_node(dag, node)  # S3 method for class 'DAG' object_1 + object_2"},{"path":"https://robindenz1.github.io/simDAG/reference/add_node.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add a DAG.node object to a DAG object — add_node","text":"dag DAG object created using empty_dag function. node DAG.node object created using node function node_td function. object_1 Either DAG object DAG.node object. order objects change result. object_2 See argument object_1.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/add_node.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add a DAG.node object to a DAG object — add_node","text":"two ways adding node DAG object : dag <- add_node(dag, node(...)) dag <- dag + node(...), give identical results (note ... replaced actual arguments initial dag created call empty_dag). See node information specify DAG use sim_from_dag node_td functions.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/add_node.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add a DAG.node object to a DAG object — add_node","text":"Returns DAG object DAG.node object added .","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/add_node.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Add a DAG.node object to a DAG object — add_node","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/add_node.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add a DAG.node object to a DAG object — add_node","text":"","code":"library(simDAG)  ## add nodes to DAG using + dag <- empty_dag() +   node(\"age\", type=\"rnorm\", mean=50, sd=5) +   node(\"sex\", type=\"rbernoulli\", p=0.5) +   node(\"income\", type=\"gaussian\", parents=c(\"age\", \"sex\"), betas=c(1.1, 0.2),        intercept=-5, error=4)  ## add nodes to DAG using add_node() dag <- empty_dag() dag <- add_node(dag, node(\"age\", type=\"rnorm\", mean=50, sd=5))"},{"path":"https://robindenz1.github.io/simDAG/reference/as.igraph.DAG.html","id":null,"dir":"Reference","previous_headings":"","what":"Transform a DAG object into an igraph object — as.igraph.DAG","title":"Transform a DAG object into an igraph object — as.igraph.DAG","text":"function extends .igraph function igraph package allow input DAG object. result igraph object includes structure DAG, specifications. May useful plotting purposes.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/as.igraph.DAG.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transform a DAG object into an igraph object — as.igraph.DAG","text":"","code":"# S3 method for class 'DAG' as.igraph(x, ...)"},{"path":"https://robindenz1.github.io/simDAG/reference/as.igraph.DAG.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transform a DAG object into an igraph object — as.igraph.DAG","text":"x DAG object created using empty_dag function nodes added using + syntax. See ?empty_dag ?node details. Supports DAGs time-dependent nodes added using node_td function. However, including DAGs may result cyclic causal structures, time represented output matrix. ... Currently used.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/as.igraph.DAG.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Transform a DAG object into an igraph object — as.igraph.DAG","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/as.igraph.DAG.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Transform a DAG object into an igraph object — as.igraph.DAG","text":"Returns igraph object.","code":""},{"path":[]},{"path":"https://robindenz1.github.io/simDAG/reference/as.igraph.DAG.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Transform a DAG object into an igraph object — as.igraph.DAG","text":"","code":"library(simDAG)  # some example DAG dag <- empty_dag() +   node(\"death\", type=\"binomial\", parents=c(\"age\", \"sex\"), betas=c(1, 2),        intercept=-10) +   node(\"age\", type=\"rnorm\", mean=10, sd=2) +   node(\"sex\", parents=\"\", type=\"rbernoulli\", p=0.5) +   node(\"smoking\", parents=c(\"sex\", \"age\"), type=\"binomial\",        betas=c(0.6, 0.2), intercept=-2)  if (requireNamespace(\"igraph\")) {   g <- igraph::as.igraph(dag)   plot(g) }"},{"path":"https://robindenz1.github.io/simDAG/reference/dag2matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Obtain a Adjacency Matrix from a DAG object — dag2matrix","title":"Obtain a Adjacency Matrix from a DAG object — dag2matrix","text":"sim_from_dag function requires user specify causal relationships inside DAG object containing node information. function takes object input outputs underlying adjacency matrix. can useful plot theoretical DAG check nodes specified correctly.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/dag2matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Obtain a Adjacency Matrix from a DAG object — dag2matrix","text":"","code":"dag2matrix(dag, include_root_nodes=TRUE, include_td_nodes=FALSE)"},{"path":"https://robindenz1.github.io/simDAG/reference/dag2matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Obtain a Adjacency Matrix from a DAG object — dag2matrix","text":"dag DAG object created using empty_dag function nodes added using + syntax. See ?empty_dag ?node details. Supports DAGs time-dependent nodes added using node_td function. However, including DAGs may result cyclic causal structures, time represented output matrix. include_root_nodes Whether include root nodes output matrix. usually kept TRUE (default). include_td_nodes Whether include time-dependent nodes added dag using node_td function . including types nodes, possible adjacency matrix contain cycles, e.g. classic DAG anymore, due matrix representing passage time.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/dag2matrix.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Obtain a Adjacency Matrix from a DAG object — dag2matrix","text":"adjacency matrix simply square matrix node one column one row associated . example, node causal effect node B, matrix contain 1 spot matrix[\"\", \"B\"]. time-varying node also defined time-fixed node, parents parts pooled creating output matrix.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/dag2matrix.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Obtain a Adjacency Matrix from a DAG object — dag2matrix","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/dag2matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Obtain a Adjacency Matrix from a DAG object — dag2matrix","text":"Returns numeric square matrix one row one column per used node dag.","code":""},{"path":[]},{"path":"https://robindenz1.github.io/simDAG/reference/dag2matrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Obtain a Adjacency Matrix from a DAG object — dag2matrix","text":"","code":"library(simDAG)  # some example DAG dag <- empty_dag() +   node(\"death\", type=\"binomial\", parents=c(\"age\", \"sex\"), betas=c(1, 2),        intercept=-10) +   node(\"age\", type=\"rnorm\", mean=10, sd=2) +   node(\"sex\", parents=\"\", type=\"rbernoulli\", p=0.5) +   node(\"smoking\", parents=c(\"sex\", \"age\"), type=\"binomial\",        betas=c(0.6, 0.2), intercept=-2)  # get adjacency matrix dag2matrix(dag) #>         age sex death smoking #> age       0   0     1       1 #> sex       0   0     1       1 #> death     0   0     0       0 #> smoking   0   0     0       0  # get adjacency matrix using only the child nodes dag2matrix(dag, include_root_nodes=FALSE) #>         death smoking #> death       0       0 #> smoking     0       0  ## adding time-varying nodes dag <- dag +   node_td(\"disease\", type=\"time_to_event\", parents=c(\"age\", \"smoking\"),           prob_fun=0.01) +   node_td(\"death\", type=\"time_to_event\", parents=c(\"age\", \"sex\", \"smoking\",                                                    \"disease\"),           prob_fun=0.001, event_duration=Inf)  # get adjacency matrix including all nodes dag2matrix(dag, include_td_nodes=TRUE) #>         age sex death smoking disease #> age       0   0     1       1       1 #> sex       0   0     1       1       0 #> death     0   0     0       0       0 #> smoking   0   0     1       0       1 #> disease   0   0     1       0       0  # get adjacency matrix including only time-constant nodes dag2matrix(dag, include_td_nodes=FALSE) #>         age sex death smoking #> age       0   0     1       1 #> sex       0   0     1       1 #> death     0   0     0       0 #> smoking   0   0     0       0  # get adjacency matrix using only the child nodes dag2matrix(dag, include_root_nodes=FALSE) #>         death smoking #> death       0       0 #> smoking     0       0"},{"path":"https://robindenz1.github.io/simDAG/reference/dag_from_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Fills a partially specified DAG object with parameters estimated from reference data — dag_from_data","title":"Fills a partially specified DAG object with parameters estimated from reference data — dag_from_data","text":"Given partially specified DAG object, name, type parents specified plus data.frame containing realizations nodes, return fully specified DAG (beta-coefficients, intercepts, errors, ...). returned DAG can used directly simulate data sim_from_dag function.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/dag_from_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fills a partially specified DAG object with parameters estimated from reference data — dag_from_data","text":"","code":"dag_from_data(dag, data, return_models=FALSE, na.rm=FALSE)"},{"path":"https://robindenz1.github.io/simDAG/reference/dag_from_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fills a partially specified DAG object with parameters estimated from reference data — dag_from_data","text":"dag partially specified DAG object created using empty_dag node functions. See ?node detailed description . nodes need contain information name, type parents. attributes added (overwritten already ) using function. Currently support DAGs time-dependent nodes added node_td function. data data.frame data.table used obtain parameters needed DAG object. needs contain column every node specified dag argument. return_models Whether return list models fit estimate information child nodes (elements dag parents argument NULL). na.rm Whether remove missing values .","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/dag_from_data.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fills a partially specified DAG object with parameters estimated from reference data — dag_from_data","text":"works: can cumbersome specify node information needed simulation, especially lot nodes consider. Additionally, data available, natural fit appropriate models data get empirical estimate node information simulation. function automates process. user reasonable DAG knows node types, fast way generate synthetic data corresponds well empirical data. user create minimal DAG object including information parents, name node type. root nodes, required distribution parameters extracted data. child nodes, regression models corresponding specified type fit data using parents independent covariates name dependent variable. required information extracted models added respective node. output contains fully specified DAG object can used directly sim_from_dag function. may also include list containing fitted models inspection, return_models=TRUE. Supported root node types: Currently, following root node types supported: \"rnorm\": Estimates parameters normal distribution. \"rbernoulli\": Estimates p parameter Bernoulli distribution. \"rcategorical\": Estimates class probabilities categorical distribution. types need implemented user. Supported child node types: Currently, following child node types supported: \"gaussian\": Estimates parameters node type \"gaussian\". \"binomial\": Estimates parameters node type \"binomial\". \"poisson\": Estimates parameters node type \"poisson\". \"negative_binomial\": Estimates parameters node type \"negative_binomial\". \"conditional_prob\": Estimates parameters node type \"conditional_prob\". types need implemented user. Support custom nodes: sim_from_dag function supports custom node functions, described node_custom. impossible us directly support custom types function directly. However, user can extend function easily accommodate /custom types. Similar defining custom node type, user simply write function returns correctly specified node.DAG object, given named arguments name, parents, type, data return_model. first three arguments simply added directly output. data used inside function fit model obtain required parameters way. return_model argument control whether model added output (named argument called model). function name paste0(\"gen_node_\", YOURTYPE). examples given . Interactions & cubic terms: function currently support usage interaction effects non-linear terms (using ~ B + (B^2) formula). Instead, assumed values parents linear effect respective node. example, using parents=c(\"\", \"B\") node named \"C\" use formula C ~ + B. behavior desired, users need integrate custom function described .","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/dag_from_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fills a partially specified DAG object with parameters estimated from reference data — dag_from_data","text":"list length two containing new fully specified DAG object named dag list fitted models (return_models=TRUE) object named models.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/dag_from_data.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Fills a partially specified DAG object with parameters estimated from reference data — dag_from_data","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/dag_from_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fills a partially specified DAG object with parameters estimated from reference data — dag_from_data","text":"","code":"library(simDAG)  set.seed(457456)  # get some example data from a known DAG dag <- empty_dag() +   node(\"death\", type=\"binomial\", parents=c(\"age\", \"sex\"), betas=c(1, 2),        intercept=-10) +   node(\"age\", type=\"rnorm\", mean=10, sd=2) +   node(\"sex\", parents=\"\", type=\"rbernoulli\", p=0.5) +   node(\"smoking\", parents=c(\"sex\", \"age\"), type=\"binomial\",        betas=c(0.6, 0.2), intercept=-2)  data <- sim_from_dag(dag=dag, n_sim=1000)  # suppose we only know the causal structure and the node type: dag <- empty_dag() +   node(\"death\", type=\"binomial\", parents=c(\"age\", \"sex\")) +   node(\"age\", type=\"rnorm\") +   node(\"sex\", type=\"rbernoulli\") +   node(\"smoking\", type=\"binomial\", parents=c(\"sex\", \"age\"))  # get parameter estimates from data dag_full <- dag_from_data(dag=dag, data=data)  # can now be used to simulate data data2 <- sim_from_dag(dag=dag_full$dag, n_sim=100)"},{"path":"https://robindenz1.github.io/simDAG/reference/do.html","id":null,"dir":"Reference","previous_headings":"","what":"Pearls do-operator for DAG objects — do","title":"Pearls do-operator for DAG objects — do","text":"function can used set one nodes given DAG object specific value, corresponds intervention DAG defined -operator introduced Judea Pearl.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/do.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pearls do-operator for DAG objects — do","text":"","code":"do(dag, names, values)"},{"path":"https://robindenz1.github.io/simDAG/reference/do.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pearls do-operator for DAG objects — do","text":"dag DAG object created using empty_dag node functions. See ?node information specify DAG. names character string specifying names nodes dag object. value nodes set corresponding value specified values argument. node already defined dag, new one added without warning. values vector list values. nodes defined names argument set values.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/do.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Pearls do-operator for DAG objects — do","text":"Internally function simply removes old node definition nodes names replaces new node definition defines node constant value, irrespective original definition. effect can created directly specifying DAG way start (see examples). function alter original DAG place. Instead, returns modified version DAG. words, using (dag, names=\"\", values=3) change dag object.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/do.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pearls do-operator for DAG objects — do","text":"Returns DAG object updated node definitions.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/do.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Pearls do-operator for DAG objects — do","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/do.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Pearls do-operator for DAG objects — do","text":"Judea Pearl (2009). Causality: Models, Reasoning Inference. 2nd ed. Cambridge: Cambridge University Press","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/do.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Pearls do-operator for DAG objects — do","text":"","code":"library(simDAG)  # define some initial DAG dag <- empty_dag() +   node(\"death\", \"binomial\", c(\"age\", \"sex\"), betas=c(1, 2), intercept=-10) +   node(\"age\", type=\"rnorm\", mean=10, sd=2) +   node(\"sex\", parents=\"\", type=\"rbernoulli\", p=0.5) +   node(\"smoking\", parents=c(\"sex\", \"age\"), type=\"binomial\",        betas=c(0.6, 0.2), intercept=-2)  # return new DAG with do(smoking = TRUE) dag2 <- do(dag, names=\"smoking\", values=TRUE)  # which is equivalent to dag2 <- empty_dag() +   node(\"death\", \"binomial\", c(\"age\", \"sex\"), betas=c(1, 2), intercept=-10) +   node(\"age\", type=\"rnorm\", mean=10, sd=2) +   node(\"sex\", parents=\"\", type=\"rbernoulli\", p=0.5) +   node(\"smoking\", type=\"rconstant\", constant=TRUE)  # use do() on multiple variables: do(smoking = TRUE, sex = FALSE) dag2 <- do(dag, names=c(\"smoking\", \"sex\"), values=list(TRUE, FALSE))"},{"path":"https://robindenz1.github.io/simDAG/reference/empty_dag.html","id":null,"dir":"Reference","previous_headings":"","what":"Initialize an empty DAG object — empty_dag","title":"Initialize an empty DAG object — empty_dag","text":"function used conjunction multiple calls node node_td create DAG object, can used simulate data using sim_from_dag sim_discrete_time functions.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/empty_dag.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Initialize an empty DAG object — empty_dag","text":"","code":"empty_dag()"},{"path":"https://robindenz1.github.io/simDAG/reference/empty_dag.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Initialize an empty DAG object — empty_dag","text":"Note function used initialize empty DAG object. Actual information respective nodes added using node function node_td function. documentation page function contains information correctly .","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/empty_dag.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Initialize an empty DAG object — empty_dag","text":"Returns empty DAG object.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/empty_dag.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Initialize an empty DAG object — empty_dag","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/empty_dag.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Initialize an empty DAG object — empty_dag","text":"","code":"library(simDAG)  # just an empty DAG empty_dag() #> An empty DAG object without any nodes.  # adding a node to it empty_dag() + node(\"age\", type=\"rnorm\", mean=20, sd=5) #> A DAG object with: #>   -  1  nodes in total #>   -  1  of which are root nodes #>   -  0  of which are child nodes #>   -  0  of which are time-varying nodes"},{"path":"https://robindenz1.github.io/simDAG/reference/long2start_stop.html","id":null,"dir":"Reference","previous_headings":"","what":"Transform a data.table in the long-format to a data.table in the start-stop format — long2start_stop","title":"Transform a data.table in the long-format to a data.table in the start-stop format — long2start_stop","text":"function transforms data.table long-format (one row per person per time point) data.table start-stop format (one row per person-specific period variables changed).","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/long2start_stop.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transform a data.table in the long-format to a data.table in the start-stop format — long2start_stop","text":"","code":"long2start_stop(data, id, time, varying, overlap=FALSE,                 check_inputs=TRUE)"},{"path":"https://robindenz1.github.io/simDAG/reference/long2start_stop.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transform a data.table in the long-format to a data.table in the start-stop format — long2start_stop","text":"data data.table object can coerced data.table (data.frame) including data long-format. id single character string specifying unique person identifier included data. time single character string specifying time variable included data coded integers starting 1. varying character vector specifying names variables included data may change time. overlap Specifies whether intervals overlap . TRUE, \"stop\" column simply increased one, compared output overlap=FALSE. means changes given \\(t\\) recorded start next interval, previous interval ends day. check_inputs Whether check user input correct . Can turned setting FALSE save computation time.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/long2start_stop.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Transform a data.table in the long-format to a data.table in the start-stop format — long2start_stop","text":"function relies data.table syntax make data transformation RAM efficient fast possible.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/long2start_stop.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Transform a data.table in the long-format to a data.table in the start-stop format — long2start_stop","text":"Returns data.table containing columns .id (unique person identifier), .time (integer variable encoding time) variables included input data long format.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/long2start_stop.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Transform a data.table in the long-format to a data.table in the start-stop format — long2start_stop","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/long2start_stop.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Transform a data.table in the long-format to a data.table in the start-stop format — long2start_stop","text":"","code":"library(simDAG) library(data.table)  # generate example data in long format long <- data.table(.id=rep(seq_len(10), each=5),                    .time=rep(seq_len(5), 10),                    A=c(rep(FALSE, 43), TRUE, TRUE, rep(FALSE, 3), TRUE,                            TRUE),                    B=FALSE) setkey(long, .id, .time)  # transform to start-stop format long2start_stop(data=long, id=\".id\", time=\".time\", varying=c(\"A\", \"B\")) #>       .id start  stop      A      B #>     <int> <int> <int> <lgcl> <lgcl> #>  1:     1     1     5  FALSE  FALSE #>  2:     2     1     5  FALSE  FALSE #>  3:     3     1     5  FALSE  FALSE #>  4:     4     1     5  FALSE  FALSE #>  5:     5     1     5  FALSE  FALSE #>  6:     6     1     5  FALSE  FALSE #>  7:     7     1     5  FALSE  FALSE #>  8:     8     1     5  FALSE  FALSE #>  9:     9     1     3  FALSE  FALSE #> 10:     9     4     5   TRUE  FALSE #> 11:    10     1     3  FALSE  FALSE #> 12:    10     4     5   TRUE  FALSE"},{"path":"https://robindenz1.github.io/simDAG/reference/matrix2dag.html","id":null,"dir":"Reference","previous_headings":"","what":"Obtain a DAG object from a Adjacency Matrix and a List of Node Types — matrix2dag","title":"Obtain a DAG object from a Adjacency Matrix and a List of Node Types — matrix2dag","text":"sim_from_dag function requires user specify causal relationships inside DAG object containing node information. function creates object using adjacency matrix list node types. resulting DAG partially specified, may useful dag_from_data function.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/matrix2dag.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Obtain a DAG object from a Adjacency Matrix and a List of Node Types — matrix2dag","text":"","code":"matrix2dag(mat, type)"},{"path":"https://robindenz1.github.io/simDAG/reference/matrix2dag.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Obtain a DAG object from a Adjacency Matrix and a List of Node Types — matrix2dag","text":"mat p x p adjacency matrix p number variables. matrix filled zeros. places variable specified row direct causal effect variable specified column 1. columns rows named corresponding variable names. type named list one entry variable mat, specifying type corresponding node. See node available node types.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/matrix2dag.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Obtain a DAG object from a Adjacency Matrix and a List of Node Types — matrix2dag","text":"adjacency matrix simply square matrix node one column one row associated . example, node causal effect node B, matrix contain 1 spot matrix[\"\", \"B\"]. function uses kind matrix additional information node type create DAG object. resulting DAG used sim_from_dag function directly, contain necessary parameters beta-coefficients intercepts etc. may, however, passed directly dag_from_data function. pretty much valid use-case. goal specify full DAG manually, user use empty_dag function conjunction node calls instead, described respective documentation pages vignettes. output never contain time-dependent nodes. necessary, user needs manually define DAG.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/matrix2dag.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Obtain a DAG object from a Adjacency Matrix and a List of Node Types — matrix2dag","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/matrix2dag.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Obtain a DAG object from a Adjacency Matrix and a List of Node Types — matrix2dag","text":"Returns partially specified DAG object.","code":""},{"path":[]},{"path":"https://robindenz1.github.io/simDAG/reference/matrix2dag.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Obtain a DAG object from a Adjacency Matrix and a List of Node Types — matrix2dag","text":"","code":"library(simDAG)  # simple example adjacency matrix mat <- matrix(c(0, 0, 1, 0, 0, 1, 0, 0, 0), ncol=3, byrow=TRUE) colnames(mat) <- c(\"age\", \"sex\", \"death\") rownames(mat) <- c(\"age\", \"sex\", \"death\")  type <- list(age=\"rnorm\", sex=\"rbernoulli\", death=\"binomial\")  matrix2dag(mat=mat, type=type) #> A DAG object with: #>   -  3  nodes in total #>   -  2  of which are root nodes #>   -  1  of which are child nodes #>   -  0  of which are time-varying nodes"},{"path":"https://robindenz1.github.io/simDAG/reference/node.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a node object to grow a DAG step-by-step — node","title":"Create a node object to grow a DAG step-by-step — node","text":"functions used conjunction empty_dag function create DAG objects, can used simulate data using sim_from_dag function sim_discrete_time function.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a node object to grow a DAG step-by-step — node","text":"","code":"node(name, type, parents=NULL, formula=NULL, ...)  node_td(name, type, parents=NULL, formula=NULL, ...)"},{"path":"https://robindenz1.github.io/simDAG/reference/node.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a node object to grow a DAG step-by-step — node","text":"name character vector least one entry specifying name node. character vector containing multiple different names supplied, one separate node created name. nodes completely independent, exact node definition supplied user. single character string provided, one node generated. type single character string specifying type node. Depending whether node root node, child node time-dependent node different node types allowed. See details. Alternatively, suitable function may passed directly argument. parents character vector names, specifying parents node NULL (default). NULL, node treated root node. convenience also allowed set parents=\"\" indicate node root node. formula optional formula object describe node generated NULL (default). supplied start ~, nothing else left hand side. right hand side define entire structural equation, including betas intercepts. may contain valid formula syntax, ~ -2 + *3 + B*4 ~ -2 + *3 + B*4 + (^2)*0.3 + :B*1.1, allowing arbitrary non-linear effects, arbitrary interactions multiple coefficients categorical variables. argument defined, need define betas intercept argument. parents argument still specified whenever categorical variable used formula. argument currently supported nodes type \"binomial\", \"gaussian\", \"poisson\", \"negative_binomial\" \"cox\". See examples associated vignette -depth explanation. ... named arguments needed specify node. can parameters distribution functions p argument rbernoulli function root nodes arbitrary named arguments betas argument node_gaussian function.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a node object to grow a DAG step-by-step — node","text":"generate data using sim_from_dag function sim_discrete_time function, required create DAG object first. object needs contain information causal structure data (e.g. variable causes variable) specific structural equations variable (information causal coefficients, type distribution etc.). package, node /node_td function used conjunction empty_dag function create object. works first initializing empty DAG using empty_dag function adding multiple calls node /node_td functions using simple +, call node /node_td adds information single node generated. Multiple examples given . call node node_td user needs indicate node called (name), function used generate node (type), whether node parents (parents) additional arguments needed actually call data-generating function node later passed three-dot syntax (...). node vs. node_td: calling node indicating node time-fixed variable generated . using node_td indicating time-dependent node, updated step time using discrete-time simulation. node_td used planning perform discrete-time simulation sim_discrete_time function. DAG objects including time-dependent nodes may used sim_from_dag function. Implemented Root Node Types: function can used generate root nodes. requirement function least one named argument called n controls length resulting vector. example, user specify node type \"rnorm\" create normally distributed node parents. argument n set internally, additional arguments can specified using ... syntax. type=\"rnorm\" example, user set mean standard deviation using node(name=\"example\", type=\"rnorm\", mean=10, sd=5). convenience, package additionally includes three custom root-node functions: \"rbernoulli\": Draws randomly bernoulli distribution. \"rcategorical\": Draws randomly discrete probability density function. \"rconstant\": Used set variable constant value. Implemented Child Node Types: Currently, following node types implemented directly convenience: \"gaussian\": node based linear regression. \"binomial\": node based logistic regression. \"conditional_prob\": node based conditional probabilities. \"conditional_distr\": node based conditional draws different distributions. \"multinomial\": node based multinomial regression. \"poisson\": node based poisson regression. \"negative_binomial\": node based negative binomial regression. \"cox\": node based cox-regression. \"identity\": node just R expression nodes. custom child node types, see . Implemented Time-Dependent Node Types: Currently, following node types implemented directly convenience use node_td calls: \"time_to_event\": node based repeatedly checking whether event occurs point time. \"competing_events\": node based repeatedly checking whether one multiple mutually exclusive events occurs point time. However, user may also use child node types node_td call directly. custom time-dependent node types, see . Custom Node Types simple write new custom node_function used instead, allowing user use type data-generation mechanism type node (root / child / time-dependent). required function , named arguments data (sample generated far) , child node, parents (character vector specifying parents) outputs either vector containing n_sim entries, data.frame n_sim rows arbitrary amount columns. information can found node_custom documentation page. Using child nodes parents nodes: data generated child node categorical (using node_multinomial) can still used parents nodes standard node types without issues. user use formula argument supply enhanced formula, instead defining parents betas argument directly. works well node types directly support formula input. node types, users may need write custom functions make work. See associated vignette: vignette(topic=\"v_using_formulas\", package=\"simDAG\") information correctly use formulas. Cyclic causal structures: name DAG (directed acyclic graph) implies cycles allowed. means start node follow arrows direction pointing, way get back original node. necessary theoretically practical reasons dealing static DAGs created using node function. user attempts generate data static cyclic graph using sim_from_dag function, error produced. However, realm discrete-time simulations, cyclic causal structures perfectly reasonable. variable \\(\\) \\(t = 1\\) may influence variable \\(B\\) \\(t = 2\\), turn may influence variable \\(\\) \\(t = 3\\) . Therefore, using node_td function simulate time-dependent data using sim_discrete_time function, cyclic structures allowed present error produced.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Create a node object to grow a DAG step-by-step — node","text":"Contrary R standard, function support partial matching argument names. means supplying nam=\"age\" recognized name=\"age\" instead added additional node argument used respective data-generating function call using sim_from_dag.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a node object to grow a DAG step-by-step — node","text":"Returns DAG.node object can added DAG object directly.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create a node object to grow a DAG step-by-step — node","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a node object to grow a DAG step-by-step — node","text":"","code":"library(simDAG)  # creating a DAG with a single root node dag <- empty_dag() +   node(\"age\", type=\"rnorm\", mean=30, sd=4)  # creating a DAG with multiple root nodes # (passing the functions directly to 'type' works too) dag <- empty_dag() +   node(\"sex\", type=rbernoulli, p=0.5) +   node(\"income\", type=rnorm, mean=2700, sd=500)  # creating a DAG with multiple root nodes + multiple names in one node dag <- empty_dag() +   node(\"sex\", type=\"rbernoulli\", p=0.5) +   node(c(\"income_1\", \"income_2\"), type=\"rnorm\", mean=2700, sd=500)  # also using child nodes dag <- empty_dag() +   node(\"sex\", type=\"rbernoulli\", p=0.5) +   node(\"income\", type=\"rnorm\", mean=2700, sd=500) +   node(\"sickness\", type=\"binomial\", parents=c(\"sex\", \"income\"),        betas=c(1.2, -0.3), intercept=-15) +   node(\"death\", type=\"binomial\", parents=c(\"sex\", \"income\", \"sickness\"),        betas=c(0.1, -0.4, 0.8), intercept=-20)  # creating the same DAG as above, but using the enhanced formula interface dag <- empty_dag() +   node(\"sex\", type=\"rbernoulli\", p=0.5) +   node(\"income\", type=\"rnorm\", mean=2700, sd=500) +   node(\"sickness\", type=\"binomial\",        formula= ~ -15 + sexTRUE*1.2 + income*-0.3) +   node(\"death\", type=\"binomial\",        formula= ~ -20 + sexTRUE*0.1 + income*-0.4 + sickness*0.8)  # using time-dependent nodes # NOTE: to simulate data from this DAG, the sim_discrete_time() function needs #       to be used due to \"sickness\" being a time-dependent node dag <- empty_dag() +   node(\"sex\", type=\"rbernoulli\", p=0.5) +   node(\"income\", type=\"rnorm\", mean=2700, sd=500) +   node_td(\"sickness\", type=\"binomial\", parents=c(\"sex\", \"income\"),           betas=c(0.1, -0.4), intercept=-50)  # we could also use a DAG with only time-varying variables dag <- empty_dag() +   node_td(\"vaccine\", type=\"time_to_event\", prob_fun=0.001, event_duration=21) +   node_td(\"covid\", type=\"time_to_event\", prob_fun=0.01, event_duration=15,           immunity_duration=100)"},{"path":"https://robindenz1.github.io/simDAG/reference/node_binomial.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate a Node Using Logistic Regression — node_binomial","title":"Simulate a Node Using Logistic Regression — node_binomial","text":"Data parents used generate node using logistic regression predicting covariate specific probability 1 sampling Bernoulli distribution accordingly.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_binomial.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate a Node Using Logistic Regression — node_binomial","text":"","code":"node_binomial(data, parents, formula=NULL, betas, intercept,               return_prob=FALSE, output=\"logical\", labels=NULL)"},{"path":"https://robindenz1.github.io/simDAG/reference/node_binomial.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate a Node Using Logistic Regression — node_binomial","text":"data data.table (something can coerced data.table) containing columns specified parents. parents character vector specifying names parents particular child node . non-linear combinations interaction effects included, user may specify formula argument instead. formula optional formula object describe node generated NULL (default). supplied start ~, nothing else left hand side. right hand side may contain valid formula syntax, + B + B + (^2), allowing non-linear effects. argument defined, need define parents argument. example, using parents=c(\"\", \"B\") equal using formula= ~ + B. betas numeric vector length equal parents, specifying causal beta coefficients used generate node. intercept single number specifying intercept used generating node. return_prob Either TRUE FALSE (default). TRUE, calculated probability returned instead results bernoulli trials. output single character string, must either \"logical\" (default), \"numeric\", \"character\" \"factor\". output=\"character\" output=\"factor\", labels (levels case factor) can set using labels argument. labels character vector length 2 NULL (default). NULL, resulting vector returned . character vector supplied output=\"character\" output=\"factor\" used, TRUE values replaced first entry vector FALSE values replaced second argument vector. output character variable factor variable, depending output argument. argument ignored output set \"numeric\" \"logical\".","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_binomial.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulate a Node Using Logistic Regression — node_binomial","text":"Using normal form logistic regression model, observation specific event probability generated every observation dataset. Using rbernoulli function, probability used take one bernoulli sample observation dataset. probability returned return_prob set TRUE. Formal Description: Formally, data generation can described : $$Y \\sim Bernoulli(logit(\\texttt{intercept} + \\texttt{parents}_1 \\cdot \\texttt{betas}_1 + ... + \\texttt{parents}_n \\cdot \\texttt{betas}_n)),$$ \\(Bernoulli(p)\\) denotes one Bernoulli trial success probability \\(p\\), \\(n\\) number parents (length(parents)) \\(logit(x)\\) function defined : $$logit(x) = ln(\\frac{x}{1-x}).$$ example, given intercept=-15, parents=c(\"\", \"B\") betas=c(0.2, 1.3) data generation process defined : $$Y \\sim Bernoulli(logit(-15 + \\cdot 0.2 + B \\cdot 1.3)).$$ Output Format: default function returns logical vector containing TRUE FALSE entries, TRUE corresponds event FALSE event. may changed using output labels arguments. last three arguments function ignored return_prob set TRUE.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_binomial.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Simulate a Node Using Logistic Regression — node_binomial","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_binomial.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate a Node Using Logistic Regression — node_binomial","text":"Returns logical vector (numeric vector return_prob=TRUE) length nrow(data).","code":""},{"path":[]},{"path":"https://robindenz1.github.io/simDAG/reference/node_binomial.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate a Node Using Logistic Regression — node_binomial","text":"","code":"library(simDAG)  set.seed(5425)  # define needed DAG dag <- empty_dag() +   node(\"age\", type=\"rnorm\", mean=50, sd=4) +   node(\"sex\", type=\"rbernoulli\", p=0.5) +   node(\"smoking\", type=\"binomial\", parents=c(\"age\", \"sex\"),        betas=c(1.1, 0.4), intercept=-2)  # define the same DAG, but using a pretty formula dag <- empty_dag() +   node(\"age\", type=\"rnorm\", mean=50, sd=4) +   node(\"sex\", type=\"rbernoulli\", p=0.5) +   node(\"smoking\", type=\"binomial\",        formula= ~ -2 + age*1.1 + sexTRUE*0.4)  # simulate data from it sim_dat <- sim_from_dag(dag=dag, n_sim=100)  # returning only the estimated probability instead dag <- empty_dag() +   node(\"age\", type=\"rnorm\", mean=50, sd=4) +   node(\"sex\", type=\"rbernoulli\", p=0.5) +   node(\"smoking\", type=\"binomial\", parents=c(\"age\", \"sex\"),        betas=c(1.1, 0.4), intercept=-2, return_prob=TRUE)  sim_dat <- sim_from_dag(dag=dag, n_sim=100)"},{"path":"https://robindenz1.github.io/simDAG/reference/node_competing_events.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate a Time-to-Event Node with Multiple Mutually Exclusive Events in Discrete-Time Simulation — node_competing_events","title":"Simulate a Time-to-Event Node with Multiple Mutually Exclusive Events in Discrete-Time Simulation — node_competing_events","text":"node essentially models categorical time-dependent variable time type event important later usage. adds two columns data: name_event (type event person currently experiencing) name_time (time current event started). Can used inside sim_discrete_time function, outside . Past events kind stored two lists. See details.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_competing_events.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate a Time-to-Event Node with Multiple Mutually Exclusive Events in Discrete-Time Simulation — node_competing_events","text":"","code":"node_competing_events(data, parents, sim_time, name,                       prob_fun, ..., event_duration=c(1, 1),                       immunity_duration=max(event_duration),                       save_past_events=TRUE, check_inputs=TRUE,                       envir)"},{"path":"https://robindenz1.github.io/simDAG/reference/node_competing_events.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate a Time-to-Event Node with Multiple Mutually Exclusive Events in Discrete-Time Simulation — node_competing_events","text":"data data.table containing columns specified parents. Similar objects data.frames supported. parents character vector specifying names parents particular child node . sim_time current time simulation. name name node. used prefix _event, _time, _past_event_times _past_event_kind columns. prob_fun function returns numeric matrix nrow(data) rows one column storing probabilities occurrence possible event type plus column events. example, two possible events recurrence death, matrix need contain three columns. first storing probability -event two columns storing probabilities recurrence death per person. Since numbers probabilities, matrix contain numbers 0 1 sum 1 row. numbers specify person-specific probability experiencing events modeled node particular point time simulation. corresponding event generated internally using rcategorical function. ... arbitrary number additional named arguments passed prob_fun. Ignore want pass arguments. event_duration numeric vector containing one positive integer type event interest, specifying long event last. example, interested modelling time cardiovascular event death competing event, argument need 2 entries. One specify duration cardiovascular event Inf (death terminal event). immunity_duration single number >= max(event_duration) specifying long person immune events experiencing one. count internally starts event starts, order use immunity duration 10 time units event max(event_duration) + 10 used. save_past_events event modeled using node recurrent (immunity_duration < Inf & (event_duration < Inf)), person may experience multiple events course simulation. generally stored ce_past_events list ce_past_causes list included output sim_discrete_time function. extends runtime increases RAM usage, interested timing previous events using save_states=\"\" functionality can turned setting argument FALSE check_inputs Whether perform plausibility checks user input . set TRUE default, can set FALSE order speed things using function simulation study something similar. envir used internally efficiently store past event times. used user.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_competing_events.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulate a Time-to-Event Node with Multiple Mutually Exclusive Events in Discrete-Time Simulation — node_competing_events","text":"performing discrete-time simulation using sim_discrete_time function, standard node functions implemented package usually sufficient capture time-dependent nature interesting variables. Often, variable modelled probability occurring point time. occur, kind influence variables period time goes back normal (). car crash, surgery, vaccination etc. node_time_to_event node function can used model kinds nodes fairly straightforward fashion. function extended version node_time_to_event function. Instead simulating binary event, can generate multiple competing events, occurrence one event time \\(t\\) mutually exclusive occurrence event time. words, multiple events possible, one can occur time. Works: \\(t = 1\\), node initialized first time. adds two columns data: name_event (whether person currently event) name_time (time current event started) name name node. Additionally, adds list max_t entries ce_past_events list returned sim_discrete_time function, records individuals experienced new event point time. ce_past_causes list additionally records kind event happened time. nutshell, simply models occurrence event calculating probability occurrence \\(t\\) drawing single multinomial trial probability. trial \"success\", corresponding event column set drawn event type (described using integers, 0 event events numbered consecutively), time column set current simulation time \\(t\\) columns storing past event times types receive entry. event column stay new integer value event . duration controlled event_duration parameter. modeling terminal events death, one can simply set parameter Inf, making event eternal. many cases also necessary implement kind immunity event, can done using immunity_duration argument. effectively sets probability another occurrence event 0 next immunity_duration time steps. immunity duration, event may > 0 (event still ongoing) 0 (event_duration event type already passed). probability occurrence calculated using function provided user using prob_fun argument. can arbitrary complex function. requirement takes data first argument. columns defined parents argument passed argument automatically. argument called sim_time, current time simulation automatically passed well. arguments can passed using prob_fun_args argument. simple example multinomial logistic regression node, probabilities calculated additive linear combination columns defined parents. complex function include simulation-time dependent effects, effects dependent past event times etc. Examples can found vignettes. can done : type node naturally support implementation competing events, may terminal recurrent nature may influenced pretty much anything. specifying parents prob_fun arguments correctly, possible create event type dependent past events time--event variables variables general. user can include amount nodes simulation. may also used simulate kind binary time-dependent variable one usually associate name \"event\" well. flexible, require user coding . done : function may used generate competing events, meaning occurrence event 1 \\(t = 1\\) makes impossible event 2 \\(t = 1\\) occur. user wants generate multiple events mutually exclusive, may add multiple node_time_to_event based nodes dag argument sim_discrete_time function. fact, competing events node may simulated using multiple calls node_time_to_event based nodes well, defining prob_fun argument nodes way occurrence event makes occurrence event B impossible. might actually easier implement situations, require user manually define probability function outputs matrix subject-specific probabilities.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_competing_events.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Simulate a Time-to-Event Node with Multiple Mutually Exclusive Events in Discrete-Time Simulation — node_competing_events","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_competing_events.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate a Time-to-Event Node with Multiple Mutually Exclusive Events in Discrete-Time Simulation — node_competing_events","text":"Returns data.table containing updated columns node.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_competing_events.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Simulate a Time-to-Event Node with Multiple Mutually Exclusive Events in Discrete-Time Simulation — node_competing_events","text":"function called outside sim_discrete_time function. makes sense use type node_td function call, described documentation vignettes.","code":""},{"path":[]},{"path":"https://robindenz1.github.io/simDAG/reference/node_competing_events.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate a Time-to-Event Node with Multiple Mutually Exclusive Events in Discrete-Time Simulation — node_competing_events","text":"","code":"library(simDAG)  ## a competing_events node with only terminal events, all with a constant ## probability of occurrence, independent of any other variable prob_death_illness <- function(data) {    # simply repeat the same probabilities for everyone   n <- nrow(data)   p_mat <- matrix(c(rep(0.9, n), rep(0.005, n), rep(0.005, n)),                   byrow = FALSE, ncol=3)    return(p_mat) }  dag <- empty_dag() +   node_td(\"death_illness\", type=\"competing_events\", prob_fun=prob_death_illness,           event_duration=c(Inf, Inf))  ## making one of the event-types terminal and the other recurrent dag <- empty_dag() +   node_td(\"death_illness\", type=\"competing_events\", prob_fun=prob_death_illness,           event_duration=c(15, Inf))  ## call the sim_discrete_time function to generate data from it sim <- sim_discrete_time(dag, n_sim=100, max_t=500)  ## more examples on how to use the sim_discrete_time function can be found ## in the documentation page of the node_time_to_event function and ## in the package vignettes"},{"path":"https://robindenz1.github.io/simDAG/reference/node_conditional_distr.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate a Node by Sampling from Different Distributions based on Strata — node_conditional_distr","title":"Simulate a Node by Sampling from Different Distributions based on Strata — node_conditional_distr","text":"function can used generate kind dichotomous, categorical numeric variables dependent one categorical variables randomly sampling user-defined distributions strata defined nodes parents.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_conditional_distr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate a Node by Sampling from Different Distributions based on Strata — node_conditional_distr","text":"","code":"node_conditional_distr(data, parents, distr, default_distr=NULL,                        default_distr_args=list(), default_val=NA_real_,                        coerce2numeric=TRUE, check_inputs=TRUE)"},{"path":"https://robindenz1.github.io/simDAG/reference/node_conditional_distr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate a Node by Sampling from Different Distributions based on Strata — node_conditional_distr","text":"data data.table (something can coerced data.table) containing columns specified parents. parents character vector specifying names parents particular child node . distr named list element corresponds one stratum defined parents. one name given parents, means one element possible values variable given parents. node multiple parents, needs one element possible combinations parents (see examples). values elements list , first argument callable function (rnorm, rcategorical, ...) rest named arguments function. function can used, long returns vector n values, n argument function. n set internally based stratum size set user. list contain one element possible strata defined parents, default_val default_distr arguments used. default_distr function used generate values strata explicitly mentioned distr argument, NULL (default). NULL, default_val argument used fill missing strata values.  function passed argument contain argument n, define number samples generate. return vector n values. examples (), rnorm rbernoulli. default_distr_args named list arguments passed function defined default_distr argument. Ignored default_distr NULL. default_val single value used output strata mentioned distr. Ignored default_distr NULL. coerce2numeric single logical value specifying whether try coerce resulting variable numeric . check_inputs single logical value specifying whether perform input checks . May set TRUE speed things little sure input correct.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_conditional_distr.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulate a Node by Sampling from Different Distributions based on Strata — node_conditional_distr","text":"Utilizing user-defined distribution stratum parents (supplied using distr argument), function simply calls user-defined function arguments given user generate new variable. allows new variable consist mix different distributions, based categorical parents. Formal Description: Formally, data generation process can described series conditional equations. example, suppose just one parent node sex levels male female goal creating continuous outcome normal distribution \\(N(10, 3)\\) males \\(N(7, 2)\\) females. conditional equation : $$Y \\sim \\begin{cases} \t\t\tN(10, 3), & \\text{} \\texttt{sex=\"male\"} \\\\ \t\t\tN(7, 2), & \\text{} \\texttt{sex=\"female\"} \\\\ \t\t\\end{cases},$$ two variables, conditional distribution stratified intersection subgroups defined variables.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_conditional_distr.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Simulate a Node by Sampling from Different Distributions based on Strata — node_conditional_distr","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_conditional_distr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate a Node by Sampling from Different Distributions based on Strata — node_conditional_distr","text":"Returns numeric vector length nrow(data).","code":""},{"path":[]},{"path":"https://robindenz1.github.io/simDAG/reference/node_conditional_distr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate a Node by Sampling from Different Distributions based on Strata — node_conditional_distr","text":"","code":"library(simDAG)  set.seed(42)  #### with one parent node ####  # define conditional distributions distr <- list(male=list(\"rnorm\", mean=100, sd=5),               female=list(\"rcategorical\", probs=c(0.1, 0.2, 0.7)))  # define DAG dag <- empty_dag() +   node(\"sex\", type=\"rcategorical\", labels=c(\"male\", \"female\"),        output=\"factor\", probs=c(0.4, 0.6)) +   node(\"chemo\", type=\"rbernoulli\", p=0.5) +   node(\"A\", type=\"conditional_distr\", parents=\"sex\", distr=distr)  # generate data data <- sim_from_dag(dag=dag, n_sim=1000)   #### with two parent nodes ####  # define conditional distributions with interaction between parents distr <- list(male.FALSE=list(\"rnorm\", mean=100, sd=5),               male.TRUE=list(\"rnorm\", mean=100, sd=20),               female.FALSE=list(\"rbernoulli\", p=0.5),               female.TRUE=list(\"rcategorical\", probs=c(0.1, 0.2, 0.7)))  # define DAG dag <- empty_dag() +   node(\"sex\", type=\"rcategorical\", labels=c(\"male\", \"female\"),        output=\"factor\", probs=c(0.4, 0.6)) +   node(\"chemo\", type=\"rbernoulli\", p=0.5) +   node(\"A\", type=\"conditional_distr\", parents=c(\"sex\", \"chemo\"), distr=distr)  # generate data data <- sim_from_dag(dag=dag, n_sim=1000)"},{"path":"https://robindenz1.github.io/simDAG/reference/node_conditional_prob.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate a Node Using Conditional Probabilities — node_conditional_prob","title":"Simulate a Node Using Conditional Probabilities — node_conditional_prob","text":"function can used generate dichotomous categorical variables dependent one categorical variables probabilities occurrence strata defined variables known.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_conditional_prob.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate a Node Using Conditional Probabilities — node_conditional_prob","text":"","code":"node_conditional_prob(data, parents, probs, default_probs=NULL,                       default_val=NA, labels=NULL,                       coerce2factor=FALSE, check_inputs=TRUE)"},{"path":"https://robindenz1.github.io/simDAG/reference/node_conditional_prob.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate a Node Using Conditional Probabilities — node_conditional_prob","text":"data data.table (something can coerced data.table) containing columns specified parents. parents character vector specifying names parents particular child node . probs named list element corresponds one stratum defined parents. one name given parents, means one element possible value variable given parents. node multiple parents, needs one element possible combinations parents (see examples). values elements either single number, corresponding probability occurrence single event/value case dichotomous variable, vector probabilities sum 1, corresponding class probabilities. either case, length elements . possible strata parents (possible combinations case multiple parents) omitted, result set default_val omitted strata. See argument default_val argument default_probs alternative. default_probs possible strata parents included probs, user may set default probabilities omitted strata. example, three strata (, B C) defined parents probs contains defined probabilities strata , probabilities strata B C can set simultaneously using argument. single value 0 1 Bernoulli trials numeric vector sum 1 multinomial trials. NULL (default) value produced output missing strata set default_val (see ). default_val Value produced variable strata included probs argument. default_probs NULL, arguments functionality used instead. labels vector labels generated output. NULL (default) output dichotomous, logical variable returned. NULL output categorical, simply uses integers starting 1 class labels. coerce2factor single logical value specifying whether return drawn events factor . check_inputs single logical value specifying whether input checks performed . Set FALSE save computation time simulations.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_conditional_prob.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulate a Node Using Conditional Probabilities — node_conditional_prob","text":"Utilizing user-defined discrete probability distribution stratum parents (supplied using probs argument), function simply calls either rbernoulli rcategorical function. Formal Description: Formally, data generation process can described series conditional equations. example, suppose just one parent node sex levels male female goal creating binary outcome probability occurrence 0.5 males 0.7 females. conditional equation : $$Y \\sim Bernoulli(p),$$ : $$p = \\begin{cases} \t\t\t0.5, & \\text{} \\texttt{sex=\"male\"} \\\\ \t\t\t0.7, & \\text{} \\texttt{sex=\"female\"} \\\\ \t\t\\end{cases},$$ \\(Bernoulli(p)\\) Bernoulli distribution success probability \\(p\\). outcome two categories, Bernoulli distribution replaced \\(Multinomial(p)\\) \\(p\\) replaced matrix class probabilities. two variables, conditional distribution stratified intersection subgroups defined variables.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_conditional_prob.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Simulate a Node Using Conditional Probabilities — node_conditional_prob","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_conditional_prob.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate a Node Using Conditional Probabilities — node_conditional_prob","text":"Returns numeric vector length nrow(data).","code":""},{"path":[]},{"path":"https://robindenz1.github.io/simDAG/reference/node_conditional_prob.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate a Node Using Conditional Probabilities — node_conditional_prob","text":"","code":"library(simDAG)  set.seed(42)  #### two classes, one parent node ####  # define conditional probs probs <- list(male=0.5, female=0.8)  # define DAG dag <- empty_dag() +   node(\"sex\", type=\"rcategorical\", labels=c(\"male\", \"female\"),        output=\"factor\", probs=c(0.5, 0.5)) +   node(\"chemo\", type=\"rbernoulli\", p=0.5) +   node(\"A\", type=\"conditional_prob\", parents=\"sex\", probs=probs)  # generate data data <- sim_from_dag(dag=dag, n_sim=1000)   #### three classes, one parent node ####  # define conditional probs probs <- list(male=c(0.5, 0.2, 0.3), female=c(0.8, 0.1, 0.1))  # define DAG dag <- empty_dag() +   node(\"sex\", type=\"rcategorical\", labels=c(\"male\", \"female\"),        output=\"factor\", probs=c(0.5, 0.5)) +   node(\"chemo\", type=\"rbernoulli\", p=0.5) +   node(\"A\", type=\"conditional_prob\", parents=\"sex\", probs=probs)  # generate data data <- sim_from_dag(dag=dag, n_sim=1000)   #### two classes, two parent nodes ####  # define conditional probs probs <- list(male.FALSE=0.5,               male.TRUE=0.8,               female.FALSE=0.1,               female.TRUE=0.3)  # define DAG dag <- empty_dag() +   node(\"sex\", type=\"rcategorical\", labels=c(\"male\", \"female\"),        output=\"factor\", probs=c(0.5, 0.5)) +   node(\"chemo\", type=\"rbernoulli\", p=0.5) +   node(\"A\", type=\"conditional_prob\", parents=c(\"sex\", \"chemo\"), probs=probs)  # generate data data <- sim_from_dag(dag=dag, n_sim=1000)   #### three classes, two parent nodes ####  # define conditional probs probs <- list(male.FALSE=c(0.5, 0.1, 0.4),               male.TRUE=c(0.8, 0.1, 0.1),               female.FALSE=c(0.1, 0.7, 0.2),               female.TRUE=c(0.3, 0.4, 0.3))  # define dag dag <- empty_dag() +   node(\"sex\", type=\"rcategorical\", labels=c(\"male\", \"female\"),        output=\"factor\", probs=c(0.5, 0.5)) +   node(\"chemo\", type=\"rbernoulli\", p=0.5) +   node(\"A\", type=\"conditional_prob\", parents=c(\"sex\", \"chemo\"), probs=probs)  # generate data data <- sim_from_dag(dag=dag, n_sim=1000)"},{"path":"https://robindenz1.github.io/simDAG/reference/node_cox.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate a Node Using Cox-Regression — node_cox","title":"Simulate a Node Using Cox-Regression — node_cox","text":"Data parents used generate node using cox-regression using method Bender et al. (2005).","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_cox.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate a Node Using Cox-Regression — node_cox","text":"","code":"node_cox(data, parents, formula=NULL, betas, surv_dist, lambda, gamma,          cens_dist, cens_args, name)"},{"path":"https://robindenz1.github.io/simDAG/reference/node_cox.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate a Node Using Cox-Regression — node_cox","text":"data data.table (something can coerced data.table) containing columns specified parents. parents character vector specifying names parents particular child node . non-linear combinations interaction effects included, user may specify formula argument instead. formula optional formula object describe node generated NULL (default). supplied start ~, nothing else left hand side. right hand side may contain valid formula syntax, + B + B + (^2), allowing non-linear effects. argument defined, need define parents argument. example, using parents=c(\"\", \"B\") equal using formula= ~ + B. betas numeric vector length equal parents, specifying causal beta coefficients used generate node. surv_dist single character specifying distribution used generating survival times. Can either \"weibull\" \"exponential\". lambda single number used parameter defined surv_dist. gamma single number used parameter defined surv_dist. cens_dist single character naming distribution function used generate censoring times. example, \"runif\" used generate uniformly distributed censoring times. Set NULL get censoring. cens_args list named arguments passed function specified cens_dist argument. name single character string specifying name node.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_cox.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulate a Node Using Cox-Regression — node_cox","text":"survival times generated according cox proportional-hazards regression model defined user. exactly data-generation works described detail Bender et al. (2005). also include censoring, function allows user supply function generates random censoring times. censoring time smaller generated survival time, individual considered censored. Unlike node type functions, function adds two columns resulting dataset instead one. first column called paste0(name, \"_event\") logical variable, TRUE indicates event happened FALSE indicates right-censoring. second column named paste0(name, \"_time\") includes survival censoring time corresponding previously mentioned event indicator. standard format right-censored time--event data without time-varying covariates. simulate complex time--event data, user may need use sim_discrete_time function instead.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_cox.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Simulate a Node Using Cox-Regression — node_cox","text":"Bender R, Augustin T, Blettner M. Generating survival times simulate Cox proportional hazards models. Statistics Medicine. 2005; 24 (11): 1713-1723.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_cox.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Simulate a Node Using Cox-Regression — node_cox","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_cox.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate a Node Using Cox-Regression — node_cox","text":"Returns data.table length nrow(data) containing two columns. starting nodes name ending _event _time. first logical vector, second numeric one.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_cox.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate a Node Using Cox-Regression — node_cox","text":"","code":"library(simDAG)  set.seed(3454)  # define DAG dag <- empty_dag() +   node(\"age\", type=\"rnorm\", mean=50, sd=4) +   node(\"sex\", type=\"rbernoulli\", p=0.5) +   node(\"death\", type=\"cox\", parents=c(\"sex\", \"age\"), betas=c(1.1, 0.4),        surv_dist=\"weibull\", lambda=1.1, gamma=0.7, cens_dist=\"runif\",        cens_args=list(min=0, max=1))  sim_dat <- sim_from_dag(dag=dag, n_sim=1000)"},{"path":"https://robindenz1.github.io/simDAG/reference/node_custom.html","id":null,"dir":"Reference","previous_headings":"","what":"Create Your Own Function to Simulate a Root Node, Child Node or Time-Dependent Node — node_custom","title":"Create Your Own Function to Simulate a Root Node, Child Node or Time-Dependent Node — node_custom","text":"page describes detail define custom functions allow usage root nodes, child nodes time-dependent nodes directly implemented package. , users may create data functional dependence can think .","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_custom.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create Your Own Function to Simulate a Root Node, Child Node or Time-Dependent Node — node_custom","text":"number available types nodes limited, package allows user easily implement node types writing single custom function. Users may create root nodes, child nodes time-dependent nodes. requirements node type listed . simple examples node type given . think custom node type might useful others, please contact maintainer package via supplied e-mail address github might add package. Root Nodes: function generates vector size \\(n\\) n==nrow(data), data.frame many rows current data can used child node. requirement : 1.) function argument called n controls many samples generate. examples already implemented R outside package rnorm(), rgamma() rbeta(). function may take amount arguments, passed three-dot syntax. Child Nodes: , almost function may used generate child node. four things required work properly: 1.) ' name start node_ (want use string define type). 2.) contain argument called data (contains already generated data). 3.) contain argument called parents (contains vector child nodes parents). 4.) return either vector length n_sim data.frame number columns n_sim rows. function may include amount additional arguments specified user. Time-Dependent Nodes: time-dependent nodes mean nodes created using node_td function. general, works essentially way simple root nodes child nodes. requirements : 1.) ' name start node_ (want use string define type). 2.) contain argument called data (contains already generated data). 3.) child node, contain argument called parents (contains vector child nodes parents). necessary nodes independently generated. 4.) return either vector length n_sim data.frame number columns n_sim rows. , number additional arguments allowed passed three-dot syntax. Additionally, users may add argument function called sim_time. included function definition, current time simulation passed function every call made . Similarly, argument past_states may added. done , list containing previous states simulation (saved using save_states argument sim_discrete_time) function) passed internally, giving user access data generated previous points time.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_custom.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create Your Own Function to Simulate a Root Node, Child Node or Time-Dependent Node — node_custom","text":"return either vector length nrow(data) data.table data.frame nrow(data) rows.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_custom.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create Your Own Function to Simulate a Root Node, Child Node or Time-Dependent Node — node_custom","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_custom.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create Your Own Function to Simulate a Root Node, Child Node or Time-Dependent Node — node_custom","text":"","code":"library(simDAG)  set.seed(3545)  ################ Custom Root Nodes ###################  # using external functions without defining them yourself can be done this way dag <- empty_dag() +   node(\"A\", type=\"rgamma\", shape=0.1, rate=2) +   node(\"B\", type=\"rbeta\", shape1=2, shape2=0.3)  ## define your own root node instead # this function takes the sum of a normally distributed random number and an # uniformly distributed random number custom_root <- function(n, min=0, max=1, mean=0, sd=1) {   out <- runif(n, min=min, max=max) + rnorm(n, mean=mean, sd=sd)   return(out) }  dag <- empty_dag() +   node(\"A\", type=\"custom_root\", min=0, max=10, mean=5, sd=2) #> Error in check_inputs_root_node(name = name, type = type): The 'type' parameter of a root node must be a single character string naming a defined function.  # equivalently, the function can be supplied directly dag <- empty_dag() +   node(\"A\", type=custom_root, min=0, max=10, mean=5, sd=2)  ############### Custom Child Nodes ###################  # create a custom node function, which is just a gaussian node that # includes (bad) truncation node_gaussian_trunc <- function(data, parents, betas, intercept, error,                                 left, right) {   out <- node_gaussian(data=data, parents=parents, betas=betas,                        intercept=intercept, error=error)   out <- ifelse(out <= left, left,                 ifelse(out >= right, right, out))   return(out) }  # another custom node function, which simply returns a sum of the parents parents_sum <- function(data, parents, betas=NULL) {   out <- rowSums(data[, parents, with=FALSE])   return(out) }  # an example of using these new node types in a simulation dag <- empty_dag() +   node(\"age\", type=\"rnorm\", mean=50, sd=4) +   node(\"sex\", type=\"rbernoulli\", p=0.5) +   node(\"custom_1\", type=\"gaussian_trunc\", parents=c(\"sex\", \"age\"),        betas=c(1.1, 0.4), intercept=-2, error=2, left=10, right=25) +   node(\"custom_2\", type=parents_sum, parents=c(\"age\", \"custom_1\")) #> Error in check_inputs_child_node(name = name, type = type, parents = parents,     args = args, formula = formula, time_varying = FALSE): The 'type' parameter of a child node must be a single character string pointing to a function starting with 'node_'.  sim_dat <- sim_from_dag(dag=dag, n_sim=100)  ########## Custom Time-Dependent Nodes ###############  ## example for a custom time-dependent node with no parents # this node simply draws a new value from a normal distribution at # each point in time node_custom_root_td <- function(data, n, mean=0, sd=1) {   return(rnorm(n=n, mean=mean, sd=sd)) }  n_sim <- 100  dag <- empty_dag() +   node_td(name=\"Something\", type=node_custom_root_td, n=n_sim, mean=10, sd=5)  sim <- sim_discrete_time(dag, n_sim=n_sim, max_t=10)  ## example for a custom time-dependent child node # draw from a normal distribution with different specifications based on # whether a previously updated time-dependent node is currently TRUE node_custom_child <- function(data, parents) {   out <- numeric(nrow(data))   out[data$other_event] <- rnorm(n=sum(data$other_event), mean=10, sd=3)   out[!data$other_event] <- rnorm(n=sum(!data$other_event), mean=5, sd=10)   return(out) }  dag <- empty_dag() +   node_td(\"other\", type=\"time_to_event\", prob_fun=0.1) +   node_td(\"whatever\", type=\"custom_child\", parents=\"other_event\") #> Error in get(paste0(\"node_\", type)): object 'node_custom_child' not found  sim <- sim_discrete_time(dag, n_sim=50, max_t=10) #> Error: An error occured when trying to add the output of node 'Something' at time t = 1 to the current data. The message was: #> Error in `[<-.data.table`(`*tmp*`, , name, value = c(6.19202228675257, : Supplied 100 items to be assigned to 50 items of column 'Something'. If you wish to 'recycle' the RHS please use rep() to make this intent clear to readers of your code.  ## using the sim_time argument in a custom node function # this function returns a continuous variable that is simply the # current simulation time squared node_square_sim_time <- function(data, sim_time, n_sim) {   return(rep(sim_time^2, n=n_sim)) }  # note that we should not actually define the sim_time argument in the # node_td() call below, because it will be passed internally, just like data dag <- empty_dag() +   node_td(\"unclear\", type=node_square_sim_time, n_sim=100)  sim <- sim_discrete_time(dag, n_sim=100, max_t=10)  ## a node using previous states of the simulation  # this function simply returns the value used two simulation time steps ago + # a normally distributed random value node_prev_state <- function(data, past_states, sim_time) {   if (sim_time < 3) {     return(rnorm(n=nrow(data)))   } else {     return(past_states[[sim_time-2]]$A + rnorm(n=nrow(data)))   } }  # note that we again do not specify the sim_time and past_states argument # directly here, because they are set internally dag <- empty_dag() +   node_td(\"A\", type=node_prev_state, parents=\"A\")  # save_states=\"all\" is needed, because we use them internally sim <- sim_discrete_time(dag, n_sim=100, max_t=10, save_states=\"all\")"},{"path":"https://robindenz1.github.io/simDAG/reference/node_gaussian.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate a Node Using Linear Regression — node_gaussian","title":"Simulate a Node Using Linear Regression — node_gaussian","text":"Data parents used generate node using linear regression predicting covariate specific mean sampling normal distribution mean specified standard deviation.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_gaussian.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate a Node Using Linear Regression — node_gaussian","text":"","code":"node_gaussian(data, parents, formula=NULL, betas, intercept, error)"},{"path":"https://robindenz1.github.io/simDAG/reference/node_gaussian.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate a Node Using Linear Regression — node_gaussian","text":"data data.table (something can coerced data.table) containing columns specified parents. parents character vector specifying names parents particular child node . non-linear combinations interaction effects included, user may specify formula argument instead. formula optional formula object describe node generated NULL (default). supplied start ~, nothing else left hand side. right hand side may contain valid formula syntax, + B + B + (^2), allowing non-linear effects. argument defined, need define parents argument. example, using parents=c(\"\", \"B\") equal using formula= ~ + B. betas numeric vector length equal parents, specifying causal beta coefficients used generate node. intercept single number specifying intercept used generating node. error single number specifying sigma error used generating node.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_gaussian.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulate a Node Using Linear Regression — node_gaussian","text":"Using general linear regression equation, observation-specific value expected given model generated every observation dataset generated thus far. stop , create perfect fit node, unrealistic. Instead, add error term taking one sample normal distribution observation mean zero standard deviation error. error term added predicted mean. Formal Description: Formally, data generation can described : $$Y \\sim \\texttt{intercept} + \\texttt{parents}_1 \\cdot \\texttt{betas}_1 + ... + \\texttt{parents}_n \\cdot \\texttt{betas}_n+ N(0, \\texttt{error}),$$ \\(N(0, \\texttt{error})\\) denotes normal distribution mean 0 standard deviation error \\(n\\) number parents (length(parents)). example, given intercept=-15, parents=c(\"\", \"B\"), betas=c(0.2, 1.3) error=2 data generation process defined : $$Y \\sim -15 + \\cdot 0.2 + B \\cdot 1.3 + N(0, 2).$$","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_gaussian.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Simulate a Node Using Linear Regression — node_gaussian","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_gaussian.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate a Node Using Linear Regression — node_gaussian","text":"Returns numeric vector length nrow(data).","code":""},{"path":[]},{"path":"https://robindenz1.github.io/simDAG/reference/node_gaussian.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate a Node Using Linear Regression — node_gaussian","text":"","code":"library(simDAG)  set.seed(12455432)  # define a DAG dag <- empty_dag() +   node(\"age\", type=\"rnorm\", mean=50, sd=4) +   node(\"sex\", type=\"rbernoulli\", p=0.5) +   node(\"bmi\", type=\"gaussian\", parents=c(\"sex\", \"age\"),        betas=c(1.1, 0.4), intercept=12, error=2)  # define the same DAG, but with a pretty formula for the child node dag <- empty_dag() +   node(\"age\", type=\"rnorm\", mean=50, sd=4) +   node(\"sex\", type=\"rbernoulli\", p=0.5) +   node(\"bmi\", type=\"gaussian\", error=2,        formula= ~ 12 + sexTRUE*1.1 + age*0.4)  sim_dat <- sim_from_dag(dag=dag, n_sim=100)"},{"path":"https://robindenz1.github.io/simDAG/reference/node_identity.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate a Node based on an expression — node_identity","title":"Simulate a Node based on an expression — node_identity","text":"node type may used generate new node given regular R expression may include function calls valid R syntax. may useful combine components node need simulated separate node calls, just convenient shorthand variable transformations.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_identity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate a Node based on an expression — node_identity","text":"","code":"node_identity(data, parents, formula)"},{"path":"https://robindenz1.github.io/simDAG/reference/node_identity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate a Node based on an expression — node_identity","text":"data data.table (something can coerced data.table) containing columns specified parents. parents character vector specifying names parents particular child node . using function node type node node_td, argument usually need specified formula argument required contains needed information already. formula formula object containing ~ symbol nothing LHS, valid R expression can evaluated data RHS. expression needs contain least one variable name (otherwise users may simply use rconstant node type). may contain number function calls valid R syntax, given contained objects included global environment.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_identity.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulate a Node based on an expression — node_identity","text":"Custom functions objects can used without issues formula, need present global environment, otherwise underlying eval() function call fail. Using function outside node node_td essentially equal using (data, eval(formula)) (without ~ formula).","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_identity.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Simulate a Node based on an expression — node_identity","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_identity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate a Node based on an expression — node_identity","text":"Returns numeric vector length nrow(data).","code":""},{"path":[]},{"path":"https://robindenz1.github.io/simDAG/reference/node_identity.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate a Node based on an expression — node_identity","text":"","code":"library(simDAG)  set.seed(12455432)  # define a DAG dag <- empty_dag() +   node(\"age\", type=\"rnorm\", mean=50, sd=4) +   node(\"sex\", type=\"rbernoulli\", p=0.5) +   node(\"bmi\", type=\"identity\", formula= ~ age + sex + 2)  sim_dat <- sim_from_dag(dag=dag, n_sim=100) head(sim_dat) #>         age    sex      bmi #>       <num> <lgcl>    <num> #> 1: 46.90669  FALSE 48.90669 #> 2: 47.25599  FALSE 49.25599 #> 3: 47.05490  FALSE 49.05490 #> 4: 48.06434  FALSE 50.06434 #> 5: 51.62119  FALSE 53.62119 #> 6: 54.11589  FALSE 56.11589  # more complex alternative dag <- empty_dag() +   node(\"age\", type=\"rnorm\", mean=50, sd=4) +   node(\"sex\", type=\"rbernoulli\", p=0.5) +   node(\"bmi\", type=\"identity\",        formula= ~ age / 2 + age^2 - ifelse(sex, 2, 3) + 2)  sim_dat <- sim_from_dag(dag=dag, n_sim=100) head(sim_dat) #>         age    sex      bmi #>       <num> <lgcl>    <num> #> 1: 48.75325   TRUE 2401.256 #> 2: 48.62980   TRUE 2389.173 #> 3: 56.19418   TRUE 3185.883 #> 4: 53.39997  FALSE 2877.257 #> 5: 45.73172   TRUE 2114.256 #> 6: 56.06411  FALSE 3170.217"},{"path":"https://robindenz1.github.io/simDAG/reference/node_multinomial.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate a Node Using Multinomial Regression — node_multinomial","title":"Simulate a Node Using Multinomial Regression — node_multinomial","text":"Data parents used generate node using multinomial regression predicting covariate specific probability class sampling multinomial distribution accordingly.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_multinomial.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate a Node Using Multinomial Regression — node_multinomial","text":"","code":"node_multinomial(data, parents, betas, intercepts,                  labels=NULL, output=\"factor\",                  return_prob=FALSE)"},{"path":"https://robindenz1.github.io/simDAG/reference/node_multinomial.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate a Node Using Multinomial Regression — node_multinomial","text":"data data.table (something can coerced data.table) containing columns specified parents. parents character vector specifying names parents particular child node . betas numeric matrix length(parents) columns one row class simulated, specifying causal beta coefficients used generate node. intercepts numeric vector one entry class simulated, specifying intercepts used generate node. labels optional character vector giving factor levels generated classes. NULL (default), integers simply used factor levels. output single character string specifying output format. Must one \"factor\" (default), \"character\" \"numeric\". argument labels supplied, output coerced \"character\" default. return_prob Either TRUE FALSE (default). Specifies whether return matrix class probabilities . using function inside node call, set TRUE return matrix. may, however, useful using function , probability generating function node_competing_events function.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_multinomial.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulate a Node Using Multinomial Regression — node_multinomial","text":"function works essentially like node_binomial function. First, matrix betas coefficients used conjunction values defined parents nodes intercepts calculate expected subject-specific probabilities occurrence possible category. done using standard multinomial regression equations. Using probabilities conjunction rcategorical function, single one possible categories drawn individual. Since function produces categorical output (), may difficult use node type parent nodes. Nevertheless, course possible using user-defined node type (see node_custom infos define ).","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_multinomial.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Simulate a Node Using Multinomial Regression — node_multinomial","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_multinomial.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate a Node Using Multinomial Regression — node_multinomial","text":"Returns vector length nrow(data). Depending used arguments, vector may type character, numeric factor. return_prob used instead returns numeric matrix containing one column per possible event nrow(data) rows.","code":""},{"path":[]},{"path":"https://robindenz1.github.io/simDAG/reference/node_multinomial.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate a Node Using Multinomial Regression — node_multinomial","text":"","code":"library(simDAG)  set.seed(3345235)  dag <- empty_dag() +   node(\"age\", type=\"rnorm\", mean=50, sd=4) +   node(\"sex\", type=\"rbernoulli\", p=0.5) +   node(\"UICC\", type=\"multinomial\", parents=c(\"sex\", \"age\"),        betas=matrix(c(0.2, 0.4, 0.1, 0.5, 1.1, 1.2), ncol=2),        intercepts=1)  sim_dat <- sim_from_dag(dag=dag, n_sim=100)"},{"path":"https://robindenz1.github.io/simDAG/reference/node_negative_binomial.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate a Node Using Negative Binomial Regression — node_negative_binomial","title":"Simulate a Node Using Negative Binomial Regression — node_negative_binomial","text":"Data parents used generate node using negative binomial regression applying betas design matrix sampling rnbinom function.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_negative_binomial.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate a Node Using Negative Binomial Regression — node_negative_binomial","text":"","code":"node_negative_binomial(data, parents, formula=NULL, betas,                        intercept, theta)"},{"path":"https://robindenz1.github.io/simDAG/reference/node_negative_binomial.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate a Node Using Negative Binomial Regression — node_negative_binomial","text":"data data.table (something can coerced data.table) containing columns specified parents. parents character vector specifying names parents particular child node . non-linear combinations interaction effects included, user may specify formula argument instead. formula optional formula object describe node generated NULL (default). supplied start ~, nothing else left hand side. right hand side may contain valid formula syntax, + B + B + (^2), allowing non-linear effects. argument defined, need define parents argument. example, using parents=c(\"\", \"B\") equal using formula= ~ + B. betas numeric vector length equal parents, specifying causal beta coefficients used generate node. intercept single number specifying intercept used generating node. theta single number specifying theta parameter (size argument rnbinom).","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_negative_binomial.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulate a Node Using Negative Binomial Regression — node_negative_binomial","text":"function uses linear predictor defined betas input design matrix sample subject-specific negative binomial distribution. calculating linear predictor using data, betas intercept, exponentiating passing mu argument rnbinom function stats package.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_negative_binomial.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Simulate a Node Using Negative Binomial Regression — node_negative_binomial","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_negative_binomial.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate a Node Using Negative Binomial Regression — node_negative_binomial","text":"Returns numeric vector length nrow(data).","code":""},{"path":[]},{"path":"https://robindenz1.github.io/simDAG/reference/node_negative_binomial.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate a Node Using Negative Binomial Regression — node_negative_binomial","text":"","code":"library(simDAG)  set.seed(124554)  dag <- empty_dag() +   node(\"age\", type=\"rnorm\", mean=50, sd=4) +   node(\"sex\", type=\"rbernoulli\", p=0.5) +   node(\"smoking\", type=\"negative_binomial\", theta=0.05,        formula= ~ -2 + sexTRUE*1.1 + age*0.4)  sim_dat <- sim_from_dag(dag=dag, n_sim=100, sort_dag=FALSE)"},{"path":"https://robindenz1.github.io/simDAG/reference/node_poisson.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate a Node Using Poisson Regression — node_poisson","title":"Simulate a Node Using Poisson Regression — node_poisson","text":"Data parents used generate node using poisson regression predicting covariate specific lambda sampling poisson distribution accordingly.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_poisson.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate a Node Using Poisson Regression — node_poisson","text":"","code":"node_poisson(data, parents, formula=NULL, betas, intercept)"},{"path":"https://robindenz1.github.io/simDAG/reference/node_poisson.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate a Node Using Poisson Regression — node_poisson","text":"data data.table (something can coerced data.table) containing columns specified parents. parents character vector specifying names parents particular child node . non-linear combinations interaction effects included, user may specify formula argument instead. formula optional formula object describe node generated NULL (default). supplied start ~, nothing else left hand side. right hand side may contain valid formula syntax, + B + B + (^2), allowing non-linear effects. argument defined, need define parents argument. example, using parents=c(\"\", \"B\") equal using formula= ~ + B. betas numeric vector length equal parents, specifying causal beta coefficients used generate node. intercept single number specifying intercept used generating node.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_poisson.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulate a Node Using Poisson Regression — node_poisson","text":"Essentially, function simply calculates linear predictor defined betas-coefficients, intercept values parents. exponential function applied predictor result passed rpois function. result draw subject-specific poisson distribution, resembling user-defined poisson regression model. Formal Description: Formally, data generation can described : $$Y \\sim Poisson(\\lambda),$$ \\(Poisson()\\) means variable Poisson distributed : $$P_\\lambda(k) = \\frac{\\lambda^k e^{-\\lambda}}{k!}.$$ , \\(k\\) count \\(e\\) eulers number. parameter \\(\\lambda\\) determined : $$\\lambda = \\exp(\\texttt{intercept} + \\texttt{parents}_1 \\cdot \\texttt{betas}_1 + ... + \\texttt{parents}_n \\cdot \\texttt{betas}_n),$$ \\(n\\) number parents (length(parents)). example, given intercept=-15, parents=c(\"\", \"B\"), betas=c(0.2, 1.3) data generation process defined : $$Y \\sim Poisson(\\exp(-15 + \\cdot 0.2 + B \\cdot 1.3)).$$","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_poisson.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Simulate a Node Using Poisson Regression — node_poisson","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_poisson.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate a Node Using Poisson Regression — node_poisson","text":"Returns numeric vector length nrow(data).","code":""},{"path":[]},{"path":"https://robindenz1.github.io/simDAG/reference/node_poisson.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate a Node Using Poisson Regression — node_poisson","text":"","code":"library(simDAG)  set.seed(345345)  dag <- empty_dag() +   node(\"age\", type=\"rnorm\", mean=50, sd=4) +   node(\"sex\", type=\"rbernoulli\", p=0.5) +   node(\"smoking\", type=\"poisson\",        formula= ~ -2 + sexTRUE*1.1 + age*0.4)  sim_dat <- sim_from_dag(dag=dag, n_sim=100)"},{"path":"https://robindenz1.github.io/simDAG/reference/node_time_to_event.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate a Time-to-Event Node in Discrete-Time Simulation — node_time_to_event","title":"Simulate a Time-to-Event Node in Discrete-Time Simulation — node_time_to_event","text":"node essentially models dichotomous time-dependent variable time event important later usage. adds two columns data: name_event (whether person currently event) name_time (time current event started). Past events stored list. Can used inside sim_discrete_time function, outside . See details.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_time_to_event.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate a Time-to-Event Node in Discrete-Time Simulation — node_time_to_event","text":"","code":"node_time_to_event(data, parents, sim_time, name,                    prob_fun, ..., event_duration=1,                    immunity_duration=event_duration,                    time_since_last=FALSE, event_count=FALSE,                    save_past_events=TRUE, check_inputs=TRUE,                    envir)"},{"path":"https://robindenz1.github.io/simDAG/reference/node_time_to_event.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate a Time-to-Event Node in Discrete-Time Simulation — node_time_to_event","text":"data data.table containing columns specified parents. Similar objects data.frames supported. parents character vector specifying names parents particular child node . child nodes valid column names data. state variable definition dependent previous states, columns produced function automatically considered parents without user manually specify . sim_time current time simulation. name name node. used prefix _event, _time columns. time_since_last event_count arguments set TRUE, also used prefix respective columns. prob_fun function returns numeric vector size nrow(data) containing numbers 0 1. numbers specify person-specific probability experiencing event modeled node particular point time simulation. corresponding event generated internally using rbernoulli function. function needs named argument called data. function argument named sim_time, current simulation time also passed function automatically, allowing time-dependent probabilities generated. Alternatively argument can set single number (0 1), resulting fixed probability occurrence every simulated individual every point time. ... arbitrary amount additional named arguments passed prob_fun. Ignore want pass arguments. Also ignored prob_fun single number. event_duration single number > 0 specifying long event last. point time event occurs also counts duration. example, event occurs \\(t = 2\\) duration 3, event set TRUE \\(t \\\\{2, 3, 4\\}\\). Therefore, events must duration least 1 unit (otherwise never happened). immunity_duration single number >= event_duration specifying long person immune event . count internally starts event starts, order use immunity duration 10 time units event event_duration + 10 used. time_since_last Either TRUE FALSE (default), indicating whether additional column generated tracks number time units since individual last event onset. example, individual experienced single event \\(t = 10\\), column NA time 10, 0 time 10 increased 1 point time. another event happens, time set 0 . column named paste0(name, \"_time_since_last\"). difference column ending \"_time\" column set NA immunity_duration . keeps counting end simulation, may useful constructing event-time dependent probability functions. event_count Either TRUE FALSE (default), indicating whether additional column generated tracks number events individual already experienced. column 0 individuals t = 0. time new event occurs, counter increased one. Note new events increase counter. example, individual event t = 10 event_duration 15 value 0 t = 10, value 1 t = 10 afterwards. column named paste0(name, \"_event_count\"). save_past_events event modeled using node recurrent (immunity_duration < Inf & event_duration < Inf), person may experience multiple events course simulation. generally stored tte_past_events list included output sim_discrete_time function. extends runtime increases RAM usage, interested timing previous events using save_states=\"\" functionality can turned setting argument FALSE. check_inputs Whether perform plausibility checks user input . set TRUE default, can set FALSE order speed things using function simulation study something similar. envir used internally efficiently store past event times. used user.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_time_to_event.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulate a Time-to-Event Node in Discrete-Time Simulation — node_time_to_event","text":"performing discrete-time simulation using sim_discrete_time function, standard node functions implemented package usually sufficient capture time-dependent nature interesting variables. Often, variable modelled probability occurring point time. occur, kind influence variables period time goes back normal (). car crash, surgery, vaccination etc. time_to_event node function can used model kinds nodes fairly straightforward fashion. Works: \\(t = 1\\), node initialized first time. adds two columns data: name_event (whether person currently event) name_time (time current event started) name name node. Additionally, adds list max_t entries tte_past_events list returned sim_discrete_time function, records individuals experienced new event point time. nutshell, simply models occurrence event calculating probability occurrence \\(t\\) drawing single bernoulli trial probability. trial \"success\", corresponding event column set TRUE, time column set current simulation time \\(t\\) column storing past event times receive entry. _event column stay TRUE event . duration controlled event_duration parameter. modeling terminal events death, one can simply set parameter Inf, making event eternal. many cases also necessary implement kind immunity event, can done using immunity_duration argument. effectively sets probability another occurrence event 0 next immunity_duration time steps. immunity duration, event may TRUE (event still ongoing) FALSE (event_duration already passed). _time column similarly set time occurrence event reset NA immunity_duration . probability occurrence calculated using function provided user using prob_fun argument. can arbitrary complex function. requirement takes data first argument. columns defined parents argument passed argument automatically. argument called sim_time, current time simulation automatically passed well. arguments can passed using ... syntax. simple example logistic regression node, probability calculated additive linear combination columns defined parents. complex function include simulation-time dependent effects, effects dependent past event times etc. Examples can found vignettes. Used: function never called directly user. Instead, user define DAG object using empty_dag node_td functions set type argument inside node_td call \"time_to_event\". DAG can passed sim_discrete_time function generate desired data. Many examples explanations given vignettes package. can done : type node naturally supports implementation terminal recurrent events may influenced pretty much anything. specifying parents prob_fun arguments correctly, possible create event type dependent past events time--event variables variables general. user can include amount nodes simulation. may also used simulate kind binary time-dependent variable one usually associate name \"event\" well. flexible, require user coding (e.g. creating suitable function prob_fun argument). done : Currently function allows binary events. Categorical event types may implemented using node_competing_events function, works similar fashion.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_time_to_event.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Simulate a Time-to-Event Node in Discrete-Time Simulation — node_time_to_event","text":"Robin Denz, Katharina Meiszl","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_time_to_event.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate a Time-to-Event Node in Discrete-Time Simulation — node_time_to_event","text":"Returns data.table containing least two columns updated values node.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/node_time_to_event.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Simulate a Time-to-Event Node in Discrete-Time Simulation — node_time_to_event","text":"function called outside sim_discrete_time function. makes sense use type node_td function call, described documentation vignettes.","code":""},{"path":[]},{"path":"https://robindenz1.github.io/simDAG/reference/node_time_to_event.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate a Time-to-Event Node in Discrete-Time Simulation — node_time_to_event","text":"","code":"library(simDAG)  ## a simple terminal time-to-event node, with a constant probability of ## occurrence, independent of any other variable dag <- empty_dag() +   node_td(\"death\", type=\"time_to_event\", prob_fun=0.0001,           event_duration=Inf)  ## a simple recurrent time-to-event node with a constant probability of ## occurrence, independent of any other variable dag <- empty_dag() +   node_td(\"car_crash\", type=\"time_to_event\", prob_fun=0.001, event_duration=1)  ## a time-to-event node with a time-dependent probability function that ## has an additional argument prob_car_crash <- function(data, sim_time, base_p) {   return(base_p + sim_time * 0.0001) }  dag <- empty_dag() +   node_td(\"car_crash\", type=\"time_to_event\", prob_fun=prob_car_crash,           event_duration=1, base_p=0.0001)  ## a time-to-event node with a probability function dependent on a ## time-fixed variable prob_car_crash <- function(data) {   ifelse(data$sex==1, 0.001, 0.01) }  dag <- empty_dag() +   node(\"sex\", type=\"rbernoulli\", p=0.5) +   node_td(\"car_crash\", type=\"time_to_event\", prob_fun=prob_car_crash,           parents=\"sex\")  ## a little more complex car crash simulation, where the probability for ## a car crash is dependent on the sex, and the probability of death is ## highly increased for 3 days after a car crash happened prob_car_crash <- function(data) {   ifelse(data$sex==1, 0.001, 0.01) }  prob_death <- function(data) {   ifelse(data$car_crash_event, 0.1, 0.0001) }  dag <- empty_dag() +   node(\"sex\", type=\"rbernoulli\", p=0.5) +   node_td(\"car_crash\", type=\"time_to_event\", prob_fun=prob_car_crash,           parents=\"sex\") +   node_td(\"death\", type=\"time_to_event\", prob_fun=prob_death,           parents=\"car_crash_event\")  # use the sim_discrete_time function to simulate data from one of these DAGs: sim <- sim_discrete_time(dag, n_sim=20, max_t=500)  ## more examples can be found in the vignettes of this package"},{"path":"https://robindenz1.github.io/simDAG/reference/plot.DAG.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot a DAG object — plot.DAG","title":"Plot a DAG object — plot.DAG","text":"Using node information contained DAG object function plots corresponding DAG quick convenient way. options customize plot available, may advisable use packages made explicitly visualize DAGs instead meet users needs.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/plot.DAG.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot a DAG object — plot.DAG","text":"","code":"# S3 method for class 'DAG' plot(x, layout=\"nicely\", node_size=0.2,      node_names=NULL, node_color=\"black\",      node_fill=\"red\", node_linewidth=0.5,      node_linetype=\"solid\", node_alpha=1,      node_text_color=\"black\", node_text_alpha=1,      node_text_size=8, node_text_family=\"sans\",      node_text_fontface=\"bold\", arrow_color=\"black\",      arrow_linetype=\"solid\", arrow_linewidth=1,      arrow_alpha=1, arrow_head_size=0.3,      arrow_head_unit=\"cm\", arrow_type=\"closed\",      arrow_node_dist=0.03, gg_theme=ggplot2::theme_void(),      include_td_nodes=TRUE, mark_td_nodes=TRUE,      ...)"},{"path":"https://robindenz1.github.io/simDAG/reference/plot.DAG.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot a DAG object — plot.DAG","text":"x DAG object created using empty_dag function nodes added using + syntax. See empty_dag node details. layout single character string specifying layout plot. internally calls layout_ function igraph package, offers great variety ways layout nodes graph. Defaults \"nicely\". options : \"as_star\", \"as_tree\", \"in_circle\", \"on_spere\", \"randomly\" many . details see ?layout_. node_size Either single positive number numeric vector one entry per node DAG, specifying radius circles used draw nodes. single number supplied, nodes size (default). node_names character vector one entry node DAG specifying names used nodes NULL (default). NULL, node names set creation DAG object used names. node_color single character string specifying color outline node circles. node_fill single character string specifying color nodes filled. Ignored time-varying nodes present include_td_nodes mark_td_nodes set TRUE. node_linewidth single number specifying width outline node circles. node_linetype single character string specifying linetype outline node circles. node_alpha single number 0 1 specifying transparency level nodes. node_text_color single character string specifying color text inside node circles. node_text_alpha single number 0 1 specifying transparency level text inside node circles. node_text_size single number specifying size text inside node circles. node_text_family single character string specifying family text inside node circles. node_text_fontface single character string specifying fontface text inside node circles. arrow_color single character string specifying color arrows nodes. arrow_linetype single character string specifying linetype arrows. arrow_linewidth single number specifying width arrows. arrow_alpha single number 0 1 specifying transparency level arrows. arrow_head_size single number specifying size arrow heads. unit size parameter can changed using arrow_head_unit argument. arrow_head_unit single character string specifying unit arrow_head_size argument. arrow_type Either \"open\" \"closed\", controls type head arrows . See ?arrow. arrow_node_dist single positive number specifying distance nodes arrows. setting values greater 0 arrows touch node circles, leaving bit space instead. gg_theme ggplot2 theme. default set theme_void, get rid everything plotted nodes (e.g. everything axis background). Might useful change something else searching good parameters number arguments function. include_td_nodes Whether include time-varying nodes added dag using node_td function . one node specified time-fixed time-varying node, parents calls pooled considered time-varying node argument TRUE. , however, also show argument FALSE. case however, parents node standard node call considered. mark_td_nodes Whether distinguish time-varying time-fixed nodes fill color. TRUE, color set automatically using standard ggplot2 palette, ignoring color specified node_fill. Ignored include_td_nodes=FALSE time-varying variables. ... arguments passed layout function specified argument name.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/plot.DAG.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot a DAG object — plot.DAG","text":"function uses igraph package find suitable layout plot uses ggplot2 package conjunction geom_circle function ggforce package plot directed acyclic graph defined DAG object. Since returns ggplot object, user may use standard ggplot2 syntax augment plot save using ggsave function. Note multiple great packages specifically designed plot directed acyclic graphs, igraph package. function meant competitor packages. functionality offered rather limited. designed produce decent plots small DAGs easy create. function enough create adequate plot, users can use dag2matrix function obtain adjacency matrix DAG object directly use matrix igraph package (similar ones) get much better plots. DAG supplied function contains time-varying variables, resulting plot may contain cycles even bi-directional arrows, depending DAG. reason , time-dimension shown plot. Note also even though, technically, every time-varying node parent, arrows showing dependence added plot.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/plot.DAG.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Plot a DAG object — plot.DAG","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/plot.DAG.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot a DAG object — plot.DAG","text":"Returns standard ggplot2 object.","code":""},{"path":[]},{"path":"https://robindenz1.github.io/simDAG/reference/plot.DAG.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot a DAG object — plot.DAG","text":"","code":"library(simDAG)  # 2 root nodes, 1 child node dag <- empty_dag() +   node(\"age\", type=\"rnorm\", mean=50, sd=4) +   node(\"sex\", type=\"rbernoulli\", p=0.5) +   node(\"smoking\", type=\"binomial\", parents=c(\"sex\", \"age\"), betas=c(1.1, 0.4),        intercept=-2)  if (requireNamespace(\"ggplot2\") & requireNamespace(\"ggforce\")) {  library(ggplot2) library(igraph) library(ggforce)  plot(dag)  # get plot using the igraph package instead g1 <- as.igraph(dag) plot(g1)  # plot with a time-varying node dag <- dag +   node_td(\"lottery\", type=\"time_to_event\", parents=c(\"age\", \"smoking\"))  plot(dag) } #> Loading required namespace: ggforce #>  #> Attaching package: ‘igraph’ #> The following objects are masked from ‘package:stats’: #>  #>     decompose, spectrum #> The following object is masked from ‘package:base’: #>  #>     union"},{"path":"https://robindenz1.github.io/simDAG/reference/plot.simDT.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a Simple Flowchart for a Discrete-Time Simulation — plot.simDT","title":"Create a Simple Flowchart for a Discrete-Time Simulation — plot.simDT","text":"Given simDT object obtained sim_discrete_time function, plots relatively simple flowchart simulation performed. Shows general information extracted dag.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/plot.simDT.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a Simple Flowchart for a Discrete-Time Simulation — plot.simDT","text":"","code":"# S3 method for class 'simDT' plot(x, right_boxes=TRUE,      box_hdist=1, box_vdist=1,      box_l_width=0.35, box_l_height=0.23,      box_r_width=box_l_width,      box_r_height=box_l_height + 0.1,      box_alpha=0.5, box_linetype=\"solid\",      box_linewidth=0.5, box_border_colors=NULL,      box_fill_colors=NULL, box_text_color=\"black\",      box_text_alpha=1, box_text_angle=0,      box_text_family=\"sans\", box_text_fontface=\"plain\",      box_text_size=5, box_text_lineheight=1,      box_1_text_left=\"Create initial data\",      box_1_text_right=NULL, box_2_text=\"Increase t by 1\",      box_l_node_labels=NULL, box_r_node_labels=NULL,      box_last_text=paste0(\"t <= \", x$max_t, \"?\"),      arrow_line_type=\"solid\", arrow_line_width=0.5,      arrow_line_color=\"black\", arrow_line_alpha=1,      arrow_head_angle=30, arrow_head_size=0.3,      arrow_head_unit=\"cm\", arrow_head_type=\"closed\",      arrow_left_pad=0.3, hline_width=0.5,      hline_type=\"dashed\", hline_color=\"black\",      hline_alpha=1, ...)"},{"path":"https://robindenz1.github.io/simDAG/reference/plot.simDT.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a Simple Flowchart for a Discrete-Time Simulation — plot.simDT","text":"x simDT object created using sim_discrete_time function. right_boxes Either TRUE (default) FALSE, specifying whether add boxes right additional information nodes left. box_hdist single positive number specifying horizontal distance left right boxes. box_vdist single positive number specifying vertical distance boxes. box_l_width single positive number specifying width boxes left side. box_l_height single positive number specifying height boxes left side. box_r_width single positive number specifying width boxes right side. Ignored right_boxes=FALSE. box_r_height single positive number specifying height boxes right side. Ignored right_boxes=FALSE. box_alpha single number 0 1 specifying transparency level boxes. box_linetype single positive number specifying linetype box outlines. box_linewidth single positive number specifying width box outlines. box_border_colors character vector length two specifying colors box outlines. Set NULL (default) use ggplot2 default colors. box_fill_colors character vector length two specifying colors inside boxes. Set NULL (default) use ggplot2 default colors. box_text_color single character string specifying color text inside boxes. box_text_alpha single number 0 1 specifying transparency level text inside boxes. box_text_angle single positive number specifying angle text inside boxes. box_text_family single character string specifying family text inside boxes. May one \"sans\", \"serif\", \"mono\". box_text_fontface single character string specifying fontface text inside boxes. May one \"plain\", \"bold\", \"italic\", \"bold.italic\". box_text_size single number specifying size text inside boxes. box_text_lineheight single number specifying lineheight text inside boxes. box_1_text_left single character string specifying text inside first box top left side. box_1_text_right single character string specifying text inside first box top right side NULL. NULL (default) simply state variables generated t = 0. box_2_text single character string specifying text inside second box top. box_l_node_labels character vector one entry time-varying node used simulation. used fill boxes left side plot. Set NULL use default values. box_r_node_labels character vector one entry time-varying node used simulation. used fill boxes right side plot. Set NULL use default values. Ignored right_boxes=FALSE. box_last_text single character string specifying text inside last box left side. default uses max_t argument initial function call construct fitting text. arrow_line_type single character string specifying linetype arrows. arrow_line_width single positive number specifying line width arrows. arrow_line_color single character string specifying color arrows. arrow_line_alpha single number 0 1 specifying transparency level arrows. arrow_head_angle single number specifying angle arrow heads. arrow_head_size single number specifying size arrow heads. unit defined arrow_head_size argument. arrow_head_unit single character string specifying unit use specifying arrow_head_size argument. Defaults \"cm\". arrow_head_type single character string specifying type arrow head use. See ?arrow details. arrow_left_pad single positive number specifying distance left boxes arrow line left . hline_width single number specifying width horizontal lines left right boxes. hline_type single character string specifying linetype horizontal lines left right boxes. hline_color single character string specifying color horizontal lines left right boxes. hline_alpha single number 0 1 specifying transparency level horizontal lines left right boxes. ... Currently used.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/plot.simDT.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a Simple Flowchart for a Discrete-Time Simulation — plot.simDT","text":"resulting flowchart includes two columns boxes next . left side always starts two boxes: box creation initial data box increasing simulation time 1. Next, box time-varying variable simDT object. Afterwards another box asks maximum simulation time reached. arrow left points back second box top indicates iterative nature simulation process. right column boxes includes additional information boxes left. text boxes may changed custom text using box_1_text_left, box_1_text_right, box_2_text, box_l_node_labels, box_r_node_labels box_last_text arguments. also possible completely remove left line boxes change various sizes appearances. Although quite options, still rather fixed function nature. One add boxes arrows simple way. general structure may also changed. may useful visualize general idea simulation flow, may limited usage scientific publications simulation complex. graphic created using ggplot2 package output standard ggplot object. means user can change result using standard ggplot syntax (adding stuff, changing geoms, ...).","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/plot.simDT.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a Simple Flowchart for a Discrete-Time Simulation — plot.simDT","text":"Returns standard ggplot object.","code":""},{"path":[]},{"path":"https://robindenz1.github.io/simDAG/reference/plot.simDT.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create a Simple Flowchart for a Discrete-Time Simulation — plot.simDT","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/plot.simDT.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a Simple Flowchart for a Discrete-Time Simulation — plot.simDT","text":"","code":"library(simDAG)  set.seed(435345)  ## exemplary car crash simulation, where the probability for ## a car crash is dependent on the sex, and the probability of death is ## highly increased for 3 days after a car crash happened prob_car_crash <- function(data) {   ifelse(data$sex==1, 0.001, 0.01) }  prob_death <- function(data) {   ifelse(data$car_crash_event, 0.1, 0.0001) }  dag <- empty_dag() +   node(\"sex\", type=\"rbernoulli\", p=0.5) +   node_td(\"car_crash\", type=\"time_to_event\", prob_fun=prob_car_crash,           parents=\"sex\") +   node_td(\"death\", type=\"time_to_event\", prob_fun=prob_death,           parents=\"car_crash_event\")  # generate some data sim <- sim_discrete_time(dag, n_sim=20, max_t=500, save_states=\"last\")  if (requireNamespace(\"ggplot2\")) {  # default plot plot(sim)  # removing boxes on the right plot(sim, right_boxes=FALSE) }"},{"path":"https://robindenz1.github.io/simDAG/reference/rbernoulli.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Random Draws from a Bernoulli Distribution — rbernoulli","title":"Generate Random Draws from a Bernoulli Distribution — rbernoulli","text":"fast implementation generating bernoulli trials. Can take vector probabilities makes useful simulation studies.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/rbernoulli.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Random Draws from a Bernoulli Distribution — rbernoulli","text":"","code":"rbernoulli(n, p=0.5, output=\"logical\")"},{"path":"https://robindenz1.github.io/simDAG/reference/rbernoulli.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Random Draws from a Bernoulli Distribution — rbernoulli","text":"n many draws make. p numeric vector probabilities, used drawing trials. output single character string, specifying format output returned . Must one \"logical\" (default), \"numeric\", \"character\" \"factor\".","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/rbernoulli.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Random Draws from a Bernoulli Distribution — rbernoulli","text":"Internally, uses single call runif, making much faster memory efficient using rbinomial. Note function accepts values p smaller 0 greater 1. p < 0 always return FALSE, p > 1 always return TRUE.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/rbernoulli.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generate Random Draws from a Bernoulli Distribution — rbernoulli","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/rbernoulli.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Random Draws from a Bernoulli Distribution — rbernoulli","text":"Returns vector length n desired output format.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/rbernoulli.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Random Draws from a Bernoulli Distribution — rbernoulli","text":"","code":"library(simDAG)  # generating 5 bernoulli random draws from an unbiased coin rbernoulli(n=5, p=0.5) #> [1]  TRUE  TRUE FALSE FALSE  TRUE  # using different probabilities for each coin throw rbernoulli(n=5, p=c(0.1, 0.2, 0.3, 0.2, 0.7)) #> [1] FALSE FALSE FALSE FALSE  TRUE  # return as numeric instead rbernoulli(n=5, p=0.5, output=\"numeric\") #> [1] 0 0 1 0 0"},{"path":"https://robindenz1.github.io/simDAG/reference/rcategorical.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Random Draws from a Discrete Set of Labels with Associated Probabilities — rcategorical","title":"Generate Random Draws from a Discrete Set of Labels with Associated Probabilities — rcategorical","text":"Allows different class probabilities person supplying matrix one column class one row person.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/rcategorical.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Random Draws from a Discrete Set of Labels with Associated Probabilities — rcategorical","text":"","code":"rcategorical(n, probs, labels=NULL, output=\"numeric\")"},{"path":"https://robindenz1.github.io/simDAG/reference/rcategorical.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Random Draws from a Discrete Set of Labels with Associated Probabilities — rcategorical","text":"n many draws make. Passed size argument sample function probs matrix. probs Either numeric vector probabilities sums one matrix one column desired class n rows. Passed probs argument sample function numeric vector passed. labels vector labels draw . NULL (default), simply uses integers starting 1. Passed x argument sample function probs matrix. output single character string specifying output format results. Must either \"numeric\" (default), \"character\" \"factor\". labels supplied, output parsed characters default.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/rcategorical.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Random Draws from a Discrete Set of Labels with Associated Probabilities — rcategorical","text":"case simple numeric vector (class probabilities draws), function wrapper sample function, make code consistent. uses weighted sampling replacement. Otherwise, custom code used faster standard rmultinom function.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/rcategorical.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generate Random Draws from a Discrete Set of Labels with Associated Probabilities — rcategorical","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/rcategorical.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Random Draws from a Discrete Set of Labels with Associated Probabilities — rcategorical","text":"Returns numeric vector (factor vector coerce2factor=TRUE) length n.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/rcategorical.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Random Draws from a Discrete Set of Labels with Associated Probabilities — rcategorical","text":"","code":"library(simDAG)  rcategorical(n=5, labels=c(\"A\", \"B\", \"C\"), probs=c(0.1, 0.2, 0.7)) #> [1] \"C\" \"C\" \"B\" \"C\" \"C\"  rcategorical(n=2, probs=matrix(c(0.1, 0.2, 0.5, 0.7, 0.4, 0.1), nrow=2)) #> [1] 2 1"},{"path":"https://robindenz1.github.io/simDAG/reference/rconstant.html","id":null,"dir":"Reference","previous_headings":"","what":"Use a single constant value for a root node — rconstant","title":"Use a single constant value for a root node — rconstant","text":"small convenience function simply returns value passed , order allow use constant node root node sim_from_dag function.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/rconstant.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Use a single constant value for a root node — rconstant","text":"","code":"rconstant(n, constant)"},{"path":"https://robindenz1.github.io/simDAG/reference/rconstant.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Use a single constant value for a root node — rconstant","text":"n number times constant repeated. constant single value kind used value resulting variable.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/rconstant.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Use a single constant value for a root node — rconstant","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/rconstant.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Use a single constant value for a root node — rconstant","text":"Returns vector length n type constant.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/rconstant.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Use a single constant value for a root node — rconstant","text":"","code":"library(simDAG)  rconstant(n=10, constant=7) #>  [1] 7 7 7 7 7 7 7 7 7 7  rconstant(n=4, constant=\"Male\") #> [1] \"Male\" \"Male\" \"Male\" \"Male\""},{"path":"https://robindenz1.github.io/simDAG/reference/sim2data.html","id":null,"dir":"Reference","previous_headings":"","what":"Transform sim_discrete_time output into the start-stop, long- or wide-format — sim2data","title":"Transform sim_discrete_time output into the start-stop, long- or wide-format — sim2data","text":"function transforms output sim_discrete_time function single data.table structured start-stop format (also known counting process format), long format (one row per person per point time) wide format (one row per person, one column per point time time-varying variables). See details.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/sim2data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transform sim_discrete_time output into the start-stop, long- or wide-format — sim2data","text":"","code":"sim2data(sim, to, use_saved_states=sim$save_states==\"all\",          overlap=FALSE, target_event=NULL,          keep_only_first=FALSE, remove_not_at_risk=FALSE,          as_data_frame=FALSE, check_inputs=TRUE, ...)  # S3 method for class 'simDT' as.data.table(x, keep.rownames=FALSE, to, overlap=FALSE,               target_event=NULL, keep_only_first=FALSE,               remove_not_at_risk=FALSE,               use_saved_states=x$save_states==\"all\",               check_inputs=TRUE, ...)  # S3 method for class 'simDT' as.data.frame(x, row.names=NULL, optional=FALSE, to,               overlap=FALSE, target_event=NULL,               keep_only_first=FALSE, remove_not_at_risk=FALSE,               use_saved_states=x$save_states==\"all\",               check_inputs=TRUE, ...)"},{"path":"https://robindenz1.github.io/simDAG/reference/sim2data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transform sim_discrete_time output into the start-stop, long- or wide-format — sim2data","text":"sim, x object created sim_discrete_time function. Specifies format output data. Must one : \"start_stop\", \"long\", \"wide\". use_saved_states Whether saved simulation states (argument save_states sim_discrete_time function) used construct resulting data . See details. overlap used =\"start_stop\". Specifies whether intervals overlap . TRUE, \"stop\" column simply increased one, compared output overlap=FALSE. means changes given \\(t\\) recorded start next interval, previous interval ends day. target_event used =\"start_stop\". default (keeping argument NULL) time--event nodes treated equally creating start-stop intervals. can changed supplying single character string argument, naming one time--event node. node treated outcome. output corresponds needed fit Cox proportional hazards model. See details. keep_only_first used =\"start_stop\" target_event NULL. Either TRUE FALSE (default). TRUE, information first event per person discarded. Useful target_event treated terminal variable. remove_not_at_risk used =\"start_stop\" target_event NULL. Either TRUE FALSE (default). TRUE, event_duration immunity_duration target_event taken account constructing start-stop data. precisely, time individuals -risk either still currently experiencing event immune event removed start-stop data. may necessary fitting survival regression models, time-periods counted time -risk. as_data_frame Set argument TRUE return data.frame instead data.table. check_inputs Whether perform input checks (TRUE default). Prints warning messages output may incorrect due missing information. keep.rownames Currently used. row.names Passed .data.frame function called finished data.table. See ?.data.frame information. optional Passed .data.frame function called finished data.table. See ?.data.frame information. ... arguments passed .data.frame (conversion finished data.table data.frame). available directly calling sim2data as_data_frame=TRUE using .data.frame.simDT.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/sim2data.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Transform sim_discrete_time output into the start-stop, long- or wide-format — sim2data","text":"raw output sim_discrete_time function may difficult use analysis. Using one functions, straightforward transform output three different formats, described . Note caution needs applied using function, also described . .data.table .data.frame internally call sim2data exist user convenience. start-stop format: start-stop format (=\"start_stop\"), also known counting process period format corresponds data.table containing multiple rows per person, row corresponds period time variables changed. intervals defined start stop columns. start column gives time period started, stop column denotes time period ended. default intervals coded non-overlapping, meaning edges periods included period . example, respective period exactly 1 point time long, start equal stop. non-overlapping periods desired, user can specify overlap=TRUE instead. default, time--event nodes treated equally. optimal goal fit survival regression models. case, usually want target event treated special way (see example Chiou et al. 2023). general, instead creating new intervals want existing intervals end event times corresponding event indicator. can achieved naming target outcome target_event variable. previously specified duration target event ignored. additionally remove time periods individuals -risk due event still going immune (specified using event_duration immunity_duration parameters node_time_to_event), users may set remove_not_at_risk=TRUE. first occurrence event interest, users may also set keep_only_first=TRUE keep information first event per person. long format: long format (=\"long\") corresponds data.table one row per person per point time. unique person identifier stored .id column unique points time given .time column. wide format: wide format (=\"wide\") corresponds data.table exactly one row per person multiple columns per points time time-varying variable. time-varying variables coded original variable name underscore time-point appended end. example, variable sickness time-point 3 named \"sickness_3\". Output use_saved_states=TRUE: use_saved_states=TRUE, function use data stored past_states list sim object construct resulting data.table. results following behavior, depending save_states option used original sim_discrete_time function call: save_states=\"\": complete data.table desired format information observations points time variables created. safest option, also uses RAM computational time. save_states=\"at_t\": data.table desired format correct information observations user specified times (save_states_at argument) variables created. state simulation times ignored, stored. may useful scenarios, generally discouraged unless good reasons use . warning message printed check_inputs=TRUE. save_states=\"last\": Since last state simulation saved, error message returned. data.table produced. Output use_saved_states=FALSE: use_saved_states=FALSE, function use data stored final state simulation (data object sim) information node_time_to_event objects. tx_nodes time_to_event nodes user cares time_to_event nodes time-fixed variables, best option. data.table desired format correct information observations times produced, correct entries time-varying variables, namely time_to_event nodes. Note information also correct user used save_past_events=TRUE time_to_event nodes. Support competing_events nodes implemented future well. time-varying variables specified tx_nodes argument still appear output, value observed last state simulation. Optional columns created using time_to_event node: using time-dependent node type \"time_to_event\" event_count=TRUE time_since_last=TRUE, columns created using either argument included output =\"start_stop\", included set either \"long\" \"wide\". reason behavior including columns lead nonsense intervals start-stop format, makes sense formats. tx_nodes time_to_event nodes?: want correct output tx_nodes one time_to_event nodes, use save_states=\"\" original sim_discrete_time call. plan add support competing_events save_states arguments near future. Support arbitrary tx_nodes probably take longer.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/sim2data.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Transform sim_discrete_time output into the start-stop, long- or wide-format — sim2data","text":"Using node names \"start\", \"stop\", \".id\", \".time\" names automatically generated time-dependent nodes type \"time_to_event\" may break function.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/sim2data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Transform sim_discrete_time output into the start-stop, long- or wide-format — sim2data","text":"Returns single data.table (data.frame) containing simulated variables desired format.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/sim2data.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Transform sim_discrete_time output into the start-stop, long- or wide-format — sim2data","text":"Robin Denz","code":""},{"path":[]},{"path":"https://robindenz1.github.io/simDAG/reference/sim2data.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Transform sim_discrete_time output into the start-stop, long- or wide-format — sim2data","text":"Sy Han Chiou, Gongjun Xu, Jun Yan, Chiung-Yu Huang (2023). \"Regression Modeling Recurrent Events Possibly Informative Terminal Event Using R Package reReg\". : Journal Statistical Software. 105.5, pp. 1-34.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/sim2data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Transform sim_discrete_time output into the start-stop, long- or wide-format — sim2data","text":"","code":"library(simDAG)  set.seed(435345)  ## exemplary car crash simulation, where the probability for ## a car crash is dependent on the sex, and the probability of death is ## highly increased for 3 days after a car crash happened prob_car_crash <- function(data) {   ifelse(data$sex==1, 0.001, 0.01) }  prob_death <- function(data) {   ifelse(data$car_crash_event, 0.1, 0.001) }  dag <- empty_dag() +   node(\"sex\", type=\"rbernoulli\", p=0.5) +   node_td(\"car_crash\", type=\"time_to_event\", prob_fun=prob_car_crash,           parents=\"sex\", event_duration=3) +   node_td(\"death\", type=\"time_to_event\", prob_fun=prob_death,           parents=\"car_crash_event\", event_duration=Inf)  # generate some data, only saving the last state # not a problem here, because the only time-varying nodes are # time-to-event nodes where the event times are saved sim <- sim_discrete_time(dag, n_sim=20, max_t=500, save_states=\"last\")  # transform to standard start-stop format d_start_stop <- sim2data(sim, to=\"start_stop\") head(d_start_stop) #>      .id start  stop car_crash  death    sex #>    <int> <int> <num>    <lgcl> <lgcl> <lgcl> #> 1:     1     1   114     FALSE  FALSE  FALSE #> 2:     1   115   117      TRUE   TRUE  FALSE #> 3:     1   118   417     FALSE   TRUE  FALSE #> 4:     1   418   420      TRUE   TRUE  FALSE #> 5:     1   421   481     FALSE   TRUE  FALSE #> 6:     1   482   484      TRUE   TRUE  FALSE  # transform to \"death\" centric start-stop format # and keep only information until death, cause it's a terminal event # (this could be used in a Cox model) d_start_stop <- sim2data(sim, to=\"start_stop\", target_event=\"death\",                          keep_only_first=TRUE, overlap=TRUE) head(d_start_stop) #>      .id start  stop car_crash  death    sex #>    <int> <int> <num>    <lgcl> <lgcl> <lgcl> #> 1:     1     1   115     FALSE  FALSE  FALSE #> 2:     1   115   116      TRUE   TRUE  FALSE #> 3:     2     1    42     FALSE  FALSE  FALSE #> 4:     2    42    45      TRUE  FALSE  FALSE #> 5:     2    45   232     FALSE  FALSE  FALSE #> 6:     2   232   235      TRUE  FALSE  FALSE  # transform to long-format d_long <- sim2data(sim, to=\"long\") head(d_long) #> Key: <.id, .time> #>      .id .time car_crash  death    sex #>    <int> <int>    <lgcl> <lgcl> <lgcl> #> 1:     1     1     FALSE  FALSE  FALSE #> 2:     1     2     FALSE  FALSE  FALSE #> 3:     1     3     FALSE  FALSE  FALSE #> 4:     1     4     FALSE  FALSE  FALSE #> 5:     1     5     FALSE  FALSE  FALSE #> 6:     1     6     FALSE  FALSE  FALSE  # transform to wide-format d_wide <- sim2data(sim, to=\"wide\") #head(d_wide)"},{"path":"https://robindenz1.github.io/simDAG/reference/simDAG.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate Data from a DAG and Associated Node Information — simDAG-package","title":"Simulate Data from a DAG and Associated Node Information — simDAG-package","text":"package ? package aims give comprehensive framework simulate static longitudinal data given directed acyclic graph information node. goal make package user-friendly intuitive possible, allowing extreme flexibility keeping underlying code fast RAM efficient possible. features included package? package includes two main simulation functions: sim_from_dag function, can used simulate data previously defined causal DAG node information sim_discrete_time function, implements framework conduct discrete-time simulations. former easy use, deal time-varying variable easily. latter little difficult use (usually requiring user write functions ), allows simulation arbitrarily complex longitudinal data. collection implemented node types, package allows user generate data mix binary, categorical, count time--event data. sim_discrete_time function additionally enables user generate time--event data , desired, mix competing events, recurrent events, time-varying variables influence types censoring. package also includes functions transform resulting data multiple formats, augment existing DAGs, plot DAGs plot flow-chart data generation process. typical workflow using package look like? Users start defining DAG object using empty_dag node functions. DAG can passed one two simulation functions included package. information can found respective documentation pages three vignettes package. use sim_from_dag sim_discrete_time? want simulate data easily described using standard DAG without time-varying variables, use sim_from_dag function. DAG includes time-varying variables, want consider points time can easily describe relations manually, can still use sim_from_dag function. want complex data time-varying variables, particularly time--event outcomes, consider using sim_discrete_time function. features missing package? package currently implements possible child nodes. future like implement child node types, nodes generalized mixed linear models complex survival time models. use package instead simCausal package? simCausal package big inspiration package. contrast , however, allows quite bit flexibility. big difference package includes comprehensive framework discrete-time simulations simCausal package . can get information? documentation pages contain lot information, relevant examples literature references. Additional examples can found vignettes package, can accessed using: vignette(topic=\"v_sim_from_dag\", package=\"simDAG\") vignette(topic=\"v_sim_discrete_time\", package=\"simDAG\") vignette(topic=\"v_covid_example\", package=\"simDAG\") vignette(topic=\"v_using_formulas\", package=\"simDAG\") also working separate article package going published peer-reviewed journal. problem using sim_discrete_time function sim_discrete_time function can become difficult use depending kind data user wants generate. reason put extra effort make documentation examples clear helpful possible. Please consult relevant documentation pages vignettes contacting authors directly programming related questions clearly bugs code. want suggest new feature / want report bug. can ? Bug reports, suggestions feature requests highly welcome. Please file issue official github page contact author directly using supplied e-mail address.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/simDAG.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Simulate Data from a DAG and Associated Node Information — simDAG-package","text":"Banks, Jerry, John S. Carson II, Barry L. Nelson, David M. Nicol (2014). Discrete-Event System Simulation. Vol. 5. Edinburgh Gate: Pearson Education Limited.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/simDAG.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Simulate Data from a DAG and Associated Node Information — simDAG-package","text":"Robin Denz, <robin.denz@rub.de>","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/sim_discrete_time.html","id":null,"dir":"Reference","previous_headings":"","what":"Using Discrete-Time Simulation to Generate Complex Data from a Given DAG and Node Information — sim_discrete_time","title":"Using Discrete-Time Simulation to Generate Complex Data from a Given DAG and Node Information — sim_discrete_time","text":"Similar sim_from_dag function, function can used generate data given DAG. contrast sim_from_dag function, function utilizes discrete-time simulation approach. \"--shelves\" simulation function, rather seen \"framework-function\", making easier create discrete-time-simulations. usually requires custom functions written user. See details.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/sim_discrete_time.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Using Discrete-Time Simulation to Generate Complex Data from a Given DAG and Node Information — sim_discrete_time","text":"","code":"sim_discrete_time(dag, n_sim=NULL, t0_sort_dag=TRUE,                   t0_data=NULL, t0_transform_fun=NULL,                   t0_transform_args=list(), max_t,                   tx_nodes_order=NULL, tx_transform_fun=NULL,                   tx_transform_args=list(),                   save_states=\"last\", save_states_at=NULL,                   verbose=FALSE, check_inputs=TRUE)"},{"path":"https://robindenz1.github.io/simDAG/reference/sim_discrete_time.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Using Discrete-Time Simulation to Generate Complex Data from a Given DAG and Node Information — sim_discrete_time","text":"dag DAG object created using empty_dag function node_td calls added (see details examples). dag contains root nodes child nodes time-fixed (added using node calls), data according DAG generated time = 0. data used starting data following simulation. Alternatively, user can specify t0_data argument directly. either case, supplied dag needs contain least one time-dependent node added using node_td function. n_sim single number specifying many observations generated. data.table supplied t0_data argument, argument ignored. sample size correspond number rows t0_data. t0_sort_dag Corresponds sort_dag argument sim_from_dag function. Ignored t0_data specified. t0_data optional data.table like object (also accepts data.frame, tibble etc.) containing values relevant variables \\(t = 0\\). dataset transformed time according node functions specified tx_nodes. Alternatively, data \\(t = 0\\) may generated automatically function standard node calls added dag. t0_transform_fun optional function takes data created \\(t = 0\\) first argument. function applied starting data output replace data.table. Can used perform arbitrary data transformations starting data created. Set NULL (default) use functionality. t0_transform_args named list additional arguments passed t0_transform_fun. Ignored t0_transform_fun=NULL. max_t single integer specifying final point time simulation carried . simulation start \\(t = 1\\) (creating starting data arguments ) continue max_t increasing time one unit every step, updating time-dependent nodes along way. tx_nodes_order numeric vector specifying order time-dependent nodes added dag object using node_td function executed time step. NULL (default), nodes generated order originally added. tx_transform_fun optional function takes data created every point time  \\(t > 0\\) first argument simulation time second argument. function applied data node functions point time executed output replace previous data.table. Can used perform arbitrary data transformations every point time. Set NULL (default) use functionality. tx_transform_args named list additional arguments passed tx_transform_fun. Ignored tx_transform_fun=NULL. save_states Specifies amount simulation states saved output object. one \"\", \"at_t\" \"last\" (default). set \"\", list containing data.table every point time added output object. \"at_t\", states specific points time specified save_states_at argument saved (plus final state). \"last\", final state data.table added output. save_states_at specific points time simulated data.table saved. Ignored save_states!=\"at_t\". verbose TRUE prints one line every point time node function executed. can useful debugging custom node functions. Defaults FALSE. check_inputs Whether perform plausibility checks user input . set TRUE default, can set FALSE order speed things using function simulation study something similar.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/sim_discrete_time.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Using Discrete-Time Simulation to Generate Complex Data from a Given DAG and Node Information — sim_discrete_time","text":"Sometimes necessary simulate complex data described easily single DAG node information. may case desired data contain multiple time-dependent variables time--event variables event time-dependent effects events. example data vaccinations effects occurrence adverse events (see vignette). Discrete-Time Simulation can effective tool generate kinds datasets. Discrete-Time Simulation?: discrete-time simulation, entities certain states associated change discrete points time. example, entities people state alive dead. example generate 100 people covariates age, sex etc.. start increasing simulation time one day. person now check person died using bernoulli trial, probability dying generated point time based covariates. simulation time increased process repeated reach max_t. Due iterative process easy simulate arbitrarily complex data. covariates may change time arbitrary ways, event probability can functional relationship covariates . want model event type terminal, occurrence cardiovascular disease, events can easily simulated dependent timing number previous events. Since Discrete-Time Simulation special case Discrete-Event Simulation, introductory textbooks latter can great help getting better understanding former. Works: Internally, function works first simulating data using sim_from_dag function. Alternatively, user can supply custom data.table using t0_data argument. data defines state entities \\(t = 0\\). Afterwards, simulation time increased one unit data transformed place calling node function defined time-dependent nodes added dag using node_td function (either order added dag object order defined tx_nodes_order argument). Usually, transformation changes state entities way. example age variable, probably increase age person one time unit every step. max_t reached, resulting data.table returned. contains state entities last step additional information experienced events (node_time_to_event used time-dependent node). Multiple -depth examples can found vignettes package. Specifying dag argument: dag argument specified described node documentation page. examples specific discrete-time simulations can found vignettes examples. difference specifying dag sim_from_dag function dag contain least one time-dependent node added using node_td function. Usage formula argument non-linear interaction terms discouraged performance reasons. Speed Considerations: functions package rely data.table backend order make memory efficient faster. however important note time simulate dataset increases non-linearly increasing max_t value additional time-dependent nodes. usually concern smaller datasets, n_sim large (say > 1 million) function get rather slow. Note also using formula argument lot computationally expensive using parents, betas approach specify certain nodes. output?: function outputs simDT object, data.table. obtain actual dataset output function, users use sim2data function transform desired format. Currently, long-format, wide-format start-stop format supported. See sim2data information. Words Caution: cases necessary user write functions order actually use sim_discrete_time function. Unlike sim_from_dag function, many popular node types can implemented re-usable way, discrete-time simulation always require custom input user. price users pay almost unlimited flexibility offered simulation methodology.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/sim_discrete_time.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Using Discrete-Time Simulation to Generate Complex Data from a Given DAG and Node Information — sim_discrete_time","text":"Robin Denz, Katharina Meiszl","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/sim_discrete_time.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Using Discrete-Time Simulation to Generate Complex Data from a Given DAG and Node Information — sim_discrete_time","text":"Returns simDT object, containing general information simulated data well final state simulated dataset (states, depending specification save_states argument). particular, includes following objects: past_states: list containing generated data specified points time. save_states: value save_states argument supplied user. data: data time max_t. tte_past_events: list storing times events happened variables type \"time_to_event\", specified. ce_past_events: list storing times events happened variables type \"competing_events\", specified. ce_past_causes: list storing types events happened variables type \"competing_events\", specified. tx_nodes: list time-varying nodes, specified supplied dag object. max_t: value max_t, supplied user. t0_var_names: character vector containing names variable names vary time. obtain single dataset function can processed , please use sim2data function.","code":""},{"path":[]},{"path":"https://robindenz1.github.io/simDAG/reference/sim_discrete_time.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Using Discrete-Time Simulation to Generate Complex Data from a Given DAG and Node Information — sim_discrete_time","text":"Tang, Jiangjun, George Leu, und Hussein . Abbass. 2020. Simulation Computational Red Teaming Problem Solving. Hoboken: IEEE Press. Banks, Jerry, John S. Carson II, Barry L. Nelson, David M. Nicol (2014). Discrete-Event System Simulation. Vol. 5. Edinburgh Gate: Pearson Education Limited.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/sim_discrete_time.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Using Discrete-Time Simulation to Generate Complex Data from a Given DAG and Node Information — sim_discrete_time","text":"","code":"library(simDAG)  set.seed(454236)  ## simulating death dependent on age, sex, bmi ## NOTE: this example is explained in detail in one of the vignettes  # initializing a DAG with nodes for generating data at t0 dag <- empty_dag() +   node(\"age\", type=\"rnorm\", mean=50, sd=4) +   node(\"sex\", type=\"rbernoulli\", p=0.5) +   node(\"bmi\", type=\"gaussian\", parents=c(\"sex\", \"age\"),        betas=c(1.1, 0.4), intercept=12, error=2)  # a function that increases age as time goes on node_advance_age <- function(data) {   return(data$age + 1/365) }  # a function to calculate the probability of death as a # linear combination of age, sex and bmi on the log scale prob_death <- function(data, beta_age, beta_sex, beta_bmi, intercept) {   prob <- intercept + data$age*beta_age + data$sex*beta_sex + data$bmi*beta_bmi   prob <- 1/(1 + exp(-prob))   return(prob) }  # adding time-dependent nodes to the dag dag <- dag +   node_td(\"age\", type=\"advance_age\", parents=\"age\") +   node_td(\"death\", type=\"time_to_event\", parents=c(\"age\", \"sex\", \"bmi\"),           prob_fun=prob_death, beta_age=0.1, beta_bmi=0.3, beta_sex=-0.2,           intercept=-20, event_duration=Inf, save_past_events=FALSE) #> Error in get(paste0(\"node_\", type)): object 'node_advance_age' not found  # run simulation for 100 people, 50 days long sim_dt <- sim_discrete_time(n_sim=100,                             dag=dag,                             max_t=50,                             verbose=FALSE) #> Error in check_inputs_sim_discrete_time(n_sim = n_sim, dag = dag, t0_sort_dag = t0_sort_dag,     t0_data = t0_data, t0_transform_fun = t0_transform_fun, t0_transform_args = t0_transform_args,     max_t = max_t, tx_nodes = tx_nodes, tx_nodes_order = tx_nodes_order,     tx_transform_fun = tx_transform_fun, tx_transform_args = tx_transform_args,     save_states = save_states, save_states_at = save_states_at,     verbose = verbose): 'dag' must contain at least one time-varying node added using the node_td() function. For dag objects with no time-varying nodes, please use the sim_from_dag() function instead."},{"path":"https://robindenz1.github.io/simDAG/reference/sim_from_DAG.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate Data from a Given DAG and Node Information — sim_from_dag","title":"Simulate Data from a Given DAG and Node Information — sim_from_dag","text":"function can used generate data given DAG. additionally requires information node distributions, beta coefficients , depending node type, parameters intercepts.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/sim_from_DAG.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate Data from a Given DAG and Node Information — sim_from_dag","text":"","code":"sim_from_dag(dag, n_sim, sort_dag=FALSE, check_inputs=TRUE)"},{"path":"https://robindenz1.github.io/simDAG/reference/sim_from_DAG.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate Data from a Given DAG and Node Information — sim_from_dag","text":"dag DAG object created using empty_dag function nodes added using + syntax. See details. n_sim single number specifying many observations generated. sort_dag Whether topologically sort DAG starting simulation . nodes dag already added topologically sorted manner, argument can kept FALSE safe computation time. usually safe much time though, internally uses topological_sort function Rfast package, fast. check_inputs Whether perform plausibility checks user input . set TRUE default, can set FALSE order speed things using function simulation study something similar.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/sim_from_DAG.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulate Data from a Given DAG and Node Information — sim_from_dag","text":"Works: First, n_sim ..d. samples root nodes drawn. Children nodes generated one one according specified relationships causal coefficients. example, lets suppose two root nodes, age sex. generated normal distribution bernoulli distribution respectively. Afterward, child node height generated using variables parents according linear regression defined coefficients, intercept sigma (random error). works every DAG least one topological ordering, linear ordering vertices every directed edge \\(u\\) \\(v\\), vertex \\(u\\) comes \\(v\\) ordering. using sort_dag=TRUE ensured nodes processed ordering. procedure simple theory, can get complex manually coded. function offers simplified workflow requiring user define dag object appropriate information (see documentation node function). sample size n_sim generated DAG specified two arguments. Specifying DAG: Concrete details specify needed dag object given documentation page node function vignettes package. Can function create longitudinal data? Yes . theoretically can, user-specified dag directly specifies node desired point time. Using sim_discrete_time better cases. brief discussion topic can found vignettes package. time-dependent nodes added dag using node_td calls, function may used. sim_discrete_time function work case.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/sim_from_DAG.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Simulate Data from a Given DAG and Node Information — sim_from_dag","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/sim_from_DAG.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate Data from a Given DAG and Node Information — sim_from_dag","text":"Returns single data.table including simulated data (least) one column per node specified dag n_sim rows.","code":""},{"path":[]},{"path":"https://robindenz1.github.io/simDAG/reference/sim_from_DAG.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate Data from a Given DAG and Node Information — sim_from_dag","text":"","code":"library(simDAG)  set.seed(345345)  dag <- empty_dag() +   node(\"age\", type=\"rnorm\", mean=50, sd=4) +   node(\"sex\", type=\"rbernoulli\", p=0.5) +   node(\"bmi\", type=\"gaussian\", parents=c(\"sex\", \"age\"),        betas=c(1.1, 0.4), intercept=12, error=2)  sim_dat <- sim_from_dag(dag=dag, n_sim=1000)  # More examples for each directly supported node type as well as for custom # nodes can be found in the documentation page of the respective node function"},{"path":"https://robindenz1.github.io/simDAG/reference/sim_n_datasets.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate multiple datasets from a single DAG object — sim_n_datasets","title":"Generate multiple datasets from a single DAG object — sim_n_datasets","text":"function takes single DAG object generates list multiple datasets, possible using parallel processing","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/sim_n_datasets.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate multiple datasets from a single DAG object — sim_n_datasets","text":"","code":"sim_n_datasets(dag, n_sim, n_repeats, n_cores=parallel::detectCores(),                data_format=\"raw\", data_format_args=list(),                seed=stats::runif(1), progressbar=TRUE, ...)"},{"path":"https://robindenz1.github.io/simDAG/reference/sim_n_datasets.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate multiple datasets from a single DAG object — sim_n_datasets","text":"dag DAG object created using empty_dag function nodes added using + syntax. See ?empty_dag ?node details. dag contains time-varying nodes added using node_td function, sim_discrete_time function used generate data. Otherwise, sim_from_dag function used. n_sim single number specifying many observations per dataset generated. n_repeats single number specifying many datasets generated. n_cores single number specifying amount cores used. n_cores = 1, simple loop used generate datasets parallel processing. n_cores > 1 used, doSNOW package used conjunction doRNG package generate datasets parallel. using doRNG package, results completely reproducible setting seed. data_format optional character string specifying output format generated datasets. \"raw\" (default), dataset returned generated respective data generation function. dag contains time-varying nodes added using node_td function argument set either \"start_stop\", \"long\" \"wide\", sim2data function called transform dataset defined format. string supplied, regardless whether time-varying nodes included dag , function name given string called transform data. can function. requirement named argument called data. Arguments function can set using data_format_args argument (see ). data_format_args optional list named arguments passed function specified data_format. Set list() use arguments. Ignored data_format=\"raw\". seed seed random number generator. supplying value argument, results replicable, even parallel processing used generate datasets (using n_cores > 1), thanks magic performed doRNG package. progressbar Either TRUE (default) FALSE, specifying whether progressbar used. Currently works n_cores > 1, ignored otherwise. ... arguments passed sim_from_dag function (dag contain time-varying nodes) sim_discrete_time function (dag contains time-varying nodes).","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/sim_n_datasets.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate multiple datasets from a single DAG object — sim_n_datasets","text":"Generating number datasets single defined dag object usually first step conducting monte-carlo simulation studies. simply convenience function automates process using parallel processing (specified). Note complex monte-carlo simulations function may ideal, allow user vary aspects data-generation mechanism inside main loop, can handle single dag. example, user wants simulate n_repeats datasets confounding n_repeats datasets without confounding, /call function twice. optimal, setting clusters parallel processing takes processing time. many different dags used, make sense write single function generates dag desired settings. can sadly automated us though.","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/sim_n_datasets.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generate multiple datasets from a single DAG object — sim_n_datasets","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/simDAG/reference/sim_n_datasets.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate multiple datasets from a single DAG object — sim_n_datasets","text":"Returns list length n_repeats containing datasets generated according supplied dag object.","code":""},{"path":[]},{"path":"https://robindenz1.github.io/simDAG/reference/sim_n_datasets.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate multiple datasets from a single DAG object — sim_n_datasets","text":"","code":"library(simDAG)  # some example DAG dag <- empty_dag() +   node(\"death\", type=\"binomial\", parents=c(\"age\", \"sex\"), betas=c(1, 2),        intercept=-10) +   node(\"age\", type=\"rnorm\", mean=10, sd=2) +   node(\"sex\", parents=\"\", type=\"rbernoulli\", p=0.5) +   node(\"smoking\", parents=c(\"sex\", \"age\"), type=\"binomial\",        betas=c(0.6, 0.2), intercept=-2)  # generate 10 datasets without parallel processing out <- sim_n_datasets(dag, n_repeats=10, n_cores=1, n_sim=100)  if (requireNamespace(\"doSNOW\") & requireNamespace(\"doRNG\") &     requireNamespace(\"foreach\")) {  # generate 10 datasets with parallel processing out <- sim_n_datasets(dag, n_repeats=10, n_cores=2, n_sim=100) } #> Loading required namespace: doSNOW #> Loading required namespace: doRNG #>    |                                                                               |                                                                      |   0% #> Error in e$fun(obj, substitute(ex), parent.frame(), e$data): worker initialization failed: package ‘RcppZiggurat’ could not be loaded  # generate 10 datasets and transforming the output # (using the sim2data function internally) dag <- dag + node_td(\"CV\", type=\"time_to_event\", prob_fun=0.01) out <- sim_n_datasets(dag, n_repeats=10, n_cores=1, n_sim=100,                       max_t=20, data_format=\"start_stop\") #> Loading required namespace: Rfast #> Error in dyn.load(file, DLLpath = DLLpath, ...): unable to load shared object '/home/runner/work/_temp/Library/RcppZiggurat/libs/RcppZiggurat.so': #>   libgsl.so.27: cannot open shared object file: No such file or directory"},{"path":"https://robindenz1.github.io/simDAG/news/index.html","id":"simdag-010","dir":"Changelog","previous_headings":"","what":"simDAG 0.1.0","title":"simDAG 0.1.0","text":"CRAN release: 2023-08-28 first release package","code":""},{"path":"https://robindenz1.github.io/simDAG/news/index.html","id":"simdag-011","dir":"Changelog","previous_headings":"","what":"simDAG 0.1.1","title":"simDAG 0.1.1","text":"CRAN release: 2024-03-07 Enhancements node() node_td() now support character vectors ‘name’ argument, allowing easy creation multiple nodes definition Bug Fixes bug node_time_to_event() function lead immunity_duration parameter used incorrectly. Since events still recorded correctly, apparent using save_states=\"\". Works correctly now. small bug dag2matrix() dag object contained root nodes. case, logical matrix returned. Now returns correct numeric matrix. New Features Added sim_n_datasets() function generate multiple datasets single dag object, possibly using multicore processing Documentation Minor changes documentation pages Minor changes vignettes","code":""},{"path":"https://robindenz1.github.io/simDAG/news/index.html","id":"simdag-012","dir":"Changelog","previous_headings":"","what":"simDAG 0.1.2","title":"simDAG 0.1.2","text":"CRAN release: 2024-06-13 General simDAG longer lists data.table “Depends” description file. instead listed “Imports” recommended data.table crew Enhancements Print underlying structural equations summary.DAG() summary.DAG.node() Added overlap argument long2start_stop() sim2data() directly create start-stop data overlapping durations, needed statistical models Added target_event keep_only_first arguments sim2data() related functions, allow direct transformation model-ready dataset Made long2start_stop() function computationally efficient Bug Fixes Fixed small bug input checks node_time_to_event() function, printed error arguments prob_fun supplied, even arguments default values Fixed bug print.DAG.node() occurred time--event node parents supplied Fixed bug sim2data() lead inconsistent results event_duration=0 used one nodes type “time_to_event” “competing_events”. made realize event durations smaller 1 make sense. now longer allowed default node types changed accordingly. Fixed bug resulted errors interaction terms supplied formula objects child nodes New Features Added .igraph.DAG() method extends generic function .igraph() conveniently parse DAG objects igraph objects Added .data.table.simDT() .data.frame.simDT() user convenience Documentation Documentation pages nodes now include formal descriptions data generation mechanism Re-wrote documentation page custom node definition","code":""},{"path":"https://robindenz1.github.io/simDAG/news/index.html","id":"simdag-020","dir":"Changelog","previous_headings":"","what":"simDAG 0.2.0","title":"simDAG 0.2.0","text":"CRAN release: 2024-09-03 Enhancements Added output argument rbernoulli() function allow different output formats. Change default sort_dag sim_from_dag() TRUE FALSE. Moved functionality coerce2factor coerce2numeric arguments rcategorical(), node_multinomial() node_binomial() output argument consistent syntax easier usage. now allowed directly supply functions type argument node() node_td(). Passing optional arguments layout function plot.DAG() now supported. Bug Fixes node_fill argument plot.DAG() function longer ignored mark_td_nodes set TRUE. New Features Added new enhanced formula interface, allows users directly type underlying structural equations many node types. replaces old formula argument. Standard formulas (without betas intercepts) still supported, longer mentioned documentation deprecated future versions. Documentation Added new vignette explaining detail new enhanced formula interface node() function works.","code":""},{"path":"https://robindenz1.github.io/simDAG/news/index.html","id":"simdag-021","dir":"Changelog","previous_headings":"","what":"simDAG 0.2.1","title":"simDAG 0.2.1","text":"Enhancements External variables may now used formula interface using eval() calls. Added remove_not_at_risk argument sim2data() function. Bug Fixes Using sim2data() time-dependent nodes type node_competing_events() longer results unwarranted error message. Using column name \"time\" time argument long2start_stop() now works properly. New Features Added node_identity() function allow users directly calculate nodes R expression nodes without need define new function. Documentation Added examples formula vignette.","code":""}]
